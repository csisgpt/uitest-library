import {
  require_pickBy
} from "./chunk-JFNIADNN.js";
import {
  require_mapValues
} from "./chunk-PQT6NA3V.js";
import {
  require_pick
} from "./chunk-6D4DUZ3O.js";
import {
  require_isPlainObject
} from "./chunk-YXMB6HMD.js";
import {
  dedent,
  esm_default
} from "./chunk-JLBFQ2EK.js";
import {
  require_global
} from "./chunk-MRU72WJ5.js";
import {
  __commonJS,
  __export,
  __require,
  __toESM
} from "./chunk-624QZG55.js";

// node_modules/@storybook/preview-api/node_modules/memoizerific/memoizerific.js
var require_memoizerific = __commonJS({
  "node_modules/@storybook/preview-api/node_modules/memoizerific/memoizerific.js"(exports, module) {
    (function(f3) {
      if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f3();
      } else if (typeof define === "function" && define.amd) {
        define([], f3);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.memoizerific = f3();
      }
    })(function() {
      var define2, module2, exports2;
      return function e(t, n, r) {
        function s(o2, u2) {
          if (!n[o2]) {
            if (!t[o2]) {
              var a = typeof __require == "function" && __require;
              if (!u2 && a)
                return a(o2, true);
              if (i)
                return i(o2, true);
              var f3 = new Error("Cannot find module '" + o2 + "'");
              throw f3.code = "MODULE_NOT_FOUND", f3;
            }
            var l2 = n[o2] = { exports: {} };
            t[o2][0].call(l2.exports, function(e2) {
              var n2 = t[o2][1][e2];
              return s(n2 ? n2 : e2);
            }, l2, l2.exports, e, t, n, r);
          }
          return n[o2].exports;
        }
        var i = typeof __require == "function" && __require;
        for (var o = 0; o < r.length; o++)
          s(r[o]);
        return s;
      }({ 1: [function(_dereq_, module3, exports3) {
        module3.exports = function(forceSimilar) {
          if (typeof Map !== "function" || forceSimilar) {
            var Similar = _dereq_("./similar");
            return new Similar();
          } else {
            return /* @__PURE__ */ new Map();
          }
        };
      }, { "./similar": 2 }], 2: [function(_dereq_, module3, exports3) {
        function Similar() {
          this.list = [];
          this.lastItem = void 0;
          this.size = 0;
          return this;
        }
        Similar.prototype.get = function(key2) {
          var index;
          if (this.lastItem && this.isEqual(this.lastItem.key, key2)) {
            return this.lastItem.val;
          }
          index = this.indexOf(key2);
          if (index >= 0) {
            this.lastItem = this.list[index];
            return this.list[index].val;
          }
          return void 0;
        };
        Similar.prototype.set = function(key2, val) {
          var index;
          if (this.lastItem && this.isEqual(this.lastItem.key, key2)) {
            this.lastItem.val = val;
            return this;
          }
          index = this.indexOf(key2);
          if (index >= 0) {
            this.lastItem = this.list[index];
            this.list[index].val = val;
            return this;
          }
          this.lastItem = { key: key2, val };
          this.list.push(this.lastItem);
          this.size++;
          return this;
        };
        Similar.prototype.delete = function(key2) {
          var index;
          if (this.lastItem && this.isEqual(this.lastItem.key, key2)) {
            this.lastItem = void 0;
          }
          index = this.indexOf(key2);
          if (index >= 0) {
            this.size--;
            return this.list.splice(index, 1)[0];
          }
          return void 0;
        };
        Similar.prototype.has = function(key2) {
          var index;
          if (this.lastItem && this.isEqual(this.lastItem.key, key2)) {
            return true;
          }
          index = this.indexOf(key2);
          if (index >= 0) {
            this.lastItem = this.list[index];
            return true;
          }
          return false;
        };
        Similar.prototype.forEach = function(callback, thisArg) {
          var i;
          for (i = 0; i < this.size; i++) {
            callback.call(thisArg || this, this.list[i].val, this.list[i].key, this);
          }
        };
        Similar.prototype.indexOf = function(key2) {
          var i;
          for (i = 0; i < this.size; i++) {
            if (this.isEqual(this.list[i].key, key2)) {
              return i;
            }
          }
          return -1;
        };
        Similar.prototype.isEqual = function(val1, val2) {
          return val1 === val2 || val1 !== val1 && val2 !== val2;
        };
        module3.exports = Similar;
      }, {}], 3: [function(_dereq_, module3, exports3) {
        var MapOrSimilar = _dereq_("map-or-similar");
        module3.exports = function(limit) {
          var cache = new MapOrSimilar(false), lru = [];
          return function(fn) {
            var memoizerific = function() {
              var currentCache = cache, newMap, fnResult, argsLengthMinusOne = arguments.length - 1, lruPath = Array(argsLengthMinusOne + 1), isMemoized = true, i;
              if ((memoizerific.numArgs || memoizerific.numArgs === 0) && memoizerific.numArgs !== argsLengthMinusOne + 1) {
                throw new Error("Memoizerific functions should always be called with the same number of arguments");
              }
              for (i = 0; i < argsLengthMinusOne; i++) {
                lruPath[i] = {
                  cacheItem: currentCache,
                  arg: arguments[i]
                };
                if (currentCache.has(arguments[i])) {
                  currentCache = currentCache.get(arguments[i]);
                  continue;
                }
                isMemoized = false;
                newMap = new MapOrSimilar(false);
                currentCache.set(arguments[i], newMap);
                currentCache = newMap;
              }
              if (isMemoized) {
                if (currentCache.has(arguments[argsLengthMinusOne])) {
                  fnResult = currentCache.get(arguments[argsLengthMinusOne]);
                } else {
                  isMemoized = false;
                }
              }
              if (!isMemoized) {
                fnResult = fn.apply(null, arguments);
                currentCache.set(arguments[argsLengthMinusOne], fnResult);
              }
              if (limit > 0) {
                lruPath[argsLengthMinusOne] = {
                  cacheItem: currentCache,
                  arg: arguments[argsLengthMinusOne]
                };
                if (isMemoized) {
                  moveToMostRecentLru(lru, lruPath);
                } else {
                  lru.push(lruPath);
                }
                if (lru.length > limit) {
                  removeCachedResult(lru.shift());
                }
              }
              memoizerific.wasMemoized = isMemoized;
              memoizerific.numArgs = argsLengthMinusOne + 1;
              return fnResult;
            };
            memoizerific.limit = limit;
            memoizerific.wasMemoized = false;
            memoizerific.cache = cache;
            memoizerific.lru = lru;
            return memoizerific;
          };
        };
        function moveToMostRecentLru(lru, lruPath) {
          var lruLen = lru.length, lruPathLen = lruPath.length, isMatch, i, ii;
          for (i = 0; i < lruLen; i++) {
            isMatch = true;
            for (ii = 0; ii < lruPathLen; ii++) {
              if (!isEqual(lru[i][ii].arg, lruPath[ii].arg)) {
                isMatch = false;
                break;
              }
            }
            if (isMatch) {
              break;
            }
          }
          lru.push(lru.splice(i, 1)[0]);
        }
        function removeCachedResult(removedLru) {
          var removedLruLen = removedLru.length, currentLru = removedLru[removedLruLen - 1], tmp, i;
          currentLru.cacheItem.delete(currentLru.arg);
          for (i = removedLruLen - 2; i >= 0; i--) {
            currentLru = removedLru[i];
            tmp = currentLru.cacheItem.get(currentLru.arg);
            if (!tmp || !tmp.size) {
              currentLru.cacheItem.delete(currentLru.arg);
            } else {
              break;
            }
          }
        }
        function isEqual(val1, val2) {
          return val1 === val2 || val1 !== val1 && val2 !== val2;
        }
      }, { "map-or-similar": 1 }] }, {}, [3])(3);
    });
  }
});

// node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/es-errors/type.js"(exports, module) {
    "use strict";
    module.exports = TypeError;
  }
});

// (disabled):node_modules/@storybook/preview-api/node_modules/object-inspect/util.inspect
var require_util = __commonJS({
  "(disabled):node_modules/@storybook/preview-api/node_modules/object-inspect/util.inspect"() {
  }
});

// node_modules/@storybook/preview-api/node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/@storybook/preview-api/node_modules/object-inspect/index.js"(exports, module) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString2 = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O2) {
      return O2.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol2(inspectCustom) ? inspectCustom : null;
    var quotes = {
      __proto__: null,
      "double": '"',
      single: "'"
    };
    var quoteREs = {
      __proto__: null,
      "double": /(["\\])/g,
      single: /(['\\])/g
    };
    module.exports = function inspect_(obj, options2, depth, seen) {
      var opts = options2 || {};
      if (has2(opts, "quoteStyle") && !has2(quotes, opts.quoteStyle)) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has2(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has2(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has2(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has2(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray2(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value2, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has2(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value2, newOpts, depth + 1, seen);
        }
        return inspect_(value2, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name2 = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name2 ? ": " + name2 : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol2(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray2(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value2, key2) {
            mapParts.push(inspect(key2, obj, true) + " => " + inspect(value2, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value2) {
            setParts.push(inspect(value2, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (typeof globalThis !== "undefined" && obj === globalThis || typeof global !== "undefined" && obj === global) {
        return "{ [object globalThis] }";
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject3 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject3 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject3 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var style = opts.quoteStyle || defaultStyle;
      var quoteChar = quotes[style];
      return quoteChar + s + quoteChar;
    }
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    function canTrustToString(obj) {
      return !toStringTag || !(typeof obj === "object" && (toStringTag in obj || typeof obj[toStringTag] !== "undefined"));
    }
    function isArray2(obj) {
      return toStr(obj) === "[object Array]" && canTrustToString(obj);
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && canTrustToString(obj);
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && canTrustToString(obj);
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && canTrustToString(obj);
    }
    function isString(obj) {
      return toStr(obj) === "[object String]" && canTrustToString(obj);
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && canTrustToString(obj);
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && canTrustToString(obj);
    }
    function isSymbol2(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key2) {
      return key2 in this;
    };
    function has2(obj, key2) {
      return hasOwn.call(obj, key2);
    }
    function toStr(obj) {
      return objectToString2.call(obj);
    }
    function nameOf(f3) {
      if (f3.name) {
        return f3.name;
      }
      var m2 = $match.call(functionToString.call(f3), /^function\s*([\w$]+)/);
      if (m2) {
        return m2[1];
      }
      return null;
    }
    function indexOf(xs, x2) {
      if (xs.indexOf) {
        return xs.indexOf(x2);
      }
      for (var i = 0, l2 = xs.length; i < l2; i++) {
        if (xs[i] === x2) {
          return i;
        }
      }
      return -1;
    }
    function isMap(x2) {
      if (!mapSize || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        mapSize.call(x2);
        try {
          setSize.call(x2);
        } catch (s) {
          return true;
        }
        return x2 instanceof Map;
      } catch (e) {
      }
      return false;
    }
    function isWeakMap(x2) {
      if (!weakMapHas || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x2, weakMapHas);
        try {
          weakSetHas.call(x2, weakSetHas);
        } catch (s) {
          return true;
        }
        return x2 instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    function isWeakRef(x2) {
      if (!weakRefDeref || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x2);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isSet(x2) {
      if (!setSize || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        setSize.call(x2);
        try {
          mapSize.call(x2);
        } catch (m2) {
          return true;
        }
        return x2 instanceof Set;
      } catch (e) {
      }
      return false;
    }
    function isWeakSet(x2) {
      if (!weakSetHas || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x2, weakSetHas);
        try {
          weakMapHas.call(x2, weakMapHas);
        } catch (s) {
          return true;
        }
        return x2 instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    function isElement(x2) {
      if (!x2 || typeof x2 !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x2 instanceof HTMLElement) {
        return true;
      }
      return typeof x2.nodeName === "string" && typeof x2.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var quoteRE = quoteREs[opts.quoteStyle || "single"];
      quoteRE.lastIndex = 0;
      var s = $replace.call($replace.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c) {
      var n = c.charCodeAt(0);
      var x2 = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x2) {
        return "\\" + x2;
      }
      return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray2(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has2(obj, i) ? inspect(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k2 = 0; k2 < syms.length; k2++) {
          symMap["$" + syms[k2]] = syms[k2];
        }
      }
      for (var key2 in obj) {
        if (!has2(obj, key2)) {
          continue;
        }
        if (isArr && String(Number(key2)) === key2 && key2 < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key2] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key2)) {
          xs.push(inspect(key2, obj) + ": " + inspect(obj[key2], obj));
        } else {
          xs.push(key2 + ": " + inspect(obj[key2], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// node_modules/@storybook/preview-api/node_modules/side-channel-list/index.js
var require_side_channel_list = __commonJS({
  "node_modules/@storybook/preview-api/node_modules/side-channel-list/index.js"(exports, module) {
    "use strict";
    var inspect = require_object_inspect();
    var $TypeError = require_type();
    var listGetNode = function(list, key2, isDelete) {
      var prev = list;
      var curr;
      for (; (curr = prev.next) != null; prev = curr) {
        if (curr.key === key2) {
          prev.next = curr.next;
          if (!isDelete) {
            curr.next = /** @type {NonNullable<typeof list.next>} */
            list.next;
            list.next = curr;
          }
          return curr;
        }
      }
    };
    var listGet = function(objects, key2) {
      if (!objects) {
        return void 0;
      }
      var node = listGetNode(objects, key2);
      return node && node.value;
    };
    var listSet = function(objects, key2, value2) {
      var node = listGetNode(objects, key2);
      if (node) {
        node.value = value2;
      } else {
        objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */
        {
          // eslint-disable-line no-param-reassign, no-extra-parens
          key: key2,
          next: objects.next,
          value: value2
        };
      }
    };
    var listHas = function(objects, key2) {
      if (!objects) {
        return false;
      }
      return !!listGetNode(objects, key2);
    };
    var listDelete = function(objects, key2) {
      if (objects) {
        return listGetNode(objects, key2, true);
      }
    };
    module.exports = function getSideChannelList() {
      var $o;
      var channel = {
        assert: function(key2) {
          if (!channel.has(key2)) {
            throw new $TypeError("Side channel does not contain " + inspect(key2));
          }
        },
        "delete": function(key2) {
          var root3 = $o && $o.next;
          var deletedNode = listDelete($o, key2);
          if (deletedNode && root3 && root3 === deletedNode) {
            $o = void 0;
          }
          return !!deletedNode;
        },
        get: function(key2) {
          return listGet($o, key2);
        },
        has: function(key2) {
          return listHas($o, key2);
        },
        set: function(key2, value2) {
          if (!$o) {
            $o = {
              next: void 0
            };
          }
          listSet(
            /** @type {NonNullable<typeof $o>} */
            $o,
            key2,
            value2
          );
        }
      };
      return channel;
    };
  }
});

// node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "node_modules/es-object-atoms/index.js"(exports, module) {
    "use strict";
    module.exports = Object;
  }
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/es-errors/index.js"(exports, module) {
    "use strict";
    module.exports = Error;
  }
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/es-errors/eval.js"(exports, module) {
    "use strict";
    module.exports = EvalError;
  }
});

// node_modules/es-errors/range.js
var require_range = __commonJS({
  "node_modules/es-errors/range.js"(exports, module) {
    "use strict";
    module.exports = RangeError;
  }
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "node_modules/es-errors/ref.js"(exports, module) {
    "use strict";
    module.exports = ReferenceError;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports, module) {
    "use strict";
    module.exports = SyntaxError;
  }
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/es-errors/uri.js"(exports, module) {
    "use strict";
    module.exports = URIError;
  }
});

// node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "node_modules/math-intrinsics/abs.js"(exports, module) {
    "use strict";
    module.exports = Math.abs;
  }
});

// node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "node_modules/math-intrinsics/floor.js"(exports, module) {
    "use strict";
    module.exports = Math.floor;
  }
});

// node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "node_modules/math-intrinsics/max.js"(exports, module) {
    "use strict";
    module.exports = Math.max;
  }
});

// node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "node_modules/math-intrinsics/min.js"(exports, module) {
    "use strict";
    module.exports = Math.min;
  }
});

// node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "node_modules/math-intrinsics/pow.js"(exports, module) {
    "use strict";
    module.exports = Math.pow;
  }
});

// node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "node_modules/math-intrinsics/round.js"(exports, module) {
    "use strict";
    module.exports = Math.round;
  }
});

// node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/math-intrinsics/isNaN.js"(exports, module) {
    "use strict";
    module.exports = Number.isNaN || function isNaN2(a) {
      return a !== a;
    };
  }
});

// node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "node_modules/math-intrinsics/sign.js"(exports, module) {
    "use strict";
    var $isNaN = require_isNaN();
    module.exports = function sign(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    };
  }
});

// node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "node_modules/gopd/gOPD.js"(exports, module) {
    "use strict";
    module.exports = Object.getOwnPropertyDescriptor;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports, module) {
    "use strict";
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports, module) {
    "use strict";
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module.exports = $defineProperty;
  }
});

// node_modules/has-symbols/shams.js
var require_shams3 = __commonJS({
  "node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols2 = __commonJS({
  "node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams3();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Reflect.getPrototypeOf.js"(exports, module) {
    "use strict";
    module.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Object.getPrototypeOf.js"(exports, module) {
    "use strict";
    var $Object = require_es_object_atoms();
    module.exports = $Object.getPrototypeOf || null;
  }
});

// node_modules/function-bind/implementation.js
var require_implementation2 = __commonJS({
  "node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args2 = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result2 = target.apply(
            this,
            concatty(args2, arguments)
          );
          if (Object(result2) === result2) {
            return result2;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args2, arguments)
        );
      };
      var boundLength = max(0, target.length - args2.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind2 = __commonJS({
  "node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var implementation = require_implementation2();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "node_modules/call-bind-apply-helpers/functionCall.js"(exports, module) {
    "use strict";
    module.exports = Function.prototype.call;
  }
});

// node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "node_modules/call-bind-apply-helpers/functionApply.js"(exports, module) {
    "use strict";
    module.exports = Function.prototype.apply;
  }
});

// node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "node_modules/call-bind-apply-helpers/reflectApply.js"(exports, module) {
    "use strict";
    module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "node_modules/call-bind-apply-helpers/actualApply.js"(exports, module) {
    "use strict";
    var bind = require_function_bind2();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module.exports = $reflectApply || bind.call($call, $apply);
  }
});

// node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "node_modules/call-bind-apply-helpers/index.js"(exports, module) {
    "use strict";
    var bind = require_function_bind2();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module.exports = function callBindBasic(args2) {
      if (args2.length < 1 || typeof args2[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind, $call, args2);
    };
  }
});

// node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "node_modules/dunder-proto/get.js"(exports, module) {
    "use strict";
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
        throw e;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      function getDunder(value2) {
        return $getPrototypeOf(value2 == null ? value2 : $Object(value2));
      }
    ) : false;
  }
});

// node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "node_modules/get-proto/index.js"(exports, module) {
    "use strict";
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module.exports = reflectGetProto ? function getProto(O2) {
      return reflectGetProto(O2);
    } : originalGetProto ? function getProto(O2) {
      if (!O2 || typeof O2 !== "object" && typeof O2 !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O2);
    } : getDunderProto ? function getProto(O2) {
      return getDunderProto(O2);
    } : null;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports, module) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind2();
    module.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic2 = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor = require_floor();
    var max = require_max();
    var min = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols2()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max,
      "%Math.min%": min,
      "%Math.pow%": pow,
      "%Math.round%": round,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name2) {
      var value2;
      if (name2 === "%AsyncFunction%") {
        value2 = getEvalledConstructor("async function () {}");
      } else if (name2 === "%GeneratorFunction%") {
        value2 = getEvalledConstructor("function* () {}");
      } else if (name2 === "%AsyncGeneratorFunction%") {
        value2 = getEvalledConstructor("async function* () {}");
      } else if (name2 === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value2 = fn.prototype;
        }
      } else if (name2 === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value2 = getProto(gen.prototype);
        }
      }
      INTRINSICS[name2] = value2;
      return value2;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind2();
    var hasOwn = require_hasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName2 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar2 = /\\(\\)?/g;
    var stringToPath2 = function stringToPath3(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result2 = [];
      $replace(string, rePropName2, function(match, number, quote, subString) {
        result2[result2.length] = quote ? $replace(subString, reEscapeChar2, "$1") : number || match;
      });
      return result2;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
      var intrinsicName = name2;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value2 = INTRINSICS[intrinsicName];
        if (value2 === needsEval) {
          value2 = doEval(intrinsicName);
        }
        if (typeof value2 === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value: value2
        };
      }
      throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
    };
    module.exports = function GetIntrinsic(name2, allowMissing) {
      if (typeof name2 !== "string" || name2.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name2) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath2(name2);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value2 = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value2 = INTRINSICS[intrinsicRealName];
        } else if (value2 != null) {
          if (!(part in value2)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name2 + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value2, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value2 = desc.get;
            } else {
              value2 = value2[part];
            }
          } else {
            isOwn = hasOwn(value2, part);
            value2 = value2[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value2;
          }
        }
      }
      return value2;
    };
  }
});

// node_modules/call-bound/index.js
var require_call_bound = __commonJS({
  "node_modules/call-bound/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic2();
    var callBindBasic = require_call_bind_apply_helpers();
    var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
    module.exports = function callBoundIntrinsic(name2, allowMissing) {
      var intrinsic = (
        /** @type {(this: unknown, ...args: unknown[]) => unknown} */
        GetIntrinsic(name2, !!allowMissing)
      );
      if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
        return callBindBasic(
          /** @type {const} */
          [intrinsic]
        );
      }
      return intrinsic;
    };
  }
});

// node_modules/@storybook/preview-api/node_modules/side-channel-map/index.js
var require_side_channel_map = __commonJS({
  "node_modules/@storybook/preview-api/node_modules/side-channel-map/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic2();
    var callBound = require_call_bound();
    var inspect = require_object_inspect();
    var $TypeError = require_type();
    var $Map = GetIntrinsic("%Map%", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var $mapDelete = callBound("Map.prototype.delete", true);
    var $mapSize = callBound("Map.prototype.size", true);
    module.exports = !!$Map && /** @type {Exclude<import('.'), false>} */
    function getSideChannelMap() {
      var $m;
      var channel = {
        assert: function(key2) {
          if (!channel.has(key2)) {
            throw new $TypeError("Side channel does not contain " + inspect(key2));
          }
        },
        "delete": function(key2) {
          if ($m) {
            var result2 = $mapDelete($m, key2);
            if ($mapSize($m) === 0) {
              $m = void 0;
            }
            return result2;
          }
          return false;
        },
        get: function(key2) {
          if ($m) {
            return $mapGet($m, key2);
          }
        },
        has: function(key2) {
          if ($m) {
            return $mapHas($m, key2);
          }
          return false;
        },
        set: function(key2, value2) {
          if (!$m) {
            $m = new $Map();
          }
          $mapSet($m, key2, value2);
        }
      };
      return channel;
    };
  }
});

// node_modules/@storybook/preview-api/node_modules/side-channel-weakmap/index.js
var require_side_channel_weakmap = __commonJS({
  "node_modules/@storybook/preview-api/node_modules/side-channel-weakmap/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic2();
    var callBound = require_call_bound();
    var inspect = require_object_inspect();
    var getSideChannelMap = require_side_channel_map();
    var $TypeError = require_type();
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $weakMapDelete = callBound("WeakMap.prototype.delete", true);
    module.exports = $WeakMap ? (
      /** @type {Exclude<import('.'), false>} */
      function getSideChannelWeakMap() {
        var $wm;
        var $m;
        var channel = {
          assert: function(key2) {
            if (!channel.has(key2)) {
              throw new $TypeError("Side channel does not contain " + inspect(key2));
            }
          },
          "delete": function(key2) {
            if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
              if ($wm) {
                return $weakMapDelete($wm, key2);
              }
            } else if (getSideChannelMap) {
              if ($m) {
                return $m["delete"](key2);
              }
            }
            return false;
          },
          get: function(key2) {
            if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
              if ($wm) {
                return $weakMapGet($wm, key2);
              }
            }
            return $m && $m.get(key2);
          },
          has: function(key2) {
            if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
              if ($wm) {
                return $weakMapHas($wm, key2);
              }
            }
            return !!$m && $m.has(key2);
          },
          set: function(key2, value2) {
            if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
              if (!$wm) {
                $wm = new $WeakMap();
              }
              $weakMapSet($wm, key2, value2);
            } else if (getSideChannelMap) {
              if (!$m) {
                $m = getSideChannelMap();
              }
              $m.set(key2, value2);
            }
          }
        };
        return channel;
      }
    ) : getSideChannelMap;
  }
});

// node_modules/@storybook/preview-api/node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "node_modules/@storybook/preview-api/node_modules/side-channel/index.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var inspect = require_object_inspect();
    var getSideChannelList = require_side_channel_list();
    var getSideChannelMap = require_side_channel_map();
    var getSideChannelWeakMap = require_side_channel_weakmap();
    var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
    module.exports = function getSideChannel() {
      var $channelData;
      var channel = {
        assert: function(key2) {
          if (!channel.has(key2)) {
            throw new $TypeError("Side channel does not contain " + inspect(key2));
          }
        },
        "delete": function(key2) {
          return !!$channelData && $channelData["delete"](key2);
        },
        get: function(key2) {
          return $channelData && $channelData.get(key2);
        },
        has: function(key2) {
          return !!$channelData && $channelData.has(key2);
        },
        set: function(key2, value2) {
          if (!$channelData) {
            $channelData = makeChannel();
          }
          $channelData.set(key2, value2);
        }
      };
      return channel;
    };
  }
});

// node_modules/@storybook/preview-api/node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "node_modules/@storybook/preview-api/node_modules/qs/lib/formats.js"(exports, module) {
    "use strict";
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value2) {
          return replace.call(value2, percentTwenties, "+");
        },
        RFC3986: function(value2) {
          return String(value2);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// node_modules/@storybook/preview-api/node_modules/qs/lib/utils.js
var require_utils = __commonJS({
  "node_modules/@storybook/preview-api/node_modules/qs/lib/utils.js"(exports, module) {
    "use strict";
    var formats = require_formats();
    var has2 = Object.prototype.hasOwnProperty;
    var isArray2 = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray2(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source2, options2) {
      var obj = options2 && options2.plainObjects ? { __proto__: null } : {};
      for (var i = 0; i < source2.length; ++i) {
        if (typeof source2[i] !== "undefined") {
          obj[i] = source2[i];
        }
      }
      return obj;
    };
    var merge = function merge2(target, source2, options2) {
      if (!source2) {
        return target;
      }
      if (typeof source2 !== "object" && typeof source2 !== "function") {
        if (isArray2(target)) {
          target.push(source2);
        } else if (target && typeof target === "object") {
          if (options2 && (options2.plainObjects || options2.allowPrototypes) || !has2.call(Object.prototype, source2)) {
            target[source2] = true;
          }
        } else {
          return [target, source2];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source2);
      }
      var mergeTarget = target;
      if (isArray2(target) && !isArray2(source2)) {
        mergeTarget = arrayToObject(target, options2);
      }
      if (isArray2(target) && isArray2(source2)) {
        source2.forEach(function(item, i) {
          if (has2.call(target, i)) {
            var targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge2(targetItem, item, options2);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source2).reduce(function(acc, key2) {
        var value2 = source2[key2];
        if (has2.call(acc, key2)) {
          acc[key2] = merge2(acc[key2], value2, options2);
        } else {
          acc[key2] = value2;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source2) {
      return Object.keys(source2).reduce(function(acc, key2) {
        acc[key2] = source2[key2];
        return acc;
      }, target);
    };
    var decode = function(str, defaultDecoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    };
    var limit = 1024;
    var encode = function encode2(str, defaultEncoder, charset, kind, format) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var j = 0; j < string.length; j += limit) {
        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
        var arr = [];
        for (var i = 0; i < segment.length; ++i) {
          var c = segment.charCodeAt(i);
          if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats.RFC1738 && (c === 40 || c === 41)) {
            arr[arr.length] = segment.charAt(i);
            continue;
          }
          if (c < 128) {
            arr[arr.length] = hexTable[c];
            continue;
          }
          if (c < 2048) {
            arr[arr.length] = hexTable[192 | c >> 6] + hexTable[128 | c & 63];
            continue;
          }
          if (c < 55296 || c >= 57344) {
            arr[arr.length] = hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
            continue;
          }
          i += 1;
          c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
          arr[arr.length] = hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
        }
        out += arr.join("");
      }
      return out;
    };
    var compact = function compact2(value2) {
      var queue = [{ obj: { o: value2 }, prop: "o" }];
      var refs2 = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
          var key2 = keys[j];
          var val = obj[key2];
          if (typeof val === "object" && val !== null && refs2.indexOf(val) === -1) {
            queue.push({ obj, prop: key2 });
            refs2.push(val);
          }
        }
      }
      compactQueue(queue);
      return value2;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a, b) {
      return [].concat(a, b);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray2(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
          mapped.push(fn(val[i]));
        }
        return mapped;
      }
      return fn(val);
    };
    module.exports = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode,
      encode,
      isBuffer,
      isRegExp,
      maybeMap,
      merge
    };
  }
});

// node_modules/@storybook/preview-api/node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/@storybook/preview-api/node_modules/qs/lib/stringify.js"(exports, module) {
    "use strict";
    var getSideChannel = require_side_channel();
    var utils = require_utils();
    var formats = require_formats();
    var has2 = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix2) {
        return prefix2 + "[]";
      },
      comma: "comma",
      indices: function indices(prefix2, key2) {
        return prefix2 + "[" + key2 + "]";
      },
      repeat: function repeat(prefix2) {
        return prefix2;
      }
    };
    var isArray2 = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray2(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      allowEmptyArrays: false,
      arrayFormat: "indices",
      charset: "utf-8",
      charsetSentinel: false,
      commaRoundTrip: false,
      delimiter: "&",
      encode: true,
      encodeDotInKeys: false,
      encoder: utils.encode,
      encodeValuesOnly: false,
      filter: void 0,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v2) {
      return typeof v2 === "string" || typeof v2 === "number" || typeof v2 === "boolean" || typeof v2 === "symbol" || typeof v2 === "bigint";
    };
    var sentinel = {};
    var stringify2 = function stringify3(object, prefix2, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter === "function") {
        obj = filter(prefix2, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray2(obj)) {
        obj = utils.maybeMap(obj, function(value3) {
          if (value3 instanceof Date) {
            return serializeDate(value3);
          }
          return value3;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix2, defaults.encoder, charset, "key", format) : prefix2;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix2 : encoder(prefix2, defaults.encoder, charset, "key", format);
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
        }
        return [formatter(prefix2) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray2(obj)) {
        if (encodeValuesOnly && encoder) {
          obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray2(filter)) {
        objKeys = filter;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      var encodedPrefix = encodeDotInKeys ? String(prefix2).replace(/\./g, "%2E") : String(prefix2);
      var adjustedPrefix = commaRoundTrip && isArray2(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
      if (allowEmptyArrays && isArray2(obj) && obj.length === 0) {
        return adjustedPrefix + "[]";
      }
      for (var j = 0; j < objKeys.length; ++j) {
        var key2 = objKeys[j];
        var value2 = typeof key2 === "object" && key2 && typeof key2.value !== "undefined" ? key2.value : obj[key2];
        if (skipNulls && value2 === null) {
          continue;
        }
        var encodedKey = allowDots && encodeDotInKeys ? String(key2).replace(/\./g, "%2E") : String(key2);
        var keyPrefix = isArray2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify3(
          value2,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          allowEmptyArrays,
          strictNullHandling,
          skipNulls,
          encodeDotInKeys,
          generateArrayPrefix === "comma" && encodeValuesOnly && isArray2(obj) ? null : encoder,
          filter,
          sort,
          allowDots,
          serializeDate,
          format,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
        throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has2.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter = defaults.filter;
      if (typeof opts.filter === "function" || isArray2(opts.filter)) {
        filter = opts.filter;
      }
      var arrayFormat;
      if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if ("indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = defaults.arrayFormat;
      }
      if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: !!opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module.exports = function(object, opts) {
      var obj = object;
      var options2 = normalizeStringifyOptions(opts);
      var objKeys;
      var filter;
      if (typeof options2.filter === "function") {
        filter = options2.filter;
        obj = filter("", obj);
      } else if (isArray2(options2.filter)) {
        filter = options2.filter;
        objKeys = filter;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var generateArrayPrefix = arrayPrefixGenerators[options2.arrayFormat];
      var commaRoundTrip = generateArrayPrefix === "comma" && options2.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options2.sort) {
        objKeys.sort(options2.sort);
      }
      var sideChannel = getSideChannel();
      for (var i = 0; i < objKeys.length; ++i) {
        var key2 = objKeys[i];
        var value2 = obj[key2];
        if (options2.skipNulls && value2 === null) {
          continue;
        }
        pushToArray(keys, stringify2(
          value2,
          key2,
          generateArrayPrefix,
          commaRoundTrip,
          options2.allowEmptyArrays,
          options2.strictNullHandling,
          options2.skipNulls,
          options2.encodeDotInKeys,
          options2.encode ? options2.encoder : null,
          options2.filter,
          options2.sort,
          options2.allowDots,
          options2.serializeDate,
          options2.format,
          options2.formatter,
          options2.encodeValuesOnly,
          options2.charset,
          sideChannel
        ));
      }
      var joined = keys.join(options2.delimiter);
      var prefix2 = options2.addQueryPrefix === true ? "?" : "";
      if (options2.charsetSentinel) {
        if (options2.charset === "iso-8859-1") {
          prefix2 += "utf8=%26%2310003%3B&";
        } else {
          prefix2 += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix2 + joined : "";
    };
  }
});

// node_modules/@storybook/preview-api/node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "node_modules/@storybook/preview-api/node_modules/qs/lib/parse.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var has2 = Object.prototype.hasOwnProperty;
    var isArray2 = Array.isArray;
    var defaults = {
      allowDots: false,
      allowEmptyArrays: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decodeDotInKeys: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      duplicates: "combine",
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictDepth: false,
      strictNullHandling: false,
      throwOnLimitExceeded: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options2, currentArrayLength) {
      if (val && typeof val === "string" && options2.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      if (options2.throwOnLimitExceeded && currentArrayLength >= options2.arrayLimit) {
        throw new RangeError("Array limit exceeded. Only " + options2.arrayLimit + " element" + (options2.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options2) {
      var obj = { __proto__: null };
      var cleanStr = options2.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      var limit = options2.parameterLimit === Infinity ? void 0 : options2.parameterLimit;
      var parts = cleanStr.split(
        options2.delimiter,
        options2.throwOnLimitExceeded ? limit + 1 : limit
      );
      if (options2.throwOnLimitExceeded && parts.length > limit) {
        throw new RangeError("Parameter limit exceeded. Only " + limit + " parameter" + (limit === 1 ? "" : "s") + " allowed.");
      }
      var skipIndex = -1;
      var i;
      var charset = options2.charset;
      if (options2.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
          if (parts[i].indexOf("utf8=") === 0) {
            if (parts[i] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i;
            i = parts.length;
          }
        }
      }
      for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
          continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key2;
        var val;
        if (pos === -1) {
          key2 = options2.decoder(part, defaults.decoder, charset, "key");
          val = options2.strictNullHandling ? null : "";
        } else {
          key2 = options2.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(
              part.slice(pos + 1),
              options2,
              isArray2(obj[key2]) ? obj[key2].length : 0
            ),
            function(encodedVal) {
              return options2.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val && options2.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(String(val));
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray2(val) ? [val] : val;
        }
        var existing = has2.call(obj, key2);
        if (existing && options2.duplicates === "combine") {
          obj[key2] = utils.combine(obj[key2], val);
        } else if (!existing || options2.duplicates === "last") {
          obj[key2] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options2, valuesParsed) {
      var currentArrayLength = 0;
      if (chain.length > 0 && chain[chain.length - 1] === "[]") {
        var parentKey = chain.slice(0, -1).join("");
        currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
      }
      var leaf = valuesParsed ? val : parseArrayValue(val, options2, currentArrayLength);
      for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root3 = chain[i];
        if (root3 === "[]" && options2.parseArrays) {
          obj = options2.allowEmptyArrays && (leaf === "" || options2.strictNullHandling && leaf === null) ? [] : utils.combine([], leaf);
        } else {
          obj = options2.plainObjects ? { __proto__: null } : {};
          var cleanRoot = root3.charAt(0) === "[" && root3.charAt(root3.length - 1) === "]" ? root3.slice(1, -1) : root3;
          var decodedRoot = options2.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
          var index = parseInt(decodedRoot, 10);
          if (!options2.parseArrays && decodedRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root3 !== decodedRoot && String(index) === decodedRoot && index >= 0 && (options2.parseArrays && index <= options2.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else if (decodedRoot !== "__proto__") {
            obj[decodedRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options2, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key2 = options2.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options2.depth > 0 && brackets.exec(key2);
      var parent = segment ? key2.slice(0, segment.index) : key2;
      var keys = [];
      if (parent) {
        if (!options2.plainObjects && has2.call(Object.prototype, parent)) {
          if (!options2.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i = 0;
      while (options2.depth > 0 && (segment = child.exec(key2)) !== null && i < options2.depth) {
        i += 1;
        if (!options2.plainObjects && has2.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options2.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        if (options2.strictDepth === true) {
          throw new RangeError("Input depth exceeded depth option of " + options2.depth + " and strictDepth is true");
        }
        keys.push("[" + key2.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options2, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
        throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      if (typeof opts.throwOnLimitExceeded !== "undefined" && typeof opts.throwOnLimitExceeded !== "boolean") {
        throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      var duplicates = typeof opts.duplicates === "undefined" ? defaults.duplicates : opts.duplicates;
      if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
        throw new TypeError("The duplicates option must be either combine, first, or last");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults.strictDepth,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling,
        throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === "boolean" ? opts.throwOnLimitExceeded : false
      };
    };
    module.exports = function(str, opts) {
      var options2 = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options2.plainObjects ? { __proto__: null } : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options2) : str;
      var obj = options2.plainObjects ? { __proto__: null } : {};
      var keys = Object.keys(tempObj);
      for (var i = 0; i < keys.length; ++i) {
        var key2 = keys[i];
        var newObj = parseKeys(key2, tempObj[key2], options2, typeof str === "string");
        obj = utils.merge(obj, newObj, options2);
      }
      if (options2.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// node_modules/@storybook/preview-api/node_modules/qs/lib/index.js
var require_lib = __commonJS({
  "node_modules/@storybook/preview-api/node_modules/qs/lib/index.js"(exports, module) {
    "use strict";
    var stringify2 = require_stringify();
    var parse3 = require_parse();
    var formats = require_formats();
    module.exports = {
      formats,
      parse: parse3,
      stringify: stringify2
    };
  }
});

// node_modules/@storybook/preview-api/node_modules/synchronous-promise/index.js
var require_synchronous_promise = __commonJS({
  "node_modules/@storybook/preview-api/node_modules/synchronous-promise/index.js"(exports, module) {
    "use strict";
    function makeArrayFrom(obj) {
      return Array.prototype.slice.apply(obj);
    }
    var PENDING = "pending";
    var RESOLVED = "resolved";
    var REJECTED = "rejected";
    function SynchronousPromise4(handler) {
      this.status = PENDING;
      this._continuations = [];
      this._parent = null;
      this._paused = false;
      if (handler) {
        handler.call(
          this,
          this._continueWith.bind(this),
          this._failWith.bind(this)
        );
      }
    }
    function looksLikeAPromise(obj) {
      return obj && typeof obj.then === "function";
    }
    function passThrough(value2) {
      return value2;
    }
    SynchronousPromise4.prototype = {
      then: function(nextFn, catchFn) {
        var next = SynchronousPromise4.unresolved()._setParent(this);
        if (this._isRejected()) {
          if (this._paused) {
            this._continuations.push({
              promise: next,
              nextFn,
              catchFn
            });
            return next;
          }
          if (catchFn) {
            try {
              var catchResult = catchFn(this._error);
              if (looksLikeAPromise(catchResult)) {
                this._chainPromiseData(catchResult, next);
                return next;
              } else {
                return SynchronousPromise4.resolve(catchResult)._setParent(this);
              }
            } catch (e) {
              return SynchronousPromise4.reject(e)._setParent(this);
            }
          }
          return SynchronousPromise4.reject(this._error)._setParent(this);
        }
        this._continuations.push({
          promise: next,
          nextFn,
          catchFn
        });
        this._runResolutions();
        return next;
      },
      catch: function(handler) {
        if (this._isResolved()) {
          return SynchronousPromise4.resolve(this._data)._setParent(this);
        }
        var next = SynchronousPromise4.unresolved()._setParent(this);
        this._continuations.push({
          promise: next,
          catchFn: handler
        });
        this._runRejections();
        return next;
      },
      finally: function(callback) {
        var ran = false;
        function runFinally(result2, err) {
          if (!ran) {
            ran = true;
            if (!callback) {
              callback = passThrough;
            }
            var callbackResult = callback(result2);
            if (looksLikeAPromise(callbackResult)) {
              return callbackResult.then(function() {
                if (err) {
                  throw err;
                }
                return result2;
              });
            } else {
              return result2;
            }
          }
        }
        return this.then(function(result2) {
          return runFinally(result2);
        }).catch(function(err) {
          return runFinally(null, err);
        });
      },
      pause: function() {
        this._paused = true;
        return this;
      },
      resume: function() {
        var firstPaused = this._findFirstPaused();
        if (firstPaused) {
          firstPaused._paused = false;
          firstPaused._runResolutions();
          firstPaused._runRejections();
        }
        return this;
      },
      _findAncestry: function() {
        return this._continuations.reduce(function(acc, cur) {
          if (cur.promise) {
            var node = {
              promise: cur.promise,
              children: cur.promise._findAncestry()
            };
            acc.push(node);
          }
          return acc;
        }, []);
      },
      _setParent: function(parent) {
        if (this._parent) {
          throw new Error("parent already set");
        }
        this._parent = parent;
        return this;
      },
      _continueWith: function(data) {
        var firstPending = this._findFirstPending();
        if (firstPending) {
          firstPending._data = data;
          firstPending._setResolved();
        }
      },
      _findFirstPending: function() {
        return this._findFirstAncestor(function(test) {
          return test._isPending && test._isPending();
        });
      },
      _findFirstPaused: function() {
        return this._findFirstAncestor(function(test) {
          return test._paused;
        });
      },
      _findFirstAncestor: function(matching) {
        var test = this;
        var result2;
        while (test) {
          if (matching(test)) {
            result2 = test;
          }
          test = test._parent;
        }
        return result2;
      },
      _failWith: function(error) {
        var firstRejected = this._findFirstPending();
        if (firstRejected) {
          firstRejected._error = error;
          firstRejected._setRejected();
        }
      },
      _takeContinuations: function() {
        return this._continuations.splice(0, this._continuations.length);
      },
      _runRejections: function() {
        if (this._paused || !this._isRejected()) {
          return;
        }
        var error = this._error, continuations = this._takeContinuations(), self2 = this;
        continuations.forEach(function(cont) {
          if (cont.catchFn) {
            try {
              var catchResult = cont.catchFn(error);
              self2._handleUserFunctionResult(catchResult, cont.promise);
            } catch (e) {
              cont.promise.reject(e);
            }
          } else {
            cont.promise.reject(error);
          }
        });
      },
      _runResolutions: function() {
        if (this._paused || !this._isResolved() || this._isPending()) {
          return;
        }
        var continuations = this._takeContinuations();
        var data = this._data;
        var self2 = this;
        continuations.forEach(function(cont) {
          if (cont.nextFn) {
            try {
              var result2 = cont.nextFn(data);
              self2._handleUserFunctionResult(result2, cont.promise);
            } catch (e) {
              self2._handleResolutionError(e, cont);
            }
          } else if (cont.promise) {
            cont.promise.resolve(data);
          }
        });
        if (looksLikeAPromise(this._data)) {
          return this._handleWhenResolvedDataIsPromise(this._data);
        }
      },
      _handleResolutionError: function(e, continuation) {
        this._setRejected();
        if (continuation.catchFn) {
          try {
            continuation.catchFn(e);
            return;
          } catch (e2) {
            e = e2;
          }
        }
        if (continuation.promise) {
          continuation.promise.reject(e);
        }
      },
      _handleWhenResolvedDataIsPromise: function(data) {
        var self2 = this;
        return data.then(function(result2) {
          self2._data = result2;
          self2._runResolutions();
        }).catch(function(error) {
          self2._error = error;
          self2._setRejected();
          self2._runRejections();
        });
      },
      _handleUserFunctionResult: function(data, nextSynchronousPromise) {
        if (looksLikeAPromise(data)) {
          this._chainPromiseData(data, nextSynchronousPromise);
        } else {
          nextSynchronousPromise.resolve(data);
        }
      },
      _chainPromiseData: function(promiseData, nextSynchronousPromise) {
        promiseData.then(function(newData) {
          nextSynchronousPromise.resolve(newData);
        }).catch(function(newError) {
          nextSynchronousPromise.reject(newError);
        });
      },
      _setResolved: function() {
        this.status = RESOLVED;
        if (!this._paused) {
          this._runResolutions();
        }
      },
      _setRejected: function() {
        this.status = REJECTED;
        if (!this._paused) {
          this._runRejections();
        }
      },
      _isPending: function() {
        return this.status === PENDING;
      },
      _isResolved: function() {
        return this.status === RESOLVED;
      },
      _isRejected: function() {
        return this.status === REJECTED;
      }
    };
    SynchronousPromise4.resolve = function(result2) {
      return new SynchronousPromise4(function(resolve, reject) {
        if (looksLikeAPromise(result2)) {
          result2.then(function(newResult) {
            resolve(newResult);
          }).catch(function(error) {
            reject(error);
          });
        } else {
          resolve(result2);
        }
      });
    };
    SynchronousPromise4.reject = function(result2) {
      return new SynchronousPromise4(function(resolve, reject) {
        reject(result2);
      });
    };
    SynchronousPromise4.unresolved = function() {
      return new SynchronousPromise4(function(resolve, reject) {
        this.resolve = resolve;
        this.reject = reject;
      });
    };
    SynchronousPromise4.all = function() {
      var args2 = makeArrayFrom(arguments);
      if (Array.isArray(args2[0])) {
        args2 = args2[0];
      }
      if (!args2.length) {
        return SynchronousPromise4.resolve([]);
      }
      return new SynchronousPromise4(function(resolve, reject) {
        var allData = [], numResolved = 0, doResolve = function() {
          if (numResolved === args2.length) {
            resolve(allData);
          }
        }, rejected = false, doReject = function(err) {
          if (rejected) {
            return;
          }
          rejected = true;
          reject(err);
        };
        args2.forEach(function(arg, idx) {
          SynchronousPromise4.resolve(arg).then(function(thisResult) {
            allData[idx] = thisResult;
            numResolved += 1;
            doResolve();
          }).catch(function(err) {
            doReject(err);
          });
        });
      });
    };
    function createAggregateErrorFrom(errors) {
      if (typeof window !== "undefined" && "AggregateError" in window) {
        return new window.AggregateError(errors);
      }
      return { errors };
    }
    SynchronousPromise4.any = function() {
      var args2 = makeArrayFrom(arguments);
      if (Array.isArray(args2[0])) {
        args2 = args2[0];
      }
      if (!args2.length) {
        return SynchronousPromise4.reject(createAggregateErrorFrom([]));
      }
      return new SynchronousPromise4(function(resolve, reject) {
        var allErrors = [], numRejected = 0, doReject = function() {
          if (numRejected === args2.length) {
            reject(createAggregateErrorFrom(allErrors));
          }
        }, resolved = false, doResolve = function(result2) {
          if (resolved) {
            return;
          }
          resolved = true;
          resolve(result2);
        };
        args2.forEach(function(arg, idx) {
          SynchronousPromise4.resolve(arg).then(function(thisResult) {
            doResolve(thisResult);
          }).catch(function(err) {
            allErrors[idx] = err;
            numRejected += 1;
            doReject();
          });
        });
      });
    };
    SynchronousPromise4.allSettled = function() {
      var args2 = makeArrayFrom(arguments);
      if (Array.isArray(args2[0])) {
        args2 = args2[0];
      }
      if (!args2.length) {
        return SynchronousPromise4.resolve([]);
      }
      return new SynchronousPromise4(function(resolve) {
        var allData = [], numSettled = 0, doSettled = function() {
          numSettled += 1;
          if (numSettled === args2.length) {
            resolve(allData);
          }
        };
        args2.forEach(function(arg, idx) {
          SynchronousPromise4.resolve(arg).then(function(thisResult) {
            allData[idx] = {
              status: "fulfilled",
              value: thisResult
            };
            doSettled();
          }).catch(function(err) {
            allData[idx] = {
              status: "rejected",
              reason: err
            };
            doSettled();
          });
        });
      });
    };
    if (Promise === SynchronousPromise4) {
      throw new Error("Please use SynchronousPromise.installGlobally() to install globally");
    }
    var RealPromise = Promise;
    SynchronousPromise4.installGlobally = function(__awaiter) {
      if (Promise === SynchronousPromise4) {
        return __awaiter;
      }
      var result2 = patchAwaiterIfRequired(__awaiter);
      Promise = SynchronousPromise4;
      return result2;
    };
    SynchronousPromise4.uninstallGlobally = function() {
      if (Promise === SynchronousPromise4) {
        Promise = RealPromise;
      }
    };
    function patchAwaiterIfRequired(__awaiter) {
      if (typeof __awaiter === "undefined" || __awaiter.__patched) {
        return __awaiter;
      }
      var originalAwaiter = __awaiter;
      __awaiter = function() {
        var Promise2 = RealPromise;
        originalAwaiter.apply(this, makeArrayFrom(arguments));
      };
      __awaiter.__patched = true;
      return __awaiter;
    }
    module.exports = {
      SynchronousPromise: SynchronousPromise4
    };
  }
});

// node_modules/@storybook/preview-api/node_modules/util-deprecate/browser.js
var require_browser = __commonJS({
  "node_modules/@storybook/preview-api/node_modules/util-deprecate/browser.js"(exports, module) {
    module.exports = deprecate3;
    function deprecate3(fn, msg) {
      if (config("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config("throwDeprecation")) {
            throw new Error(msg);
          } else if (config("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    function config(name2) {
      try {
        if (!global.localStorage)
          return false;
      } catch (_) {
        return false;
      }
      var val = global.localStorage[name2];
      if (null == val)
        return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// node_modules/@storybook/preview-api/node_modules/@storybook/channels/dist/chunk-NH5GSF3H.mjs
var isMulti = (args2) => args2.transports !== void 0;
var generateRandomId = () => Math.random().toString(16).slice(2);
var Channel = class {
  constructor(input = {}) {
    this.sender = generateRandomId();
    this.events = {};
    this.data = {};
    this.transports = [];
    this.isAsync = input.async || false, isMulti(input) ? (this.transports = input.transports || [], this.transports.forEach((t) => {
      t.setHandler((event) => this.handleEvent(event));
    })) : this.transports = input.transport ? [input.transport] : [], this.transports.forEach((t) => {
      t.setHandler((event) => this.handleEvent(event));
    });
  }
  get hasTransport() {
    return this.transports.length > 0;
  }
  addListener(eventName, listener) {
    this.events[eventName] = this.events[eventName] || [], this.events[eventName].push(listener);
  }
  emit(eventName, ...args2) {
    let event = { type: eventName, args: args2, from: this.sender }, options2 = {};
    args2.length >= 1 && args2[0] && args2[0].options && (options2 = args2[0].options);
    let handler = () => {
      this.transports.forEach((t) => {
        t.send(event, options2);
      }), this.handleEvent(event);
    };
    this.isAsync ? setImmediate(handler) : handler();
  }
  last(eventName) {
    return this.data[eventName];
  }
  eventNames() {
    return Object.keys(this.events);
  }
  listenerCount(eventName) {
    let listeners = this.listeners(eventName);
    return listeners ? listeners.length : 0;
  }
  listeners(eventName) {
    return this.events[eventName] || void 0;
  }
  once(eventName, listener) {
    let onceListener = this.onceListener(eventName, listener);
    this.addListener(eventName, onceListener);
  }
  removeAllListeners(eventName) {
    eventName ? this.events[eventName] && delete this.events[eventName] : this.events = {};
  }
  removeListener(eventName, listener) {
    let listeners = this.listeners(eventName);
    listeners && (this.events[eventName] = listeners.filter((l2) => l2 !== listener));
  }
  on(eventName, listener) {
    this.addListener(eventName, listener);
  }
  off(eventName, listener) {
    this.removeListener(eventName, listener);
  }
  handleEvent(event) {
    let listeners = this.listeners(event.type);
    listeners && listeners.length && listeners.forEach((fn) => {
      fn.apply(event, event.args);
    }), this.data[event.type] = event.args;
  }
  onceListener(eventName, listener) {
    let onceListener = (...args2) => (this.removeListener(eventName, onceListener), listener(...args2));
    return onceListener;
  }
};

// node_modules/@storybook/preview-api/node_modules/@storybook/channels/dist/chunk-BNMUBNN5.mjs
var import_global2 = __toESM(require_global(), 1);

// node_modules/@storybook/preview-api/node_modules/@storybook/core-events/dist/index.mjs
var dist_exports = {};
__export(dist_exports, {
  CHANNEL_CREATED: () => CHANNEL_CREATED,
  CONFIG_ERROR: () => CONFIG_ERROR,
  CURRENT_STORY_WAS_SET: () => CURRENT_STORY_WAS_SET,
  DOCS_PREPARED: () => DOCS_PREPARED,
  DOCS_RENDERED: () => DOCS_RENDERED,
  FORCE_REMOUNT: () => FORCE_REMOUNT,
  FORCE_RE_RENDER: () => FORCE_RE_RENDER,
  GLOBALS_UPDATED: () => GLOBALS_UPDATED,
  IGNORED_EXCEPTION: () => IGNORED_EXCEPTION,
  NAVIGATE_URL: () => NAVIGATE_URL,
  PLAY_FUNCTION_THREW_EXCEPTION: () => PLAY_FUNCTION_THREW_EXCEPTION,
  PRELOAD_ENTRIES: () => PRELOAD_ENTRIES,
  PREVIEW_BUILDER_PROGRESS: () => PREVIEW_BUILDER_PROGRESS,
  PREVIEW_KEYDOWN: () => PREVIEW_KEYDOWN,
  REGISTER_SUBSCRIPTION: () => REGISTER_SUBSCRIPTION,
  REQUEST_WHATS_NEW_DATA: () => REQUEST_WHATS_NEW_DATA,
  RESET_STORY_ARGS: () => RESET_STORY_ARGS,
  RESULT_WHATS_NEW_DATA: () => RESULT_WHATS_NEW_DATA,
  SELECT_STORY: () => SELECT_STORY,
  SET_CONFIG: () => SET_CONFIG,
  SET_CURRENT_STORY: () => SET_CURRENT_STORY,
  SET_GLOBALS: () => SET_GLOBALS,
  SET_INDEX: () => SET_INDEX,
  SET_STORIES: () => SET_STORIES,
  SET_WHATS_NEW_CACHE: () => SET_WHATS_NEW_CACHE,
  SHARED_STATE_CHANGED: () => SHARED_STATE_CHANGED,
  SHARED_STATE_SET: () => SHARED_STATE_SET,
  STORIES_COLLAPSE_ALL: () => STORIES_COLLAPSE_ALL,
  STORIES_EXPAND_ALL: () => STORIES_EXPAND_ALL,
  STORY_ARGS_UPDATED: () => STORY_ARGS_UPDATED,
  STORY_CHANGED: () => STORY_CHANGED,
  STORY_ERRORED: () => STORY_ERRORED,
  STORY_INDEX_INVALIDATED: () => STORY_INDEX_INVALIDATED,
  STORY_MISSING: () => STORY_MISSING,
  STORY_PREPARED: () => STORY_PREPARED,
  STORY_RENDERED: () => STORY_RENDERED,
  STORY_RENDER_PHASE_CHANGED: () => STORY_RENDER_PHASE_CHANGED,
  STORY_SPECIFIED: () => STORY_SPECIFIED,
  STORY_THREW_EXCEPTION: () => STORY_THREW_EXCEPTION,
  STORY_UNCHANGED: () => STORY_UNCHANGED,
  TELEMETRY_ERROR: () => TELEMETRY_ERROR,
  TOGGLE_WHATS_NEW_NOTIFICATIONS: () => TOGGLE_WHATS_NEW_NOTIFICATIONS,
  UPDATE_GLOBALS: () => UPDATE_GLOBALS,
  UPDATE_QUERY_PARAMS: () => UPDATE_QUERY_PARAMS,
  UPDATE_STORY_ARGS: () => UPDATE_STORY_ARGS,
  default: () => src_default
});
var events = ((events2) => (events2.CHANNEL_CREATED = "channelCreated", events2.CONFIG_ERROR = "configError", events2.STORY_INDEX_INVALIDATED = "storyIndexInvalidated", events2.STORY_SPECIFIED = "storySpecified", events2.SET_CONFIG = "setConfig", events2.SET_STORIES = "setStories", events2.SET_INDEX = "setIndex", events2.SET_CURRENT_STORY = "setCurrentStory", events2.CURRENT_STORY_WAS_SET = "currentStoryWasSet", events2.FORCE_RE_RENDER = "forceReRender", events2.FORCE_REMOUNT = "forceRemount", events2.PRELOAD_ENTRIES = "preloadStories", events2.STORY_PREPARED = "storyPrepared", events2.DOCS_PREPARED = "docsPrepared", events2.STORY_CHANGED = "storyChanged", events2.STORY_UNCHANGED = "storyUnchanged", events2.STORY_RENDERED = "storyRendered", events2.STORY_MISSING = "storyMissing", events2.STORY_ERRORED = "storyErrored", events2.STORY_THREW_EXCEPTION = "storyThrewException", events2.STORY_RENDER_PHASE_CHANGED = "storyRenderPhaseChanged", events2.PLAY_FUNCTION_THREW_EXCEPTION = "playFunctionThrewException", events2.UPDATE_STORY_ARGS = "updateStoryArgs", events2.STORY_ARGS_UPDATED = "storyArgsUpdated", events2.RESET_STORY_ARGS = "resetStoryArgs", events2.SET_GLOBALS = "setGlobals", events2.UPDATE_GLOBALS = "updateGlobals", events2.GLOBALS_UPDATED = "globalsUpdated", events2.REGISTER_SUBSCRIPTION = "registerSubscription", events2.PREVIEW_KEYDOWN = "previewKeydown", events2.PREVIEW_BUILDER_PROGRESS = "preview_builder_progress", events2.SELECT_STORY = "selectStory", events2.STORIES_COLLAPSE_ALL = "storiesCollapseAll", events2.STORIES_EXPAND_ALL = "storiesExpandAll", events2.DOCS_RENDERED = "docsRendered", events2.SHARED_STATE_CHANGED = "sharedStateChanged", events2.SHARED_STATE_SET = "sharedStateSet", events2.NAVIGATE_URL = "navigateUrl", events2.UPDATE_QUERY_PARAMS = "updateQueryParams", events2.REQUEST_WHATS_NEW_DATA = "requestWhatsNewData", events2.RESULT_WHATS_NEW_DATA = "resultWhatsNewData", events2.SET_WHATS_NEW_CACHE = "setWhatsNewCache", events2.TOGGLE_WHATS_NEW_NOTIFICATIONS = "toggleWhatsNewNotifications", events2.TELEMETRY_ERROR = "telemetryError", events2))(events || {});
var src_default = events;
var { CHANNEL_CREATED, CONFIG_ERROR, CURRENT_STORY_WAS_SET, DOCS_PREPARED, DOCS_RENDERED, FORCE_RE_RENDER, FORCE_REMOUNT, GLOBALS_UPDATED, NAVIGATE_URL, PLAY_FUNCTION_THREW_EXCEPTION, PRELOAD_ENTRIES, PREVIEW_BUILDER_PROGRESS, PREVIEW_KEYDOWN, REGISTER_SUBSCRIPTION, RESET_STORY_ARGS, SELECT_STORY, SET_CONFIG, SET_CURRENT_STORY, SET_GLOBALS, SET_INDEX, SET_STORIES, SHARED_STATE_CHANGED, SHARED_STATE_SET, STORIES_COLLAPSE_ALL, STORIES_EXPAND_ALL, STORY_ARGS_UPDATED, STORY_CHANGED, STORY_ERRORED, STORY_INDEX_INVALIDATED, STORY_MISSING, STORY_PREPARED, STORY_RENDER_PHASE_CHANGED, STORY_RENDERED, STORY_SPECIFIED, STORY_THREW_EXCEPTION, STORY_UNCHANGED, UPDATE_GLOBALS, UPDATE_QUERY_PARAMS, UPDATE_STORY_ARGS, REQUEST_WHATS_NEW_DATA, RESULT_WHATS_NEW_DATA, SET_WHATS_NEW_CACHE, TOGGLE_WHATS_NEW_NOTIFICATIONS, TELEMETRY_ERROR } = events;
var IGNORED_EXCEPTION = new Error("ignoredException");

// node_modules/@storybook/preview-api/node_modules/@storybook/client-logger/dist/index.mjs
var import_global = __toESM(require_global(), 1);
var { LOGLEVEL } = import_global.global;
var levels = { trace: 1, debug: 2, info: 3, warn: 4, error: 5, silent: 10 };
var currentLogLevelString = LOGLEVEL;
var currentLogLevelNumber = levels[currentLogLevelString] || levels.info;
var logger = { trace: (message, ...rest) => {
  currentLogLevelNumber <= levels.trace && console.trace(message, ...rest);
}, debug: (message, ...rest) => {
  currentLogLevelNumber <= levels.debug && console.debug(message, ...rest);
}, info: (message, ...rest) => {
  currentLogLevelNumber <= levels.info && console.info(message, ...rest);
}, warn: (message, ...rest) => {
  currentLogLevelNumber <= levels.warn && console.warn(message, ...rest);
}, error: (message, ...rest) => {
  currentLogLevelNumber <= levels.error && console.error(message, ...rest);
}, log: (message, ...rest) => {
  currentLogLevelNumber < levels.silent && console.log(message, ...rest);
} };
var logged = /* @__PURE__ */ new Set();
var once = (type) => (message, ...rest) => {
  if (!logged.has(message))
    return logged.add(message), logger[type](message, ...rest);
};
once.clear = () => logged.clear();
once.trace = once("trace");
once.debug = once("debug");
once.info = once("info");
once.warn = once("warn");
once.error = once("error");
once.log = once("log");
var deprecate = once("warn");
var pretty = (type) => (...args2) => {
  let argArray = [];
  if (args2.length) {
    let startTagRe = /<span\s+style=(['"])([^'"]*)\1\s*>/gi, endTagRe = /<\/span>/gi, reResultArray;
    for (argArray.push(args2[0].replace(startTagRe, "%c").replace(endTagRe, "%c")); reResultArray = startTagRe.exec(args2[0]); )
      argArray.push(reResultArray[2]), argArray.push("");
    for (let j = 1; j < args2.length; j++)
      argArray.push(args2[j]);
  }
  logger[type].apply(logger, argArray);
};
pretty.trace = pretty("trace");
pretty.debug = pretty("debug");
pretty.info = pretty("info");
pretty.warn = pretty("warn");
pretty.error = pretty("error");

// node_modules/@storybook/preview-api/node_modules/telejson/dist/chunk-465TF3XA.mjs
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS2 = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var eventProperties = [
  "bubbles",
  "cancelBubble",
  "cancelable",
  "composed",
  "currentTarget",
  "defaultPrevented",
  "eventPhase",
  "isTrusted",
  "returnValue",
  "srcElement",
  "target",
  "timeStamp",
  "type"
];
var customEventSpecificProperties = ["detail"];
function extractEventHiddenProperties(event) {
  const rebuildEvent = eventProperties.filter((value2) => event[value2] !== void 0).reduce((acc, value2) => {
    return { ...acc, [value2]: event[value2] };
  }, {});
  if (event instanceof CustomEvent) {
    customEventSpecificProperties.filter((value2) => event[value2] !== void 0).forEach((value2) => {
      rebuildEvent[value2] = event[value2];
    });
  }
  return rebuildEvent;
}

// node_modules/@storybook/preview-api/node_modules/telejson/dist/index.mjs
var import_memoizerific = __toESM(require_memoizerific(), 1);
var require_shams = __commonJS2({
  "node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});
var require_has_symbols = __commonJS2({
  "node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});
var require_implementation = __commonJS2({
  "node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args2 = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result2 = target.apply(
            this,
            args2.concat(slice.call(arguments))
          );
          if (Object(result2) === result2) {
            return result2;
          }
          return this;
        } else {
          return target.apply(
            that,
            args2.concat(slice.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args2.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs.push("$" + i);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});
var require_function_bind = __commonJS2({
  "node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});
var require_src = __commonJS2({
  "node_modules/has/src/index.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});
var require_get_intrinsic = __commonJS2({
  "node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = Object.getPrototypeOf || function(x2) {
      return x2.__proto__;
    };
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    var doEval = function doEval2(name2) {
      var value2;
      if (name2 === "%AsyncFunction%") {
        value2 = getEvalledConstructor("async function () {}");
      } else if (name2 === "%GeneratorFunction%") {
        value2 = getEvalledConstructor("function* () {}");
      } else if (name2 === "%AsyncGeneratorFunction%") {
        value2 = getEvalledConstructor("async function* () {}");
      } else if (name2 === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value2 = fn.prototype;
        }
      } else if (name2 === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen) {
          value2 = getProto(gen.prototype);
        }
      }
      INTRINSICS[name2] = value2;
      return value2;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_src();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName2 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar2 = /\\(\\)?/g;
    var stringToPath2 = function stringToPath3(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result2 = [];
      $replace(string, rePropName2, function(match, number, quote, subString) {
        result2[result2.length] = quote ? $replace(subString, reEscapeChar2, "$1") : number || match;
      });
      return result2;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
      var intrinsicName = name2;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value2 = INTRINSICS[intrinsicName];
        if (value2 === needsEval) {
          value2 = doEval(intrinsicName);
        }
        if (typeof value2 === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value: value2
        };
      }
      throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
    };
    module.exports = function GetIntrinsic(name2, allowMissing) {
      if (typeof name2 !== "string" || name2.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name2) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath2(name2);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value2 = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value2 = INTRINSICS[intrinsicRealName];
        } else if (value2 != null) {
          if (!(part in value2)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name2 + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value2, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value2 = desc.get;
            } else {
              value2 = value2[part];
            }
          } else {
            isOwn = hasOwn(value2, part);
            value2 = value2[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value2;
          }
        }
      }
      return value2;
    };
  }
});
var require_call_bind = __commonJS2({
  "node_modules/call-bind/index.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    module.exports = function callBind(originalFunction) {
      var func = $reflectApply(bind, $call, arguments);
      if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, "length");
        if (desc.configurable) {
          $defineProperty(
            func,
            "length",
            { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
          );
        }
      }
      return func;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  }
});
var require_callBound = __commonJS2({
  "node_modules/call-bind/callBound.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module.exports = function callBoundIntrinsic(name2, allowMissing) {
      var intrinsic = GetIntrinsic(name2, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});
var require_shams2 = __commonJS2({
  "node_modules/has-tostringtag/shams.js"(exports, module) {
    "use strict";
    var hasSymbols = require_shams();
    module.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});
var require_is_regex = __commonJS2({
  "node_modules/is-regex/index.js"(exports, module) {
    "use strict";
    var callBound = require_callBound();
    var hasToStringTag = require_shams2()();
    var has2;
    var $exec;
    var isRegexMarker;
    var badStringifier;
    if (hasToStringTag) {
      has2 = callBound("Object.prototype.hasOwnProperty");
      $exec = callBound("RegExp.prototype.exec");
      isRegexMarker = {};
      throwRegexMarker = function() {
        throw isRegexMarker;
      };
      badStringifier = {
        toString: throwRegexMarker,
        valueOf: throwRegexMarker
      };
      if (typeof Symbol.toPrimitive === "symbol") {
        badStringifier[Symbol.toPrimitive] = throwRegexMarker;
      }
    }
    var throwRegexMarker;
    var $toString = callBound("Object.prototype.toString");
    var gOPD = Object.getOwnPropertyDescriptor;
    var regexClass = "[object RegExp]";
    module.exports = hasToStringTag ? function isRegex(value2) {
      if (!value2 || typeof value2 !== "object") {
        return false;
      }
      var descriptor = gOPD(value2, "lastIndex");
      var hasLastIndexDataProperty = descriptor && has2(descriptor, "value");
      if (!hasLastIndexDataProperty) {
        return false;
      }
      try {
        $exec(value2, badStringifier);
      } catch (e) {
        return e === isRegexMarker;
      }
    } : function isRegex(value2) {
      if (!value2 || typeof value2 !== "object" && typeof value2 !== "function") {
        return false;
      }
      return $toString(value2) === regexClass;
    };
  }
});
var require_is_function = __commonJS2({
  "node_modules/is-function/index.js"(exports, module) {
    module.exports = isFunction3;
    var toString2 = Object.prototype.toString;
    function isFunction3(fn) {
      if (!fn) {
        return false;
      }
      var string = toString2.call(fn);
      return string === "[object Function]" || typeof fn === "function" && string !== "[object RegExp]" || typeof window !== "undefined" && (fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt);
    }
  }
});
var require_is_symbol = __commonJS2({
  "node_modules/is-symbol/index.js"(exports, module) {
    "use strict";
    var toStr = Object.prototype.toString;
    var hasSymbols = require_has_symbols()();
    if (hasSymbols) {
      symToStr = Symbol.prototype.toString;
      symStringRegex = /^Symbol\(.*\)$/;
      isSymbolObject = function isRealSymbolObject(value2) {
        if (typeof value2.valueOf() !== "symbol") {
          return false;
        }
        return symStringRegex.test(symToStr.call(value2));
      };
      module.exports = function isSymbol3(value2) {
        if (typeof value2 === "symbol") {
          return true;
        }
        if (toStr.call(value2) !== "[object Symbol]") {
          return false;
        }
        try {
          return isSymbolObject(value2);
        } catch (e) {
          return false;
        }
      };
    } else {
      module.exports = function isSymbol3(value2) {
        return false;
      };
    }
    var symToStr;
    var symStringRegex;
    var isSymbolObject;
  }
});
var import_is_regex = __toESM2(require_is_regex());
var import_is_function = __toESM2(require_is_function());
var import_is_symbol = __toESM2(require_is_symbol());
function isObject(val) {
  return val != null && typeof val === "object" && Array.isArray(val) === false;
}
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root2 = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root2;
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value2) {
  var isOwn = hasOwnProperty.call(value2, symToStringTag), tag = value2[symToStringTag];
  try {
    value2[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result2 = nativeObjectToString.call(value2);
  if (unmasked) {
    if (isOwn) {
      value2[symToStringTag] = tag;
    } else {
      delete value2[symToStringTag];
    }
  }
  return result2;
}
var getRawTag_default = getRawTag;
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value2) {
  return nativeObjectToString2.call(value2);
}
var objectToString_default = objectToString;
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value2) {
  if (value2 == null) {
    return value2 === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value2) ? getRawTag_default(value2) : objectToString_default(value2);
}
var baseGetTag_default = baseGetTag;
function isObjectLike(value2) {
  return value2 != null && typeof value2 == "object";
}
var isObjectLike_default = isObjectLike;
var symbolTag = "[object Symbol]";
function isSymbol(value2) {
  return typeof value2 == "symbol" || isObjectLike_default(value2) && baseGetTag_default(value2) == symbolTag;
}
var isSymbol_default = isSymbol;
function arrayMap(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length, result2 = Array(length);
  while (++index < length) {
    result2[index] = iteratee(array[index], index, array);
  }
  return result2;
}
var arrayMap_default = arrayMap;
var isArray = Array.isArray;
var isArray_default = isArray;
var INFINITY = 1 / 0;
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value2) {
  if (typeof value2 == "string") {
    return value2;
  }
  if (isArray_default(value2)) {
    return arrayMap_default(value2, baseToString) + "";
  }
  if (isSymbol_default(value2)) {
    return symbolToString ? symbolToString.call(value2) : "";
  }
  var result2 = value2 + "";
  return result2 == "0" && 1 / value2 == -INFINITY ? "-0" : result2;
}
var baseToString_default = baseToString;
function isObject2(value2) {
  var type = typeof value2;
  return value2 != null && (type == "object" || type == "function");
}
var isObject_default = isObject2;
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value2) {
  if (!isObject_default(value2)) {
    return false;
  }
  var tag = baseGetTag_default(value2);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction;
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked;
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var toSource_default = toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value2) {
  if (!isObject_default(value2) || isMasked_default(value2)) {
    return false;
  }
  var pattern = isFunction_default(value2) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value2));
}
var baseIsNative_default = baseIsNative;
function getValue(object, key2) {
  return object == null ? void 0 : object[key2];
}
var getValue_default = getValue;
function getNative(object, key2) {
  var value2 = getValue_default(object, key2);
  return baseIsNative_default(value2) ? value2 : void 0;
}
var getNative_default = getNative;
function eq(value2, other) {
  return value2 === other || value2 !== value2 && other !== other;
}
var eq_default = eq;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value2, object) {
  if (isArray_default(value2)) {
    return false;
  }
  var type = typeof value2;
  if (type == "number" || type == "symbol" || type == "boolean" || value2 == null || isSymbol_default(value2)) {
    return true;
  }
  return reIsPlainProp.test(value2) || !reIsDeepProp.test(value2) || object != null && value2 in Object(object);
}
var isKey_default = isKey;
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
var hashClear_default = hashClear;
function hashDelete(key2) {
  var result2 = this.has(key2) && delete this.__data__[key2];
  this.size -= result2 ? 1 : 0;
  return result2;
}
var hashDelete_default = hashDelete;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto4 = Object.prototype;
var hasOwnProperty3 = objectProto4.hasOwnProperty;
function hashGet(key2) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result2 = data[key2];
    return result2 === HASH_UNDEFINED ? void 0 : result2;
  }
  return hasOwnProperty3.call(data, key2) ? data[key2] : void 0;
}
var hashGet_default = hashGet;
var objectProto5 = Object.prototype;
var hasOwnProperty4 = objectProto5.hasOwnProperty;
function hashHas(key2) {
  var data = this.__data__;
  return nativeCreate_default ? data[key2] !== void 0 : hasOwnProperty4.call(data, key2);
}
var hashHas_default = hashHas;
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key2, value2) {
  var data = this.__data__;
  this.size += this.has(key2) ? 0 : 1;
  data[key2] = nativeCreate_default && value2 === void 0 ? HASH_UNDEFINED2 : value2;
  return this;
}
var hashSet_default = hashSet;
function Hash(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var listCacheClear_default = listCacheClear;
function assocIndexOf(array, key2) {
  var length = array.length;
  while (length--) {
    if (eq_default(array[length][0], key2)) {
      return length;
    }
  }
  return -1;
}
var assocIndexOf_default = assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key2) {
  var data = this.__data__, index = assocIndexOf_default(data, key2);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var listCacheDelete_default = listCacheDelete;
function listCacheGet(key2) {
  var data = this.__data__, index = assocIndexOf_default(data, key2);
  return index < 0 ? void 0 : data[index][1];
}
var listCacheGet_default = listCacheGet;
function listCacheHas(key2) {
  return assocIndexOf_default(this.__data__, key2) > -1;
}
var listCacheHas_default = listCacheHas;
function listCacheSet(key2, value2) {
  var data = this.__data__, index = assocIndexOf_default(data, key2);
  if (index < 0) {
    ++this.size;
    data.push([key2, value2]);
  } else {
    data[index][1] = value2;
  }
  return this;
}
var listCacheSet_default = listCacheSet;
function ListCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
var mapCacheClear_default = mapCacheClear;
function isKeyable(value2) {
  var type = typeof value2;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value2 !== "__proto__" : value2 === null;
}
var isKeyable_default = isKeyable;
function getMapData(map2, key2) {
  var data = map2.__data__;
  return isKeyable_default(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
}
var getMapData_default = getMapData;
function mapCacheDelete(key2) {
  var result2 = getMapData_default(this, key2)["delete"](key2);
  this.size -= result2 ? 1 : 0;
  return result2;
}
var mapCacheDelete_default = mapCacheDelete;
function mapCacheGet(key2) {
  return getMapData_default(this, key2).get(key2);
}
var mapCacheGet_default = mapCacheGet;
function mapCacheHas(key2) {
  return getMapData_default(this, key2).has(key2);
}
var mapCacheHas_default = mapCacheHas;
function mapCacheSet(key2, value2) {
  var data = getMapData_default(this, key2), size = data.size;
  data.set(key2, value2);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var mapCacheSet_default = mapCacheSet;
function MapCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args2 = arguments, key2 = resolver ? resolver.apply(this, args2) : args2[0], cache = memoized.cache;
    if (cache.has(key2)) {
      return cache.get(key2);
    }
    var result2 = func.apply(this, args2);
    memoized.cache = cache.set(key2, result2) || cache;
    return result2;
  };
  memoized.cache = new (memoize.Cache || MapCache_default)();
  return memoized;
}
memoize.Cache = MapCache_default;
var memoize_default = memoize;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result2 = memoize_default(func, function(key2) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key2;
  });
  var cache = result2.cache;
  return result2;
}
var memoizeCapped_default = memoizeCapped;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function(string) {
  var result2 = [];
  if (string.charCodeAt(0) === 46) {
    result2.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result2;
});
var stringToPath_default = stringToPath;
function toString(value2) {
  return value2 == null ? "" : baseToString_default(value2);
}
var toString_default = toString;
function castPath(value2, object) {
  if (isArray_default(value2)) {
    return value2;
  }
  return isKey_default(value2, object) ? [value2] : stringToPath_default(toString_default(value2));
}
var castPath_default = castPath;
var INFINITY2 = 1 / 0;
function toKey(value2) {
  if (typeof value2 == "string" || isSymbol_default(value2)) {
    return value2;
  }
  var result2 = value2 + "";
  return result2 == "0" && 1 / value2 == -INFINITY2 ? "-0" : result2;
}
var toKey_default = toKey;
function baseGet(object, path) {
  path = castPath_default(path, object);
  var index = 0, length = path.length;
  while (object != null && index < length) {
    object = object[toKey_default(path[index++])];
  }
  return index && index == length ? object : void 0;
}
var baseGet_default = baseGet;
function get(object, path, defaultValue) {
  var result2 = object == null ? void 0 : baseGet_default(object, path);
  return result2 === void 0 ? defaultValue : result2;
}
var get_default = get;
var isObject3 = isObject;
var removeCodeComments = (code) => {
  let inQuoteChar = null;
  let inBlockComment = false;
  let inLineComment = false;
  let inRegexLiteral = false;
  let newCode = "";
  if (code.indexOf("//") >= 0 || code.indexOf("/*") >= 0) {
    for (let i = 0; i < code.length; i += 1) {
      if (!inQuoteChar && !inBlockComment && !inLineComment && !inRegexLiteral) {
        if (code[i] === '"' || code[i] === "'" || code[i] === "`") {
          inQuoteChar = code[i];
        } else if (code[i] === "/" && code[i + 1] === "*") {
          inBlockComment = true;
        } else if (code[i] === "/" && code[i + 1] === "/") {
          inLineComment = true;
        } else if (code[i] === "/" && code[i + 1] !== "/") {
          inRegexLiteral = true;
        }
      } else {
        if (inQuoteChar && (code[i] === inQuoteChar && code[i - 1] !== "\\" || code[i] === "\n" && inQuoteChar !== "`")) {
          inQuoteChar = null;
        }
        if (inRegexLiteral && (code[i] === "/" && code[i - 1] !== "\\" || code[i] === "\n")) {
          inRegexLiteral = false;
        }
        if (inBlockComment && code[i - 1] === "/" && code[i - 2] === "*") {
          inBlockComment = false;
        }
        if (inLineComment && code[i] === "\n") {
          inLineComment = false;
        }
      }
      if (!inBlockComment && !inLineComment) {
        newCode += code[i];
      }
    }
  } else {
    newCode = code;
  }
  return newCode;
};
var cleanCode = (0, import_memoizerific.default)(1e4)(
  (code) => removeCodeComments(code).replace(/\n\s*/g, "").trim()
);
var convertShorthandMethods = function convertShorthandMethods2(key2, stringified) {
  const fnHead = stringified.slice(0, stringified.indexOf("{"));
  const fnBody = stringified.slice(stringified.indexOf("{"));
  if (fnHead.includes("=>")) {
    return stringified;
  }
  if (fnHead.includes("function")) {
    return stringified;
  }
  let modifiedHead = fnHead;
  modifiedHead = modifiedHead.replace(key2, "function");
  return modifiedHead + fnBody;
};
var dateFormat = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z$/;
var isJSON = (input) => input.match(/^[\[\{\"\}].*[\]\}\"]$/);
function convertUnconventionalData(data) {
  if (!isObject3(data)) {
    return data;
  }
  let result2 = data;
  let wasMutated = false;
  if (typeof Event !== "undefined" && data instanceof Event) {
    result2 = extractEventHiddenProperties(result2);
    wasMutated = true;
  }
  result2 = Object.keys(result2).reduce((acc, key2) => {
    try {
      if (result2[key2]) {
        result2[key2].toJSON;
      }
      acc[key2] = result2[key2];
    } catch (err) {
      wasMutated = true;
    }
    return acc;
  }, {});
  return wasMutated ? result2 : data;
}
var replacer = function replacer2(options2) {
  let objects;
  let map2;
  let stack;
  let keys;
  return function replace(key2, value2) {
    try {
      if (key2 === "") {
        keys = [];
        objects = /* @__PURE__ */ new Map([[value2, "[]"]]);
        map2 = /* @__PURE__ */ new Map();
        stack = [];
        return value2;
      }
      const origin = map2.get(this) || this;
      while (stack.length && origin !== stack[0]) {
        stack.shift();
        keys.pop();
      }
      if (typeof value2 === "boolean") {
        return value2;
      }
      if (value2 === void 0) {
        if (!options2.allowUndefined) {
          return void 0;
        }
        return "_undefined_";
      }
      if (value2 === null) {
        return null;
      }
      if (typeof value2 === "number") {
        if (value2 === -Infinity) {
          return "_-Infinity_";
        }
        if (value2 === Infinity) {
          return "_Infinity_";
        }
        if (Number.isNaN(value2)) {
          return "_NaN_";
        }
        return value2;
      }
      if (typeof value2 === "bigint") {
        return `_bigint_${value2.toString()}`;
      }
      if (typeof value2 === "string") {
        if (dateFormat.test(value2)) {
          if (!options2.allowDate) {
            return void 0;
          }
          return `_date_${value2}`;
        }
        return value2;
      }
      if ((0, import_is_regex.default)(value2)) {
        if (!options2.allowRegExp) {
          return void 0;
        }
        return `_regexp_${value2.flags}|${value2.source}`;
      }
      if ((0, import_is_function.default)(value2)) {
        if (!options2.allowFunction) {
          return void 0;
        }
        const { name: name2 } = value2;
        const stringified = value2.toString();
        if (!stringified.match(
          /(\[native code\]|WEBPACK_IMPORTED_MODULE|__webpack_exports__|__webpack_require__)/
        )) {
          return `_function_${name2}|${cleanCode(convertShorthandMethods(key2, stringified))}`;
        }
        return `_function_${name2}|${(() => {
        }).toString()}`;
      }
      if ((0, import_is_symbol.default)(value2)) {
        if (!options2.allowSymbol) {
          return void 0;
        }
        const globalRegistryKey = Symbol.keyFor(value2);
        if (globalRegistryKey !== void 0) {
          return `_gsymbol_${globalRegistryKey}`;
        }
        return `_symbol_${value2.toString().slice(7, -1)}`;
      }
      if (stack.length >= options2.maxDepth) {
        if (Array.isArray(value2)) {
          return `[Array(${value2.length})]`;
        }
        return "[Object]";
      }
      if (value2 === this) {
        return `_duplicate_${JSON.stringify(keys)}`;
      }
      if (value2 instanceof Error && options2.allowError) {
        return {
          __isConvertedError__: true,
          errorProperties: {
            ...value2.cause ? { cause: value2.cause } : {},
            ...value2,
            name: value2.name,
            message: value2.message,
            stack: value2.stack,
            "_constructor-name_": value2.constructor.name
          }
        };
      }
      if (value2.constructor && value2.constructor.name && value2.constructor.name !== "Object" && !Array.isArray(value2) && !options2.allowClass) {
        return void 0;
      }
      const found = objects.get(value2);
      if (!found) {
        const converted = Array.isArray(value2) ? value2 : convertUnconventionalData(value2);
        if (value2.constructor && value2.constructor.name && value2.constructor.name !== "Object" && !Array.isArray(value2) && options2.allowClass) {
          try {
            Object.assign(converted, { "_constructor-name_": value2.constructor.name });
          } catch (e) {
          }
        }
        keys.push(key2);
        stack.unshift(converted);
        objects.set(value2, JSON.stringify(keys));
        if (value2 !== converted) {
          map2.set(value2, converted);
        }
        return converted;
      }
      return `_duplicate_${found}`;
    } catch (e) {
      return void 0;
    }
  };
};
var reviver2 = function reviver(options) {
  const refs = [];
  let root;
  return function revive(key, value) {
    if (key === "") {
      root = value;
      refs.forEach(({ target, container, replacement }) => {
        const replacementArr = isJSON(replacement) ? JSON.parse(replacement) : replacement.split(".");
        if (replacementArr.length === 0) {
          container[target] = root;
        } else {
          container[target] = get_default(root, replacementArr);
        }
      });
    }
    if (key === "_constructor-name_") {
      return value;
    }
    if (isObject3(value) && value.__isConvertedError__) {
      const { message, ...properties } = value.errorProperties;
      const error = new Error(message);
      Object.assign(error, properties);
      return error;
    }
    if (isObject3(value) && value["_constructor-name_"] && options.allowFunction) {
      const name2 = value["_constructor-name_"];
      if (name2 !== "Object") {
        const Fn = new Function(`return function ${name2.replace(/[^a-zA-Z0-9$_]+/g, "")}(){}`)();
        Object.setPrototypeOf(value, new Fn());
      }
      delete value["_constructor-name_"];
      return value;
    }
    if (typeof value === "string" && value.startsWith("_function_") && options.allowFunction) {
      const [, name, source] = value.match(/_function_([^|]*)\|(.*)/) || [];
      const sourceSanitized = source.replace(/[(\(\))|\\| |\]|`]*$/, "");
      if (!options.lazyEval) {
        return eval(`(${sourceSanitized})`);
      }
      const result = (...args) => {
        const f = eval(`(${sourceSanitized})`);
        return f(...args);
      };
      Object.defineProperty(result, "toString", {
        value: () => sourceSanitized
      });
      Object.defineProperty(result, "name", {
        value: name
      });
      return result;
    }
    if (typeof value === "string" && value.startsWith("_regexp_") && options.allowRegExp) {
      const [, flags, source2] = value.match(/_regexp_([^|]*)\|(.*)/) || [];
      return new RegExp(source2, flags);
    }
    if (typeof value === "string" && value.startsWith("_date_") && options.allowDate) {
      return new Date(value.replace("_date_", ""));
    }
    if (typeof value === "string" && value.startsWith("_duplicate_")) {
      refs.push({ target: key, container: this, replacement: value.replace(/^_duplicate_/, "") });
      return null;
    }
    if (typeof value === "string" && value.startsWith("_symbol_") && options.allowSymbol) {
      return Symbol(value.replace("_symbol_", ""));
    }
    if (typeof value === "string" && value.startsWith("_gsymbol_") && options.allowSymbol) {
      return Symbol.for(value.replace("_gsymbol_", ""));
    }
    if (typeof value === "string" && value === "_-Infinity_") {
      return -Infinity;
    }
    if (typeof value === "string" && value === "_Infinity_") {
      return Infinity;
    }
    if (typeof value === "string" && value === "_NaN_") {
      return NaN;
    }
    if (typeof value === "string" && value.startsWith("_bigint_") && typeof BigInt === "function") {
      return BigInt(value.replace("_bigint_", ""));
    }
    return value;
  };
};
var defaultOptions = {
  maxDepth: 10,
  space: void 0,
  allowFunction: true,
  allowRegExp: true,
  allowDate: true,
  allowClass: true,
  allowError: true,
  allowUndefined: true,
  allowSymbol: true,
  lazyEval: true
};
var stringify = (data, options2 = {}) => {
  const mergedOptions = { ...defaultOptions, ...options2 };
  return JSON.stringify(convertUnconventionalData(data), replacer(mergedOptions), options2.space);
};
var mutator = () => {
  const mutated = /* @__PURE__ */ new Map();
  return function mutateUndefined(value2) {
    if (isObject3(value2)) {
      Object.entries(value2).forEach(([k2, v2]) => {
        if (v2 === "_undefined_") {
          value2[k2] = void 0;
        } else if (!mutated.get(v2)) {
          mutated.set(v2, true);
          mutateUndefined(v2);
        }
      });
    }
    if (Array.isArray(value2)) {
      value2.forEach((v2, index) => {
        if (v2 === "_undefined_") {
          mutated.set(v2, true);
          value2[index] = void 0;
        } else if (!mutated.get(v2)) {
          mutated.set(v2, true);
          mutateUndefined(v2);
        }
      });
    }
  };
};
var parse = (data, options2 = {}) => {
  const mergedOptions = { ...defaultOptions, ...options2 };
  const result2 = JSON.parse(data, reviver2(mergedOptions));
  mutator()(result2);
  return result2;
};

// node_modules/@storybook/preview-api/node_modules/@storybook/channels/dist/chunk-BNMUBNN5.mjs
var import_qs = __toESM(require_lib(), 1);

// node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var isProduction = false;
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  var provided = typeof message === "function" ? message() : message;
  var value2 = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
  throw new Error(value2);
}

// node_modules/@storybook/preview-api/node_modules/@storybook/channels/dist/chunk-BNMUBNN5.mjs
var getEventSourceUrl = (event) => {
  let frames = Array.from(document.querySelectorAll("iframe[data-is-storybook]")), [frame, ...remainder] = frames.filter((element) => {
    try {
      return element.contentWindow === event.source;
    } catch {
    }
    let src2 = element.getAttribute("src"), origin;
    try {
      if (!src2)
        return false;
      ({ origin } = new URL(src2, document.location.toString()));
    } catch {
      return false;
    }
    return origin === event.origin;
  }), src = frame == null ? void 0 : frame.getAttribute("src");
  if (src && remainder.length === 0) {
    let { protocol, host, pathname } = new URL(src, document.location.toString());
    return `${protocol}//${host}${pathname}`;
  }
  return remainder.length > 0 && logger.error("found multiple candidates for event source"), null;
};
var { document: document2, location } = import_global2.global;
var KEY = "storybook-channel";
var defaultEventOptions = { allowFunction: true, maxDepth: 25 };
var PostMessageTransport = class {
  constructor(config) {
    var _a;
    this.config = config;
    this.connected = false;
    if (this.buffer = [], typeof ((_a = import_global2.global) == null ? void 0 : _a.addEventListener) == "function" && import_global2.global.addEventListener("message", this.handleEvent.bind(this), false), config.page !== "manager" && config.page !== "preview")
      throw new Error(`postmsg-channel: "config.page" cannot be "${config.page}"`);
  }
  setHandler(handler) {
    this.handler = (...args2) => {
      handler.apply(this, args2), !this.connected && this.getLocalFrame().length && (this.flush(), this.connected = true);
    };
  }
  send(event, options2) {
    let { target, allowRegExp, allowFunction, allowSymbol, allowDate, allowError, allowUndefined, allowClass, maxDepth, space, lazyEval } = options2 || {}, eventOptions = Object.fromEntries(Object.entries({ allowRegExp, allowFunction, allowSymbol, allowDate, allowError, allowUndefined, allowClass, maxDepth, space, lazyEval }).filter(([k2, v2]) => typeof v2 < "u")), stringifyOptions = { ...defaultEventOptions, ...import_global2.global.CHANNEL_OPTIONS || {}, ...eventOptions }, frames = this.getFrames(target), query = import_qs.default.parse((location == null ? void 0 : location.search) || "", { ignoreQueryPrefix: true }), data = stringify({ key: KEY, event, refId: query.refId }, stringifyOptions);
    return frames.length ? (this.buffer.length && this.flush(), frames.forEach((f3) => {
      try {
        f3.postMessage(data, "*");
      } catch {
        logger.error("sending over postmessage fail");
      }
    }), Promise.resolve(null)) : new Promise((resolve, reject) => {
      this.buffer.push({ event, resolve, reject });
    });
  }
  flush() {
    let { buffer } = this;
    this.buffer = [], buffer.forEach((item) => {
      this.send(item.event).then(item.resolve).catch(item.reject);
    });
  }
  getFrames(target) {
    if (this.config.page === "manager") {
      let list = Array.from(document2.querySelectorAll("iframe[data-is-storybook][data-is-loaded]")).flatMap((e) => {
        try {
          return e.contentWindow && e.dataset.isStorybook !== void 0 && e.id === target ? [e.contentWindow] : [];
        } catch {
          return [];
        }
      });
      return (list == null ? void 0 : list.length) ? list : this.getCurrentFrames();
    }
    return import_global2.global && import_global2.global.parent && import_global2.global.parent !== import_global2.global.self ? [import_global2.global.parent] : [];
  }
  getCurrentFrames() {
    return this.config.page === "manager" ? Array.from(document2.querySelectorAll('[data-is-storybook="true"]')).flatMap((e) => e.contentWindow ? [e.contentWindow] : []) : import_global2.global && import_global2.global.parent ? [import_global2.global.parent] : [];
  }
  getLocalFrame() {
    return this.config.page === "manager" ? Array.from(document2.querySelectorAll("#storybook-preview-iframe")).flatMap((e) => e.contentWindow ? [e.contentWindow] : []) : import_global2.global && import_global2.global.parent ? [import_global2.global.parent] : [];
  }
  handleEvent(rawEvent) {
    try {
      let { data } = rawEvent, { key: key2, event, refId } = typeof data == "string" && isJSON(data) ? parse(data, import_global2.global.CHANNEL_OPTIONS || {}) : data;
      if (key2 === KEY) {
        let pageString = this.config.page === "manager" ? '<span style="color: #37D5D3; background: black"> manager </span>' : '<span style="color: #1EA7FD; background: black"> preview </span>', eventString = Object.values(dist_exports).includes(event.type) ? `<span style="color: #FF4785">${event.type}</span>` : `<span style="color: #FFAE00">${event.type}</span>`;
        if (refId && (event.refId = refId), event.source = this.config.page === "preview" ? rawEvent.origin : getEventSourceUrl(rawEvent), !event.source) {
          pretty.error(`${pageString} received ${eventString} but was unable to determine the source of the event`);
          return;
        }
        let message = `${pageString} received ${eventString} (${data.length})`;
        pretty.debug(location.origin !== event.source ? message : `${message} <span style="color: gray">(on ${location.origin} from ${event.source})</span>`, ...event.args), invariant(this.handler, "ChannelHandler should be set"), this.handler(event);
      }
    } catch (error) {
      logger.error(error);
    }
  }
};

// node_modules/@storybook/preview-api/node_modules/@storybook/channels/dist/chunk-V4SVTEPD.mjs
var import_global3 = __toESM(require_global(), 1);
var { WebSocket } = import_global3.global;
var WebsocketTransport = class {
  constructor({ url, onError }) {
    this.buffer = [];
    this.isReady = false;
    this.socket = new WebSocket(url), this.socket.onopen = () => {
      this.isReady = true, this.flush();
    }, this.socket.onmessage = ({ data }) => {
      let event = typeof data == "string" && isJSON(data) ? parse(data) : data;
      invariant(this.handler, "WebsocketTransport handler should be set"), this.handler(event);
    }, this.socket.onerror = (e) => {
      onError && onError(e);
    };
  }
  setHandler(handler) {
    this.handler = handler;
  }
  send(event) {
    this.isReady ? this.sendNow(event) : this.sendLater(event);
  }
  sendLater(event) {
    this.buffer.push(event);
  }
  sendNow(event) {
    let data = stringify(event, { maxDepth: 15, allowFunction: true });
    this.socket.send(data);
  }
  flush() {
    let { buffer } = this;
    this.buffer = [], buffer.forEach((event) => this.send(event));
  }
};

// node_modules/@storybook/preview-api/node_modules/@storybook/channels/dist/index.mjs
var import_global4 = __toESM(require_global(), 1);
var { CONFIG_TYPE } = import_global4.global;
function createBrowserChannel({ page, extraTransports = [] }) {
  let transports = [new PostMessageTransport({ page }), ...extraTransports];
  if (CONFIG_TYPE === "DEVELOPMENT") {
    let protocol = window.location.protocol === "http:" ? "ws" : "wss", { hostname, port } = window.location, channelUrl = `${protocol}://${hostname}:${port}/storybook-server-channel`;
    transports.push(new WebsocketTransport({ url: channelUrl, onError: () => {
    } }));
  }
  return new Channel({ transports });
}

// node_modules/@storybook/preview-api/dist/chunk-2WNKQWTL.mjs
var import_global5 = __toESM(require_global(), 1);
var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getProtoOf2 = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __commonJS3 = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps2 = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key2 of __getOwnPropNames2(from))
      !__hasOwnProp2.call(to, key2) && key2 !== except && __defProp2(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc2(from, key2)) || desc.enumerable });
  return to;
};
var __toESM3 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
function mockChannel() {
  let transport = { setHandler: () => {
  }, send: () => {
  } };
  return new Channel({ transport });
}
var AddonStore = class {
  constructor() {
    this.getChannel = () => {
      if (!this.channel) {
        let channel = mockChannel();
        return this.setChannel(channel), channel;
      }
      return this.channel;
    };
    this.getServerChannel = () => {
      if (!this.serverChannel)
        throw new Error("Accessing non-existent serverChannel");
      return this.serverChannel;
    };
    this.ready = () => this.promise;
    this.hasChannel = () => !!this.channel;
    this.hasServerChannel = () => !!this.serverChannel;
    this.setChannel = (channel) => {
      this.channel = channel, this.resolve();
    };
    this.setServerChannel = (channel) => {
      this.serverChannel = channel;
    };
    this.promise = new Promise((res) => {
      this.resolve = () => res(this.getChannel());
    });
  }
};
var KEY2 = "__STORYBOOK_ADDONS_PREVIEW";
function getAddonsStore() {
  return import_global5.global[KEY2] || (import_global5.global[KEY2] = new AddonStore()), import_global5.global[KEY2];
}
var addons = getAddonsStore();
var HooksContext = class {
  constructor() {
    this.hookListsMap = void 0;
    this.mountedDecorators = void 0;
    this.prevMountedDecorators = void 0;
    this.currentHooks = void 0;
    this.nextHookIndex = void 0;
    this.currentPhase = void 0;
    this.currentEffects = void 0;
    this.prevEffects = void 0;
    this.currentDecoratorName = void 0;
    this.hasUpdates = void 0;
    this.currentContext = void 0;
    this.renderListener = (storyId) => {
      var _a;
      storyId === ((_a = this.currentContext) == null ? void 0 : _a.id) && (this.triggerEffects(), this.currentContext = null, this.removeRenderListeners());
    };
    this.init();
  }
  init() {
    this.hookListsMap = /* @__PURE__ */ new WeakMap(), this.mountedDecorators = /* @__PURE__ */ new Set(), this.prevMountedDecorators = /* @__PURE__ */ new Set(), this.currentHooks = [], this.nextHookIndex = 0, this.currentPhase = "NONE", this.currentEffects = [], this.prevEffects = [], this.currentDecoratorName = null, this.hasUpdates = false, this.currentContext = null;
  }
  clean() {
    this.prevEffects.forEach((effect) => {
      effect.destroy && effect.destroy();
    }), this.init(), this.removeRenderListeners();
  }
  getNextHook() {
    let hook = this.currentHooks[this.nextHookIndex];
    return this.nextHookIndex += 1, hook;
  }
  triggerEffects() {
    this.prevEffects.forEach((effect) => {
      !this.currentEffects.includes(effect) && effect.destroy && effect.destroy();
    }), this.currentEffects.forEach((effect) => {
      this.prevEffects.includes(effect) || (effect.destroy = effect.create());
    }), this.prevEffects = this.currentEffects, this.currentEffects = [];
  }
  addRenderListeners() {
    this.removeRenderListeners(), addons.getChannel().on(STORY_RENDERED, this.renderListener);
  }
  removeRenderListeners() {
    addons.getChannel().removeListener(STORY_RENDERED, this.renderListener);
  }
};
function hookify(fn) {
  let hookified = (...args2) => {
    let { hooks } = typeof args2[0] == "function" ? args2[1] : args2[0], prevPhase = hooks.currentPhase, prevHooks = hooks.currentHooks, prevNextHookIndex = hooks.nextHookIndex, prevDecoratorName = hooks.currentDecoratorName;
    hooks.currentDecoratorName = fn.name, hooks.prevMountedDecorators.has(fn) ? (hooks.currentPhase = "UPDATE", hooks.currentHooks = hooks.hookListsMap.get(fn) || []) : (hooks.currentPhase = "MOUNT", hooks.currentHooks = [], hooks.hookListsMap.set(fn, hooks.currentHooks), hooks.prevMountedDecorators.add(fn)), hooks.nextHookIndex = 0;
    let prevContext = import_global5.global.STORYBOOK_HOOKS_CONTEXT;
    import_global5.global.STORYBOOK_HOOKS_CONTEXT = hooks;
    let result2 = fn(...args2);
    if (import_global5.global.STORYBOOK_HOOKS_CONTEXT = prevContext, hooks.currentPhase === "UPDATE" && hooks.getNextHook() != null)
      throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
    return hooks.currentPhase = prevPhase, hooks.currentHooks = prevHooks, hooks.nextHookIndex = prevNextHookIndex, hooks.currentDecoratorName = prevDecoratorName, result2;
  };
  return hookified.originalFn = fn, hookified;
}
var numberOfRenders = 0;
var RENDER_LIMIT = 25;
var applyHooks = (applyDecorators) => (storyFn, decorators) => {
  let decorated = applyDecorators(hookify(storyFn), decorators.map((decorator) => hookify(decorator)));
  return (context) => {
    let { hooks } = context;
    hooks.prevMountedDecorators ?? (hooks.prevMountedDecorators = /* @__PURE__ */ new Set()), hooks.mountedDecorators = /* @__PURE__ */ new Set([storyFn, ...decorators]), hooks.currentContext = context, hooks.hasUpdates = false;
    let result2 = decorated(context);
    for (numberOfRenders = 1; hooks.hasUpdates; )
      if (hooks.hasUpdates = false, hooks.currentEffects = [], result2 = decorated(context), numberOfRenders += 1, numberOfRenders > RENDER_LIMIT)
        throw new Error("Too many re-renders. Storybook limits the number of renders to prevent an infinite loop.");
    return hooks.addRenderListeners(), result2;
  };
};

// node_modules/@storybook/preview-api/dist/chunk-F345BBH6.mjs
var import_memoizerific2 = __toESM(require_memoizerific(), 1);
var import_mapValues = __toESM(require_mapValues(), 1);
var import_pick = __toESM(require_pick(), 1);
var import_synchronous_promise = __toESM(require_synchronous_promise(), 1);

// node_modules/@storybook/preview-api/node_modules/@storybook/core-events/dist/chunk-3FIG6PJN.mjs
var StorybookError = class extends Error {
  constructor() {
    super(...arguments);
    this.data = {};
    this.documentation = false;
    this.fromStorybook = true;
  }
  get fullErrorCode() {
    let paddedCode = String(this.code).padStart(4, "0");
    return `SB_${this.category}_${paddedCode}`;
  }
  get name() {
    let errorName = this.constructor.name;
    return `${this.fullErrorCode} (${errorName})`;
  }
  get message() {
    let page;
    return this.documentation === true ? page = `https://storybook.js.org/error/${this.fullErrorCode}` : typeof this.documentation == "string" ? page = this.documentation : Array.isArray(this.documentation) && (page = `
${this.documentation.map((doc) => `	- ${doc}`).join(`
`)}`), `${this.template()}${page != null ? `

More info: ${page}
` : ""}`;
  }
};

// node_modules/@storybook/preview-api/node_modules/@storybook/core-events/dist/errors/preview-errors.mjs
var Category = ((Category2) => (Category2.PREVIEW_CLIENT_LOGGER = "PREVIEW_CLIENT-LOGGER", Category2.PREVIEW_CHANNELS = "PREVIEW_CHANNELS", Category2.PREVIEW_CORE_EVENTS = "PREVIEW_CORE-EVENTS", Category2.PREVIEW_INSTRUMENTER = "PREVIEW_INSTRUMENTER", Category2.PREVIEW_API = "PREVIEW_API", Category2.PREVIEW_REACT_DOM_SHIM = "PREVIEW_REACT-DOM-SHIM", Category2.PREVIEW_ROUTER = "PREVIEW_ROUTER", Category2.PREVIEW_THEMING = "PREVIEW_THEMING", Category2.RENDERER_HTML = "RENDERER_HTML", Category2.RENDERER_PREACT = "RENDERER_PREACT", Category2.RENDERER_REACT = "RENDERER_REACT", Category2.RENDERER_SERVER = "RENDERER_SERVER", Category2.RENDERER_SVELTE = "RENDERER_SVELTE", Category2.RENDERER_VUE = "RENDERER_VUE", Category2.RENDERER_VUE3 = "RENDERER_VUE3", Category2.RENDERER_WEB_COMPONENTS = "RENDERER_WEB-COMPONENTS", Category2))(Category || {});
var MissingStoryAfterHmrError = class extends StorybookError {
  constructor(data) {
    super();
    this.data = data;
    this.category = "PREVIEW_API";
    this.code = 1;
  }
  template() {
    return esm_default`
    Couldn't find story matching id '${this.data.storyId}' after HMR.
    - Did you just rename a story?
    - Did you remove it from your CSF file?
    - Are you sure a story with the id '${this.data.storyId}' exists?
    - Please check the values in the stories field of your main.js config and see if they would match your CSF File.
    - Also check the browser console and terminal for potential error messages.`;
  }
};

// node_modules/dequal/dist/index.mjs
var has = Object.prototype.hasOwnProperty;
function find(iter, tar, key2) {
  for (key2 of iter.keys()) {
    if (dequal(key2, tar))
      return key2;
  }
}
function dequal(foo, bar) {
  var ctor, len, tmp;
  if (foo === bar)
    return true;
  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date)
      return foo.getTime() === bar.getTime();
    if (ctor === RegExp)
      return foo.toString() === bar.toString();
    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && dequal(foo[len], bar[len]))
          ;
      }
      return len === -1;
    }
    if (ctor === Set) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len;
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp)
            return false;
        }
        if (!bar.has(tmp))
          return false;
      }
      return true;
    }
    if (ctor === Map) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len[0];
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp)
            return false;
        }
        if (!dequal(len[1], bar.get(tmp))) {
          return false;
        }
      }
      return true;
    }
    if (ctor === ArrayBuffer) {
      foo = new Uint8Array(foo);
      bar = new Uint8Array(bar);
    } else if (ctor === DataView) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo.getInt8(len) === bar.getInt8(len))
          ;
      }
      return len === -1;
    }
    if (ArrayBuffer.isView(foo)) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo[len] === bar[len])
          ;
      }
      return len === -1;
    }
    if (!ctor || typeof foo === "object") {
      len = 0;
      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor))
          return false;
        if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor]))
          return false;
      }
      return Object.keys(bar).length === len;
    }
  }
  return foo !== foo && bar !== bar;
}

// node_modules/@storybook/preview-api/dist/chunk-F345BBH6.mjs
var import_isPlainObject = __toESM(require_isPlainObject(), 1);

// node_modules/@storybook/preview-api/node_modules/@storybook/csf/dist/index.mjs
var C = Object.create;
var u = Object.defineProperty;
var B = Object.getOwnPropertyDescriptor;
var F = Object.getOwnPropertyNames;
var h = Object.getPrototypeOf;
var w = Object.prototype.hasOwnProperty;
var E = (r, e) => () => (e || r((e = { exports: {} }).exports, e), e.exports);
var v = (r, e, n, t) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let a of F(e))
      !w.call(r, a) && a !== n && u(r, a, { get: () => e[a], enumerable: !(t = B(e, a)) || t.enumerable });
  return r;
};
var I = (r, e, n) => (n = r != null ? C(h(r)) : {}, v(e || !r || !r.__esModule ? u(n, "default", { value: r, enumerable: true }) : n, r));
var x = E((T) => {
  Object.defineProperty(T, "__esModule", { value: true }), T.isEqual = /* @__PURE__ */ function() {
    var r = Object.prototype.toString, e = Object.getPrototypeOf, n = Object.getOwnPropertySymbols ? function(t) {
      return Object.keys(t).concat(Object.getOwnPropertySymbols(t));
    } : Object.keys;
    return function(t, a) {
      return function i(o, s, p) {
        var g, y, d, c = r.call(o), b = r.call(s);
        if (o === s)
          return true;
        if (o == null || s == null)
          return false;
        if (p.indexOf(o) > -1 && p.indexOf(s) > -1)
          return true;
        if (p.push(o, s), c != b || (g = n(o), y = n(s), g.length != y.length || g.some(function(A) {
          return !i(o[A], s[A], p);
        })))
          return false;
        switch (c.slice(8, -1)) {
          case "Symbol":
            return o.valueOf() == s.valueOf();
          case "Date":
          case "Number":
            return +o == +s || +o != +o && +s != +s;
          case "RegExp":
          case "Function":
          case "String":
          case "Boolean":
            return "" + o == "" + s;
          case "Set":
          case "Map":
            g = o.entries(), y = s.entries();
            do
              if (!i((d = g.next()).value, y.next().value, p))
                return false;
            while (!d.done);
            return true;
          case "ArrayBuffer":
            o = new Uint8Array(o), s = new Uint8Array(s);
          case "DataView":
            o = new Uint8Array(o.buffer), s = new Uint8Array(s.buffer);
          case "Float32Array":
          case "Float64Array":
          case "Int8Array":
          case "Int16Array":
          case "Int32Array":
          case "Uint8Array":
          case "Uint16Array":
          case "Uint32Array":
          case "Uint8ClampedArray":
          case "Arguments":
          case "Array":
            if (o.length != s.length)
              return false;
            for (d = 0; d < o.length; d++)
              if ((d in o || d in s) && (d in o != d in s || !i(o[d], s[d], p)))
                return false;
            return true;
          case "Object":
            return i(e(o), e(s), p);
          default:
            return false;
        }
      }(t, a, []);
    };
  }();
});
function R(r) {
  return r.replace(/_/g, " ").replace(/-/g, " ").replace(/\./g, " ").replace(/([^\n])([A-Z])([a-z])/g, (e, n, t, a) => `${n} ${t}${a}`).replace(/([a-z])([A-Z])/g, (e, n, t) => `${n} ${t}`).replace(/([a-z])([0-9])/gi, (e, n, t) => `${n} ${t}`).replace(/([0-9])([a-z])/gi, (e, n, t) => `${n} ${t}`).replace(/(\s|^)(\w)/g, (e, n, t) => `${n}${t.toUpperCase()}`).replace(/ +/g, " ").trim();
}
var l = I(x());
var S = (r) => r.map((e) => typeof e < "u").filter(Boolean).length;
var k = (r, e) => {
  let { exists: n, eq: t, neq: a, truthy: i } = r;
  if (S([n, t, a, i]) > 1)
    throw new Error(`Invalid conditional test ${JSON.stringify({ exists: n, eq: t, neq: a })}`);
  if (typeof t < "u")
    return (0, l.isEqual)(e, t);
  if (typeof a < "u")
    return !(0, l.isEqual)(e, a);
  if (typeof n < "u") {
    let s = typeof e < "u";
    return n ? s : !s;
  }
  return (typeof i > "u" ? true : i) ? !!e : !e;
};
var P = (r, e, n) => {
  if (!r.if)
    return true;
  let { arg: t, global: a } = r.if;
  if (S([t, a]) !== 1)
    throw new Error(`Invalid conditional value ${JSON.stringify({ arg: t, global: a })}`);
  let i = t ? e[t] : n[a];
  return k(r.if, i);
};
var O = (r) => r.toLowerCase().replace(/[ '`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, "-").replace(/-+/g, "-").replace(/^-+/, "").replace(/-+$/, "");
var f2 = (r, e) => {
  let n = O(r);
  if (n === "")
    throw new Error(`Invalid ${e} '${r}', must include alphanumeric characters`);
  return n;
};
var G = (r, e) => `${f2(r, "kind")}${e ? `--${f2(e, "name")}` : ""}`;
var N = (r) => R(r);
function m(r, e) {
  return Array.isArray(e) ? e.includes(r) : r.match(e);
}
function M(r, { includeStories: e, excludeStories: n }) {
  return r !== "__esModule" && (!e || m(r, e)) && (!n || !m(r, n));
}

// node_modules/@storybook/preview-api/dist/chunk-F345BBH6.mjs
var import_util_deprecate = __toESM(require_browser(), 1);
var import_global6 = __toESM(require_global(), 1);
var import_pickBy = __toESM(require_pickBy(), 1);
var getImportPathMap = (0, import_memoizerific2.default)(1)((entries) => Object.values(entries).reduce((acc, entry) => (acc[entry.importPath] = acc[entry.importPath] || entry, acc), {}));
var StoryIndexStore = class {
  constructor({ entries } = { v: 4, entries: {} }) {
    this.entries = entries;
  }
  entryFromSpecifier(specifier) {
    let entries = Object.values(this.entries);
    if (specifier === "*")
      return entries[0];
    if (typeof specifier == "string")
      return this.entries[specifier] ? this.entries[specifier] : entries.find((entry) => entry.id.startsWith(specifier));
    let { name: name2, title } = specifier;
    return entries.find((entry) => entry.name === name2 && entry.title === title);
  }
  storyIdToEntry(storyId) {
    let storyEntry = this.entries[storyId];
    if (!storyEntry)
      throw new MissingStoryAfterHmrError({ storyId });
    return storyEntry;
  }
  importPathToEntry(importPath) {
    return getImportPathMap(this.entries)[importPath];
  }
};
var INCOMPATIBLE = Symbol("incompatible");
var map = (arg, argType) => {
  let type = argType.type;
  if (arg == null || !type || argType.mapping)
    return arg;
  switch (type.name) {
    case "string":
      return String(arg);
    case "enum":
      return arg;
    case "number":
      return Number(arg);
    case "boolean":
      return String(arg) === "true";
    case "array":
      return !type.value || !Array.isArray(arg) ? INCOMPATIBLE : arg.reduce((acc, item, index) => {
        let mapped = map(item, { type: type.value });
        return mapped !== INCOMPATIBLE && (acc[index] = mapped), acc;
      }, new Array(arg.length));
    case "object":
      return typeof arg == "string" || typeof arg == "number" ? arg : !type.value || typeof arg != "object" ? INCOMPATIBLE : Object.entries(arg).reduce((acc, [key2, val]) => {
        let mapped = map(val, { type: type.value[key2] });
        return mapped === INCOMPATIBLE ? acc : Object.assign(acc, { [key2]: mapped });
      }, {});
    default:
      return INCOMPATIBLE;
  }
};
var mapArgsToTypes = (args2, argTypes) => Object.entries(args2).reduce((acc, [key2, value2]) => {
  if (!argTypes[key2])
    return acc;
  let mapped = map(value2, argTypes[key2]);
  return mapped === INCOMPATIBLE ? acc : Object.assign(acc, { [key2]: mapped });
}, {});
var combineArgs = (value2, update) => Array.isArray(value2) && Array.isArray(update) ? update.reduce((acc, upd, index) => (acc[index] = combineArgs(value2[index], update[index]), acc), [...value2]).filter((v2) => v2 !== void 0) : !(0, import_isPlainObject.default)(value2) || !(0, import_isPlainObject.default)(update) ? update : Object.keys({ ...value2, ...update }).reduce((acc, key2) => {
  if (key2 in update) {
    let combined = combineArgs(value2[key2], update[key2]);
    combined !== void 0 && (acc[key2] = combined);
  } else
    acc[key2] = value2[key2];
  return acc;
}, {});
var validateOptions = (args2, argTypes) => Object.entries(argTypes).reduce((acc, [key2, { options: options2 }]) => {
  function allowArg() {
    return key2 in args2 && (acc[key2] = args2[key2]), acc;
  }
  if (!options2)
    return allowArg();
  if (!Array.isArray(options2))
    return once.error(dedent`
        Invalid argType: '${key2}.options' should be an array.

        More info: https://storybook.js.org/docs/react/api/argtypes
      `), allowArg();
  if (options2.some((opt) => opt && ["object", "function"].includes(typeof opt)))
    return once.error(dedent`
        Invalid argType: '${key2}.options' should only contain primitives. Use a 'mapping' for complex values.

        More info: https://storybook.js.org/docs/react/writing-stories/args#mapping-to-complex-arg-values
      `), allowArg();
  let isArray2 = Array.isArray(args2[key2]), invalidIndex = isArray2 && args2[key2].findIndex((val) => !options2.includes(val)), isValidArray = isArray2 && invalidIndex === -1;
  if (args2[key2] === void 0 || options2.includes(args2[key2]) || isValidArray)
    return allowArg();
  let field = isArray2 ? `${key2}[${invalidIndex}]` : key2, supportedOptions = options2.map((opt) => typeof opt == "string" ? `'${opt}'` : String(opt)).join(", ");
  return once.warn(`Received illegal value for '${field}'. Supported options: ${supportedOptions}`), acc;
}, {});
var DEEPLY_EQUAL = Symbol("Deeply equal");
var deepDiff = (value2, update) => {
  if (typeof value2 != typeof update)
    return update;
  if (dequal(value2, update))
    return DEEPLY_EQUAL;
  if (Array.isArray(value2) && Array.isArray(update)) {
    let res = update.reduce((acc, upd, index) => {
      let diff = deepDiff(value2[index], upd);
      return diff !== DEEPLY_EQUAL && (acc[index] = diff), acc;
    }, new Array(update.length));
    return update.length >= value2.length ? res : res.concat(new Array(value2.length - update.length).fill(void 0));
  }
  return (0, import_isPlainObject.default)(value2) && (0, import_isPlainObject.default)(update) ? Object.keys({ ...value2, ...update }).reduce((acc, key2) => {
    let diff = deepDiff(value2 == null ? void 0 : value2[key2], update == null ? void 0 : update[key2]);
    return diff === DEEPLY_EQUAL ? acc : Object.assign(acc, { [key2]: diff });
  }, {}) : update;
};
var UNTARGETED = "UNTARGETED";
function groupArgsByTarget({ args: args2, argTypes }) {
  let groupedArgs = {};
  return Object.entries(args2).forEach(([name2, value2]) => {
    let { target = UNTARGETED } = argTypes[name2] || {};
    groupedArgs[target] = groupedArgs[target] || {}, groupedArgs[target][name2] = value2;
  }), groupedArgs;
}
function deleteUndefined(obj) {
  return Object.keys(obj).forEach((key2) => obj[key2] === void 0 && delete obj[key2]), obj;
}
var ArgsStore = class {
  constructor() {
    this.initialArgsByStoryId = {};
    this.argsByStoryId = {};
  }
  get(storyId) {
    if (!(storyId in this.argsByStoryId))
      throw new Error(`No args known for ${storyId} -- has it been rendered yet?`);
    return this.argsByStoryId[storyId];
  }
  setInitial(story) {
    if (!this.initialArgsByStoryId[story.id])
      this.initialArgsByStoryId[story.id] = story.initialArgs, this.argsByStoryId[story.id] = story.initialArgs;
    else if (this.initialArgsByStoryId[story.id] !== story.initialArgs) {
      let delta = deepDiff(this.initialArgsByStoryId[story.id], this.argsByStoryId[story.id]);
      this.initialArgsByStoryId[story.id] = story.initialArgs, this.argsByStoryId[story.id] = story.initialArgs, delta !== DEEPLY_EQUAL && this.updateFromDelta(story, delta);
    }
  }
  updateFromDelta(story, delta) {
    let validatedDelta = validateOptions(delta, story.argTypes);
    this.argsByStoryId[story.id] = combineArgs(this.argsByStoryId[story.id], validatedDelta);
  }
  updateFromPersisted(story, persisted) {
    let mappedPersisted = mapArgsToTypes(persisted, story.argTypes);
    return this.updateFromDelta(story, mappedPersisted);
  }
  update(storyId, argsUpdate) {
    if (!(storyId in this.argsByStoryId))
      throw new Error(`No args known for ${storyId} -- has it been rendered yet?`);
    this.argsByStoryId[storyId] = deleteUndefined({ ...this.argsByStoryId[storyId], ...argsUpdate });
  }
};
var getValuesFromArgTypes = (argTypes = {}) => Object.entries(argTypes).reduce((acc, [arg, { defaultValue }]) => (typeof defaultValue < "u" && (acc[arg] = defaultValue), acc), {});
var GlobalsStore = class {
  constructor({ globals = {}, globalTypes = {} }) {
    this.set({ globals, globalTypes });
  }
  set({ globals = {}, globalTypes = {} }) {
    let delta = this.initialGlobals && deepDiff(this.initialGlobals, this.globals);
    this.allowedGlobalNames = /* @__PURE__ */ new Set([...Object.keys(globals), ...Object.keys(globalTypes)]);
    let defaultGlobals = getValuesFromArgTypes(globalTypes);
    this.initialGlobals = { ...defaultGlobals, ...globals }, this.globals = this.initialGlobals, delta && delta !== DEEPLY_EQUAL && this.updateFromPersisted(delta);
  }
  filterAllowedGlobals(globals) {
    return Object.entries(globals).reduce((acc, [key2, value2]) => (this.allowedGlobalNames.has(key2) ? acc[key2] = value2 : logger.warn(`Attempted to set a global (${key2}) that is not defined in initial globals or globalTypes`), acc), {});
  }
  updateFromPersisted(persisted) {
    let allowedUrlGlobals = this.filterAllowedGlobals(persisted);
    this.globals = { ...this.globals, ...allowedUrlGlobals };
  }
  get() {
    return this.globals;
  }
  update(newGlobals) {
    this.globals = { ...this.globals, ...this.filterAllowedGlobals(newGlobals) };
  }
};
var normalizeType = (type) => typeof type == "string" ? { name: type } : type;
var normalizeControl = (control) => typeof control == "string" ? { type: control } : control;
var normalizeInputType = (inputType, key2) => {
  let { type, control, ...rest } = inputType, normalized = { name: key2, ...rest };
  return type && (normalized.type = normalizeType(type)), control ? normalized.control = normalizeControl(control) : control === false && (normalized.control = { disable: true }), normalized;
};
var normalizeInputTypes = (inputTypes) => (0, import_mapValues.default)(inputTypes, normalizeInputType);
var normalizeArrays = (array) => Array.isArray(array) ? array : array ? [array] : [];
var deprecatedStoryAnnotation = dedent`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`;
var deprecatedStoryAnnotationWarning = (0, import_util_deprecate.default)(() => {
}, deprecatedStoryAnnotation);
function normalizeStory(key2, storyAnnotations, meta) {
  let storyObject = storyAnnotations, userStoryFn = typeof storyAnnotations == "function" ? storyAnnotations : null, { story } = storyObject;
  story && (logger.debug("deprecated story", story), deprecatedStoryAnnotationWarning());
  let exportName = N(key2), name2 = typeof storyObject != "function" && storyObject.name || storyObject.storyName || (story == null ? void 0 : story.name) || exportName, decorators = [...normalizeArrays(storyObject.decorators), ...normalizeArrays(story == null ? void 0 : story.decorators)], parameters = { ...story == null ? void 0 : story.parameters, ...storyObject.parameters }, args2 = { ...story == null ? void 0 : story.args, ...storyObject.args }, argTypes = { ...story == null ? void 0 : story.argTypes, ...storyObject.argTypes }, loaders = [...normalizeArrays(storyObject.loaders), ...normalizeArrays(story == null ? void 0 : story.loaders)], { render, play, tags = [] } = storyObject, id = parameters.__id || G(meta.id, exportName);
  return { moduleExport: storyAnnotations, id, name: name2, tags, decorators, parameters, args: args2, argTypes: normalizeInputTypes(argTypes), loaders, ...render && { render }, ...userStoryFn && { userStoryFn }, ...play && { play } };
}
function normalizeComponentAnnotations(defaultExport, title = defaultExport.title, importPath) {
  let { id, argTypes } = defaultExport;
  return { id: O(id || title), ...defaultExport, title, ...argTypes && { argTypes: normalizeInputTypes(argTypes) }, parameters: { fileName: importPath, ...defaultExport.parameters } };
}
var checkGlobals = (parameters) => {
  let { globals, globalTypes } = parameters;
  (globals || globalTypes) && logger.error("Global args/argTypes can only be set globally", JSON.stringify({ globals, globalTypes }));
};
var checkStorySort = (parameters) => {
  let { options: options2 } = parameters;
  (options2 == null ? void 0 : options2.storySort) && logger.error("The storySort option parameter can only be set globally");
};
var checkDisallowedParameters = (parameters) => {
  parameters && (checkGlobals(parameters), checkStorySort(parameters));
};
var checkSubcomponents = (meta) => {
  meta.subcomponents && deprecate(esm_default`The \`subcomponents\` annotation is deprecated. 
    
      Please refer to the migration guide: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#argstable-block'
    `);
};
function processCSFFile(moduleExports, importPath, title) {
  let { default: defaultExport, __namedExportsOrder, ...namedExports } = moduleExports, meta = normalizeComponentAnnotations(defaultExport, title, importPath);
  checkDisallowedParameters(meta.parameters), checkSubcomponents(meta);
  let csfFile = { meta, stories: {}, moduleExports };
  return Object.keys(namedExports).forEach((key2) => {
    if (M(key2, meta)) {
      let storyMeta = normalizeStory(key2, namedExports[key2], meta);
      checkDisallowedParameters(storyMeta.parameters), csfFile.stories[storyMeta.id] = storyMeta;
    }
  }), csfFile;
}
var combineParameters = (...parameterSets) => {
  let mergeKeys = {}, definedParametersSets = parameterSets.filter(Boolean), combined = definedParametersSets.reduce((acc, parameters) => (Object.entries(parameters).forEach(([key2, value2]) => {
    let existing = acc[key2];
    Array.isArray(value2) || typeof existing > "u" ? acc[key2] = value2 : (0, import_isPlainObject.default)(value2) && (0, import_isPlainObject.default)(existing) ? mergeKeys[key2] = true : typeof value2 < "u" && (acc[key2] = value2);
  }), acc), {});
  return Object.keys(mergeKeys).forEach((key2) => {
    let mergeValues = definedParametersSets.filter(Boolean).map((p) => p[key2]).filter((value2) => typeof value2 < "u");
    mergeValues.every((value2) => (0, import_isPlainObject.default)(value2)) ? combined[key2] = combineParameters(...mergeValues) : combined[key2] = mergeValues[mergeValues.length - 1];
  }), combined;
};
function decorateStory(storyFn, decorator, bindWithContext) {
  let boundStoryFunction = bindWithContext(storyFn);
  return (context) => decorator(boundStoryFunction, context);
}
function sanitizeStoryContextUpdate({ componentId, title, kind, id, name: name2, story, parameters, initialArgs, argTypes, ...update } = {}) {
  return update;
}
function defaultDecorateStory(storyFn, decorators) {
  let contextStore = {}, bindWithContext = (decoratedStoryFn) => (update) => {
    if (!contextStore.value)
      throw new Error("Decorated function called without init");
    return contextStore.value = { ...contextStore.value, ...sanitizeStoryContextUpdate(update) }, decoratedStoryFn(contextStore.value);
  }, decoratedWithContextStore = decorators.reduce((story, decorator) => decorateStory(story, decorator, bindWithContext), storyFn);
  return (context) => (contextStore.value = context, decoratedWithContextStore(context));
}
function prepareStory(storyAnnotations, componentAnnotations, projectAnnotations) {
  let { moduleExport, id, name: name2 } = storyAnnotations || {}, partialAnnotations = preparePartialAnnotations(storyAnnotations, componentAnnotations, projectAnnotations), applyLoaders = async (context) => {
    let updatedContext = { ...context, loaded: {} };
    for (let loaders of [..."__STORYBOOK_TEST_LOADERS__" in import_global6.global && Array.isArray(import_global6.global.__STORYBOOK_TEST_LOADERS__) ? [import_global6.global.__STORYBOOK_TEST_LOADERS__] : [], normalizeArrays(projectAnnotations.loaders), normalizeArrays(componentAnnotations.loaders), normalizeArrays(storyAnnotations.loaders)]) {
      let loadResults = await Promise.all(loaders.map((loader) => loader(updatedContext))), loaded = Object.assign({}, ...loadResults);
      updatedContext = { ...updatedContext, loaded: { ...updatedContext.loaded, ...loaded } };
    }
    return updatedContext;
  }, undecoratedStoryFn = (context) => {
    let { passArgsFirst: renderTimePassArgsFirst = true } = context.parameters;
    return renderTimePassArgsFirst ? render(context.args, context) : render(context);
  }, { applyDecorators = defaultDecorateStory, runStep } = projectAnnotations, decorators = [...normalizeArrays(storyAnnotations == null ? void 0 : storyAnnotations.decorators), ...normalizeArrays(componentAnnotations == null ? void 0 : componentAnnotations.decorators), ...normalizeArrays(projectAnnotations == null ? void 0 : projectAnnotations.decorators)], render = (storyAnnotations == null ? void 0 : storyAnnotations.userStoryFn) || (storyAnnotations == null ? void 0 : storyAnnotations.render) || componentAnnotations.render || projectAnnotations.render;
  if (!render)
    throw new Error(`No render function available for storyId '${id}'`);
  let decoratedStoryFn = applyHooks(applyDecorators)(undecoratedStoryFn, decorators), unboundStoryFn = (context) => decoratedStoryFn(context), play = (storyAnnotations == null ? void 0 : storyAnnotations.play) || componentAnnotations.play;
  return { ...partialAnnotations, moduleExport, id, name: name2, story: name2, originalStoryFn: render, undecoratedStoryFn, unboundStoryFn, applyLoaders, playFunction: play && (async (storyContext) => {
    let playFunctionContext = { ...storyContext, step: (label, play2) => runStep(label, play2, playFunctionContext) };
    return play(playFunctionContext);
  }) };
}
function prepareMeta(componentAnnotations, projectAnnotations, moduleExport) {
  return { ...preparePartialAnnotations(void 0, componentAnnotations, projectAnnotations), moduleExport };
}
function preparePartialAnnotations(storyAnnotations, componentAnnotations, projectAnnotations) {
  let tags = [...(storyAnnotations == null ? void 0 : storyAnnotations.tags) || componentAnnotations.tags || [], "story"], parameters = combineParameters(projectAnnotations.parameters, componentAnnotations.parameters, storyAnnotations == null ? void 0 : storyAnnotations.parameters), { argTypesEnhancers = [], argsEnhancers = [] } = projectAnnotations, passedArgTypes = combineParameters(projectAnnotations.argTypes, componentAnnotations.argTypes, storyAnnotations == null ? void 0 : storyAnnotations.argTypes);
  if (storyAnnotations) {
    let render = (storyAnnotations == null ? void 0 : storyAnnotations.userStoryFn) || (storyAnnotations == null ? void 0 : storyAnnotations.render) || componentAnnotations.render || projectAnnotations.render, { passArgsFirst = true } = parameters;
    parameters.__isArgsStory = passArgsFirst && render && render.length > 0;
  }
  let passedArgs = { ...projectAnnotations.args, ...componentAnnotations.args, ...storyAnnotations == null ? void 0 : storyAnnotations.args }, contextForEnhancers = { componentId: componentAnnotations.id, title: componentAnnotations.title, kind: componentAnnotations.title, id: (storyAnnotations == null ? void 0 : storyAnnotations.id) || componentAnnotations.id, name: (storyAnnotations == null ? void 0 : storyAnnotations.name) || "__meta", story: (storyAnnotations == null ? void 0 : storyAnnotations.name) || "__meta", component: componentAnnotations.component, subcomponents: componentAnnotations.subcomponents, tags, parameters, initialArgs: passedArgs, argTypes: passedArgTypes };
  contextForEnhancers.argTypes = argTypesEnhancers.reduce((accumulatedArgTypes, enhancer) => enhancer({ ...contextForEnhancers, argTypes: accumulatedArgTypes }), contextForEnhancers.argTypes);
  let initialArgsBeforeEnhancers = { ...passedArgs };
  contextForEnhancers.initialArgs = argsEnhancers.reduce((accumulatedArgs, enhancer) => ({ ...accumulatedArgs, ...enhancer({ ...contextForEnhancers, initialArgs: accumulatedArgs }) }), initialArgsBeforeEnhancers);
  let { name: name2, story, ...withoutStoryIdentifiers } = contextForEnhancers;
  return withoutStoryIdentifiers;
}
function prepareContext(context) {
  var _a;
  let { args: unmappedArgs } = context, targetedContext = { ...context, allArgs: void 0, argsByTarget: void 0 };
  if ((_a = import_global6.global.FEATURES) == null ? void 0 : _a.argTypeTargetsV7) {
    let argsByTarget = groupArgsByTarget(context);
    targetedContext = { ...context, allArgs: context.args, argsByTarget, args: argsByTarget[UNTARGETED] || {} };
  }
  let mappedArgs = Object.entries(targetedContext.args).reduce((acc, [key2, val]) => {
    var _a2;
    if (!((_a2 = targetedContext.argTypes[key2]) == null ? void 0 : _a2.mapping))
      return acc[key2] = val, acc;
    let mappingFn = (originalValue) => originalValue in targetedContext.argTypes[key2].mapping ? targetedContext.argTypes[key2].mapping[originalValue] : originalValue;
    return acc[key2] = Array.isArray(val) ? val.map(mappingFn) : mappingFn(val), acc;
  }, {}), includedArgs = Object.entries(mappedArgs).reduce((acc, [key2, val]) => {
    let argType = targetedContext.argTypes[key2] || {};
    return P(argType, mappedArgs, targetedContext.globals) && (acc[key2] = val), acc;
  }, {});
  return { ...targetedContext, unmappedArgs, args: includedArgs };
}
var inferType = (value2, name2, visited) => {
  let type = typeof value2;
  switch (type) {
    case "boolean":
    case "string":
    case "number":
    case "function":
    case "symbol":
      return { name: type };
  }
  return value2 ? visited.has(value2) ? (logger.warn(dedent`
        We've detected a cycle in arg '${name2}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/react/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/react/essentials/controls#fully-custom-args
      `), { name: "other", value: "cyclic object" }) : (visited.add(value2), Array.isArray(value2) ? { name: "array", value: value2.length > 0 ? inferType(value2[0], name2, new Set(visited)) : { name: "other", value: "unknown" } } : { name: "object", value: (0, import_mapValues.default)(value2, (field) => inferType(field, name2, new Set(visited))) }) : { name: "object", value: {} };
};
var inferArgTypes = (context) => {
  let { id, argTypes: userArgTypes = {}, initialArgs = {} } = context, argTypes = (0, import_mapValues.default)(initialArgs, (arg, key2) => ({ name: key2, type: inferType(arg, `${id}.${key2}`, /* @__PURE__ */ new Set()) })), userArgTypesNames = (0, import_mapValues.default)(userArgTypes, (argType, key2) => ({ name: key2 }));
  return combineParameters(argTypes, userArgTypesNames, userArgTypes);
};
inferArgTypes.secondPass = true;
var matches = (name2, descriptor) => Array.isArray(descriptor) ? descriptor.includes(name2) : name2.match(descriptor);
var filterArgTypes = (argTypes, include, exclude) => !include && !exclude ? argTypes : argTypes && (0, import_pickBy.default)(argTypes, (argType, key2) => {
  let name2 = argType.name || key2;
  return (!include || matches(name2, include)) && (!exclude || !matches(name2, exclude));
});
var inferControl = (argType, name2, matchers) => {
  let { type, options: options2 } = argType;
  if (type) {
    if (matchers.color && matchers.color.test(name2)) {
      let controlType = type.name;
      if (controlType === "string")
        return { control: { type: "color" } };
      controlType !== "enum" && logger.warn(`Addon controls: Control of type color only supports string, received "${controlType}" instead`);
    }
    if (matchers.date && matchers.date.test(name2))
      return { control: { type: "date" } };
    switch (type.name) {
      case "array":
        return { control: { type: "object" } };
      case "boolean":
        return { control: { type: "boolean" } };
      case "string":
        return { control: { type: "text" } };
      case "number":
        return { control: { type: "number" } };
      case "enum": {
        let { value: value2 } = type;
        return { control: { type: (value2 == null ? void 0 : value2.length) <= 5 ? "radio" : "select" }, options: value2 };
      }
      case "function":
      case "symbol":
        return null;
      default:
        return { control: { type: options2 ? "select" : "object" } };
    }
  }
};
var inferControls = (context) => {
  let { argTypes, parameters: { __isArgsStory, controls: { include = null, exclude = null, matchers = {} } = {} } } = context;
  if (!__isArgsStory)
    return argTypes;
  let filteredArgTypes = filterArgTypes(argTypes, include, exclude), withControls = (0, import_mapValues.default)(filteredArgTypes, (argType, name2) => (argType == null ? void 0 : argType.type) && inferControl(argType, name2, matchers));
  return combineParameters(withControls, filteredArgTypes);
};
inferControls.secondPass = true;
function normalizeProjectAnnotations({ argTypes, globalTypes, argTypesEnhancers, decorators, loaders, ...annotations }) {
  return { ...argTypes && { argTypes: normalizeInputTypes(argTypes) }, ...globalTypes && { globalTypes: normalizeInputTypes(globalTypes) }, decorators: normalizeArrays(decorators), loaders: normalizeArrays(loaders), argTypesEnhancers: [...argTypesEnhancers || [], inferArgTypes, inferControls], ...annotations };
}
function composeStepRunners(stepRunners) {
  return async (label, play, playContext) => {
    await stepRunners.reduceRight((innerPlay, stepRunner) => async () => stepRunner(label, innerPlay, playContext), async () => play(playContext))();
  };
}
function getField(moduleExportList, field) {
  return moduleExportList.map((xs) => {
    var _a;
    return ((_a = xs.default) == null ? void 0 : _a[field]) ?? xs[field];
  }).filter(Boolean);
}
function getArrayField(moduleExportList, field, options2 = {}) {
  return getField(moduleExportList, field).reduce((a, b) => options2.reverseFileOrder ? [...b, ...a] : [...a, ...b], []);
}
function getObjectField(moduleExportList, field) {
  return Object.assign({}, ...getField(moduleExportList, field));
}
function getSingletonField(moduleExportList, field) {
  return getField(moduleExportList, field).pop();
}
function composeConfigs(moduleExportList) {
  var _a;
  let allArgTypeEnhancers = getArrayField(moduleExportList, "argTypesEnhancers"), stepRunners = getField(moduleExportList, "runStep");
  return { parameters: combineParameters(...getField(moduleExportList, "parameters")), decorators: getArrayField(moduleExportList, "decorators", { reverseFileOrder: !(((_a = import_global6.global.FEATURES) == null ? void 0 : _a.legacyDecoratorFileOrder) ?? false) }), args: getObjectField(moduleExportList, "args"), argsEnhancers: getArrayField(moduleExportList, "argsEnhancers"), argTypes: getObjectField(moduleExportList, "argTypes"), argTypesEnhancers: [...allArgTypeEnhancers.filter((e) => !e.secondPass), ...allArgTypeEnhancers.filter((e) => e.secondPass)], globals: getObjectField(moduleExportList, "globals"), globalTypes: getObjectField(moduleExportList, "globalTypes"), loaders: getArrayField(moduleExportList, "loaders"), render: getSingletonField(moduleExportList, "render"), renderToCanvas: getSingletonField(moduleExportList, "renderToCanvas"), renderToDOM: getSingletonField(moduleExportList, "renderToDOM"), applyDecorators: getSingletonField(moduleExportList, "applyDecorators"), runStep: composeStepRunners(stepRunners) };
}
var GLOBAL_STORYBOOK_PROJECT_ANNOTATIONS = composeConfigs([]);
var CSF_CACHE_SIZE = 1e3;
var STORY_CACHE_SIZE = 1e4;
var EXTRACT_BATCH_SIZE = 20;
var StoryStore = class {
  constructor() {
    this.getStoriesJsonData = () => {
      let { storyIndex } = this;
      if (!storyIndex)
        throw new Error("getStoriesJsonData called before initialization");
      let value2 = this.getSetStoriesPayload(), allowedParameters = ["fileName", "docsOnly", "framework", "__id", "__isArgsStory"];
      return { v: 3, stories: (0, import_mapValues.default)(value2.stories, (story) => {
        let { importPath } = storyIndex.entries[story.id];
        return { ...(0, import_pick.default)(story, ["id", "name", "title"]), importPath, kind: story.title, story: story.name, parameters: { ...(0, import_pick.default)(story.parameters, allowedParameters), fileName: importPath } };
      }) };
    };
    this.args = new ArgsStore(), this.hooks = {}, this.processCSFFileWithCache = (0, import_memoizerific2.default)(CSF_CACHE_SIZE)(processCSFFile), this.prepareMetaWithCache = (0, import_memoizerific2.default)(CSF_CACHE_SIZE)(prepareMeta), this.prepareStoryWithCache = (0, import_memoizerific2.default)(STORY_CACHE_SIZE)(prepareStory), this.initializationPromise = new import_synchronous_promise.SynchronousPromise((resolve) => {
      this.resolveInitializationPromise = resolve;
    });
  }
  setProjectAnnotations(projectAnnotations) {
    this.projectAnnotations = normalizeProjectAnnotations(projectAnnotations);
    let { globals, globalTypes } = projectAnnotations;
    this.globals ? this.globals.set({ globals, globalTypes }) : this.globals = new GlobalsStore({ globals, globalTypes });
  }
  initialize({ storyIndex, importFn, cache = false }) {
    return this.storyIndex = new StoryIndexStore(storyIndex), this.importFn = importFn, this.resolveInitializationPromise(), cache ? this.cacheAllCSFFiles() : import_synchronous_promise.SynchronousPromise.resolve();
  }
  async onStoriesChanged({ importFn, storyIndex }) {
    await this.initializationPromise, importFn && (this.importFn = importFn), storyIndex && (this.storyIndex.entries = storyIndex.entries), this.cachedCSFFiles && await this.cacheAllCSFFiles();
  }
  async storyIdToEntry(storyId) {
    return await this.initializationPromise, this.storyIndex.storyIdToEntry(storyId);
  }
  loadCSFFileByStoryId(storyId) {
    if (!this.storyIndex || !this.importFn)
      throw new Error("loadCSFFileByStoryId called before initialization");
    let { importPath, title } = this.storyIndex.storyIdToEntry(storyId);
    return this.importFn(importPath).then((moduleExports) => this.processCSFFileWithCache(moduleExports, importPath, title));
  }
  loadAllCSFFiles({ batchSize = EXTRACT_BATCH_SIZE } = {}) {
    if (!this.storyIndex)
      throw new Error("loadAllCSFFiles called before initialization");
    let importPaths = Object.entries(this.storyIndex.entries).map(([storyId, { importPath }]) => [importPath, storyId]), loadInBatches = (remainingImportPaths) => {
      if (remainingImportPaths.length === 0)
        return import_synchronous_promise.SynchronousPromise.resolve([]);
      let csfFilePromiseList = remainingImportPaths.slice(0, batchSize).map(([importPath, storyId]) => this.loadCSFFileByStoryId(storyId).then((csfFile) => ({ importPath, csfFile })));
      return import_synchronous_promise.SynchronousPromise.all(csfFilePromiseList).then((firstResults) => loadInBatches(remainingImportPaths.slice(batchSize)).then((restResults) => firstResults.concat(restResults)));
    };
    return loadInBatches(importPaths).then((list) => list.reduce((acc, { importPath, csfFile }) => (acc[importPath] = csfFile, acc), {}));
  }
  cacheAllCSFFiles() {
    return this.initializationPromise.then(() => this.loadAllCSFFiles().then((csfFiles) => {
      this.cachedCSFFiles = csfFiles;
    }));
  }
  preparedMetaFromCSFFile({ csfFile }) {
    if (!this.projectAnnotations)
      throw new Error("storyFromCSFFile called before initialization");
    let componentAnnotations = csfFile.meta;
    return this.prepareMetaWithCache(componentAnnotations, this.projectAnnotations, csfFile.moduleExports.default);
  }
  async loadStory({ storyId }) {
    await this.initializationPromise;
    let csfFile = await this.loadCSFFileByStoryId(storyId);
    return this.storyFromCSFFile({ storyId, csfFile });
  }
  storyFromCSFFile({ storyId, csfFile }) {
    if (!this.projectAnnotations)
      throw new Error("storyFromCSFFile called before initialization");
    let storyAnnotations = csfFile.stories[storyId];
    if (!storyAnnotations)
      throw new Error(`Didn't find '${storyId}' in CSF file, this is unexpected`);
    let componentAnnotations = csfFile.meta, story = this.prepareStoryWithCache(storyAnnotations, componentAnnotations, this.projectAnnotations);
    return this.args.setInitial(story), this.hooks[story.id] = this.hooks[story.id] || new HooksContext(), story;
  }
  componentStoriesFromCSFFile({ csfFile }) {
    if (!this.storyIndex)
      throw new Error("componentStoriesFromCSFFile called before initialization");
    return Object.keys(this.storyIndex.entries).filter((storyId) => !!csfFile.stories[storyId]).map((storyId) => this.storyFromCSFFile({ storyId, csfFile }));
  }
  async loadEntry(id) {
    let entry = await this.storyIdToEntry(id), { importFn, storyIndex } = this;
    if (!storyIndex || !importFn)
      throw new Error("loadEntry called before initialization");
    let storyImports = entry.type === "docs" ? entry.storiesImports : [], [entryExports, ...csfFiles] = await Promise.all([importFn(entry.importPath), ...storyImports.map((storyImportPath) => {
      let firstStoryEntry = storyIndex.importPathToEntry(storyImportPath);
      return this.loadCSFFileByStoryId(firstStoryEntry.id);
    })]);
    return { entryExports, csfFiles };
  }
  getStoryContext(story, { forceInitialArgs = false } = {}) {
    if (!this.globals)
      throw new Error("getStoryContext called before initialization");
    return prepareContext({ ...story, args: forceInitialArgs ? story.initialArgs : this.args.get(story.id), globals: this.globals.get(), hooks: this.hooks[story.id] });
  }
  cleanupStory(story) {
    this.hooks[story.id].clean();
  }
  extract(options2 = { includeDocsOnly: false }) {
    if (!this.storyIndex)
      throw new Error("extract called before initialization");
    let { cachedCSFFiles } = this;
    if (!cachedCSFFiles)
      throw new Error("Cannot call extract() unless you call cacheAllCSFFiles() first.");
    return Object.entries(this.storyIndex.entries).reduce((acc, [storyId, { type, importPath }]) => {
      if (type === "docs")
        return acc;
      let csfFile = cachedCSFFiles[importPath], story = this.storyFromCSFFile({ storyId, csfFile });
      return !options2.includeDocsOnly && story.parameters.docsOnly || (acc[storyId] = Object.entries(story).reduce((storyAcc, [key2, value2]) => key2 === "moduleExport" || typeof value2 == "function" ? storyAcc : Array.isArray(value2) ? Object.assign(storyAcc, { [key2]: value2.slice().sort() }) : Object.assign(storyAcc, { [key2]: value2 }), { args: story.initialArgs })), acc;
    }, {});
  }
  getSetStoriesPayload() {
    if (!this.globals)
      throw new Error("getSetStoriesPayload called before initialization");
    let stories = this.extract({ includeDocsOnly: true }), kindParameters = Object.values(stories).reduce((acc, { title }) => (acc[title] = {}, acc), {});
    return { v: 2, globals: this.globals.get(), globalParameters: {}, kindParameters, stories };
  }
  getSetIndexPayload() {
    if (!this.storyIndex)
      throw new Error("getSetIndexPayload called before initialization");
    if (!this.cachedCSFFiles)
      throw new Error("Cannot call getSetIndexPayload() unless you call cacheAllCSFFiles() first");
    let { cachedCSFFiles } = this, stories = this.extract({ includeDocsOnly: true });
    return { v: 4, entries: Object.fromEntries(Object.entries(this.storyIndex.entries).map(([id, entry]) => [id, stories[id] ? { ...entry, args: stories[id].initialArgs, initialArgs: stories[id].initialArgs, argTypes: stories[id].argTypes, parameters: stories[id].parameters } : { ...entry, parameters: this.preparedMetaFromCSFFile({ csfFile: cachedCSFFiles[entry.importPath] }).parameters }])) };
  }
  raw() {
    return Object.values(this.extract()).map(({ id }) => this.fromId(id)).filter(Boolean);
  }
  fromId(storyId) {
    if (!this.storyIndex)
      throw new Error("fromId called before initialization");
    if (!this.cachedCSFFiles)
      throw new Error("Cannot call fromId/raw() unless you call cacheAllCSFFiles() first.");
    let importPath;
    try {
      ({ importPath } = this.storyIndex.storyIdToEntry(storyId));
    } catch {
      return null;
    }
    let csfFile = this.cachedCSFFiles[importPath], story = this.storyFromCSFFile({ storyId, csfFile });
    return { ...story, storyFn: (update) => {
      let context = { ...this.getStoryContext(story), viewMode: "story" };
      return story.unboundStoryFn({ ...context, ...update });
    } };
  }
};
function slash(path) {
  return path.startsWith("\\\\?\\") ? path : path.replace(/\\/g, "/");
}
var stripExtension = (path) => {
  let parts = [...path], last = parts[parts.length - 1], dotIndex = last.indexOf("."), stripped = dotIndex > 0 ? last.substr(0, dotIndex) : last;
  parts[parts.length - 1] = stripped;
  let [first, ...rest] = parts;
  return first === "" && (parts = rest), parts;
};
var indexRe = /^index$/i;
var removeRedundantFilename = (paths) => {
  let prevVal;
  return paths.filter((val, index) => index === paths.length - 1 && (val === prevVal || indexRe.test(val)) ? false : (prevVal = val, true));
};
function pathJoin(paths) {
  let slashes = new RegExp("/{1,}", "g");
  return paths.join("/").replace(slashes, "/");
}
var userOrAutoTitleFromSpecifier = (fileName, entry, userTitle) => {
  let { directory, importPathMatcher, titlePrefix = "" } = entry || {};
  typeof fileName == "number" && once.warn(dedent`
      CSF Auto-title received a numeric fileName. This typically happens when
      webpack is mis-configured in production mode. To force webpack to produce
      filenames, set optimization.moduleIds = "named" in your webpack config.
    `);
  let normalizedFileName = slash(String(fileName));
  if (importPathMatcher.exec(normalizedFileName)) {
    if (!userTitle) {
      let suffix = normalizedFileName.replace(directory, ""), path = slash(pathJoin([titlePrefix, suffix])).split("/");
      return path = stripExtension(path), path = removeRedundantFilename(path), path.join("/");
    }
    return titlePrefix ? slash(pathJoin([titlePrefix, userTitle])) : userTitle;
  }
};
var userOrAutoTitle = (fileName, storiesEntries, userTitle) => {
  for (let i = 0; i < storiesEntries.length; i += 1) {
    let title = userOrAutoTitleFromSpecifier(fileName, storiesEntries[i], userTitle);
    if (title)
      return title;
  }
  return userTitle || void 0;
};
var STORY_KIND_PATH_SEPARATOR = /\s*\/\s*/;
var storySort = (options2 = {}) => (a, b) => {
  if (a.title === b.title && !options2.includeNames)
    return 0;
  let method = options2.method || "configure", order = options2.order || [], storyTitleA = a.title.trim().split(STORY_KIND_PATH_SEPARATOR), storyTitleB = b.title.trim().split(STORY_KIND_PATH_SEPARATOR);
  options2.includeNames && (storyTitleA.push(a.name), storyTitleB.push(b.name));
  let depth = 0;
  for (; storyTitleA[depth] || storyTitleB[depth]; ) {
    if (!storyTitleA[depth])
      return -1;
    if (!storyTitleB[depth])
      return 1;
    let nameA = storyTitleA[depth], nameB = storyTitleB[depth];
    if (nameA !== nameB) {
      let indexA = order.indexOf(nameA), indexB = order.indexOf(nameB), indexWildcard = order.indexOf("*");
      return indexA !== -1 || indexB !== -1 ? (indexA === -1 && (indexWildcard !== -1 ? indexA = indexWildcard : indexA = order.length), indexB === -1 && (indexWildcard !== -1 ? indexB = indexWildcard : indexB = order.length), indexA - indexB) : method === "configure" ? 0 : nameA.localeCompare(nameB, options2.locales ? options2.locales : void 0, { numeric: true, sensitivity: "accent" });
    }
    let index = order.indexOf(nameA);
    index === -1 && (index = order.indexOf("*")), order = index !== -1 && Array.isArray(order[index + 1]) ? order[index + 1] : [], depth += 1;
  }
  return 0;
};
var sortStoriesCommon = (stories, storySortParameter, fileNameOrder) => {
  if (storySortParameter) {
    let sortFn;
    typeof storySortParameter == "function" ? sortFn = storySortParameter : sortFn = storySort(storySortParameter), stories.sort(sortFn);
  } else
    stories.sort((s1, s2) => fileNameOrder.indexOf(s1.importPath) - fileNameOrder.indexOf(s2.importPath));
  return stories;
};
var toIndexEntry = (story) => {
  let { id, title, name: name2, parameters, type } = story;
  return { id, title, name: name2, importPath: parameters.fileName, type };
};
var sortStoriesV6 = (stories, storySortParameter, fileNameOrder) => {
  if (storySortParameter && typeof storySortParameter == "function")
    return stories.sort(storySortParameter), stories.map((s) => toIndexEntry(s[1]));
  let storiesV7 = stories.map((s) => toIndexEntry(s[1]));
  return sortStoriesCommon(storiesV7, storySortParameter, fileNameOrder);
};

// node_modules/@storybook/preview-api/dist/chunk-7YGXXCYU.mjs
var import_global7 = __toESM(require_global(), 1);
var import_synchronous_promise2 = __toESM(require_synchronous_promise(), 1);
var import_qs2 = __toESM(require_lib(), 1);
var AUTODOCS_TAG = "autodocs";
var STORIES_MDX_TAG = "stories-mdx";
var StoryStoreFacade = class {
  constructor() {
    this.projectAnnotations = { loaders: [], decorators: [], parameters: {}, argsEnhancers: [], argTypesEnhancers: [], args: {}, argTypes: {} }, this.entries = {}, this.csfExports = {};
  }
  importFn(path) {
    return import_synchronous_promise2.SynchronousPromise.resolve().then(() => {
      let moduleExports = this.csfExports[path];
      if (!moduleExports)
        throw new Error(`Unknown path: ${path}`);
      return moduleExports;
    });
  }
  getStoryIndex(store) {
    var _a, _b;
    let fileNameOrder = Object.keys(this.csfExports), storySortParameter = (_b = (_a = this.projectAnnotations.parameters) == null ? void 0 : _a.options) == null ? void 0 : _b.storySort, sortableV6 = Object.entries(this.entries).map(([storyId, { type, importPath, ...entry }]) => {
      let exports = this.csfExports[importPath], csfFile = store.processCSFFileWithCache(exports, importPath, exports.default.title), storyLike;
      return type === "story" ? storyLike = store.storyFromCSFFile({ storyId, csfFile }) : storyLike = { ...entry, story: entry.name, kind: entry.title, componentId: G(entry.componentId || entry.title), parameters: { fileName: importPath } }, [storyId, storyLike, csfFile.meta.parameters, this.projectAnnotations.parameters || {}];
    }), sortedV7;
    try {
      sortedV7 = sortStoriesV6(sortableV6, storySortParameter, fileNameOrder);
    } catch (err) {
      throw typeof storySortParameter == "function" ? new Error(dedent`
          Error sorting stories with sort parameter ${storySortParameter}:

          > ${err.message}
          
          Are you using a V7-style sort function in V6 compatibility mode?
          
          More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort
        `) : err;
    }
    return { v: 4, entries: sortedV7.reduce((acc, s) => (acc[s.id] = this.entries[s.id], acc), {}) };
  }
  clearFilenameExports(fileName) {
    this.csfExports[fileName] && (Object.entries(this.entries).forEach(([id, { importPath }]) => {
      importPath === fileName && delete this.entries[id];
    }), this.csfExports[fileName] = {});
  }
  addStoriesFromExports(fileName, fileExports) {
    var _a;
    if (fileName.match(/\.mdx$/) && !fileName.match(/\.stories\.mdx$/) && ((_a = import_global7.global.FEATURES) == null ? void 0 : _a.storyStoreV7MdxErrors) !== false)
      throw new Error(dedent`
        Cannot index \`.mdx\` file (\`${fileName}\`) in \`storyStoreV7: false\` mode.

        The legacy story store does not support new-style \`.mdx\` files. If the file above
        is not intended to be indexed (i.e. displayed as an entry in the sidebar), either
        exclude it from your \`stories\` glob, or add <Meta isTemplate /> to it.
        
        If you wanted to index the file, you'll need to name it \`stories.mdx\` and stick to the
        legacy (6.x) MDX API, or use the new store.`);
    if (this.csfExports[fileName] === fileExports)
      return;
    this.clearFilenameExports(fileName);
    let { default: defaultExport, __namedExportsOrder, ...namedExports } = fileExports, { id: componentId, title, tags: componentTags = [] } = defaultExport || {}, specifiers = (import_global7.global.STORIES || []).map((specifier) => ({ ...specifier, importPathMatcher: new RegExp(specifier.importPathMatcher) }));
    if (title = userOrAutoTitle(fileName, specifiers, title), !title) {
      logger.info(`Unexpected default export without title in '${fileName}': ${JSON.stringify(fileExports.default)}`);
      return;
    }
    this.csfExports[fileName] = { ...fileExports, default: { ...defaultExport, title } };
    let sortedExports = namedExports;
    Array.isArray(__namedExportsOrder) && (sortedExports = {}, __namedExportsOrder.forEach((name2) => {
      let namedExport = namedExports[name2];
      namedExport && (sortedExports[name2] = namedExport);
    }));
    let storyExports = Object.entries(sortedExports).filter(([key2]) => M(key2, defaultExport)), docsOptions = import_global7.global.DOCS_OPTIONS || {}, { autodocs } = docsOptions, componentAutodocs = componentTags.includes(AUTODOCS_TAG), autodocsOptedIn = autodocs === true || autodocs === "tag" && componentAutodocs;
    if (storyExports.length && (componentTags.includes(STORIES_MDX_TAG) || autodocsOptedIn)) {
      let name2 = docsOptions.defaultName, docsId = G(componentId || title, name2);
      this.entries[docsId] = { type: "docs", id: docsId, title, name: name2, importPath: fileName, ...componentId && { componentId }, tags: [...componentTags, "docs", ...autodocsOptedIn && !componentAutodocs ? [AUTODOCS_TAG] : []], storiesImports: [] };
    }
    storyExports.forEach(([key2, storyExport]) => {
      var _a2, _b, _c;
      let exportName = N(key2), id = ((_a2 = storyExport.parameters) == null ? void 0 : _a2.__id) || G(componentId || title, exportName), name2 = typeof storyExport != "function" && storyExport.name || storyExport.storyName || ((_b = storyExport.story) == null ? void 0 : _b.name) || exportName;
      ((_c = storyExport.parameters) == null ? void 0 : _c.docsOnly) || (this.entries[id] = { type: "story", id, name: name2, title, importPath: fileName, ...componentId && { componentId }, tags: [...storyExport.tags || componentTags, "story"] });
    });
  }
};
var invalidStoryTypes = /* @__PURE__ */ new Set(["string", "number", "boolean", "symbol"]);
var ClientApi = class {
  constructor({ storyStore } = {}) {
    this.lastFileName = 0;
    this.addDecorator = (decorator) => {
      var _a;
      (_a = this.facade.projectAnnotations.decorators) == null ? void 0 : _a.push(decorator);
    };
    this.addParameters = ({ globals, globalTypes, ...parameters }) => {
      this.facade.projectAnnotations.parameters = combineParameters(this.facade.projectAnnotations.parameters, parameters), globals && (this.facade.projectAnnotations.globals = { ...this.facade.projectAnnotations.globals, ...globals }), globalTypes && (this.facade.projectAnnotations.globalTypes = { ...this.facade.projectAnnotations.globalTypes, ...normalizeInputTypes(globalTypes) });
    };
    this.addStepRunner = (stepRunner) => {
      this.facade.projectAnnotations.runStep = composeStepRunners([this.facade.projectAnnotations.runStep, stepRunner].filter(Boolean));
    };
    this.addLoader = (loader) => {
      var _a;
      (_a = this.facade.projectAnnotations.loaders) == null ? void 0 : _a.push(loader);
    };
    this.addArgs = (args2) => {
      this.facade.projectAnnotations.args = { ...this.facade.projectAnnotations.args, ...args2 };
    };
    this.addArgTypes = (argTypes) => {
      this.facade.projectAnnotations.argTypes = { ...this.facade.projectAnnotations.argTypes, ...normalizeInputTypes(argTypes) };
    };
    this.addArgsEnhancer = (enhancer) => {
      var _a;
      (_a = this.facade.projectAnnotations.argsEnhancers) == null ? void 0 : _a.push(enhancer);
    };
    this.addArgTypesEnhancer = (enhancer) => {
      var _a;
      (_a = this.facade.projectAnnotations.argTypesEnhancers) == null ? void 0 : _a.push(enhancer);
    };
    this._addedExports = {};
    this.storiesOf = (kind, m2) => {
      if (!kind && typeof kind != "string")
        throw new Error("Invalid or missing kind provided for stories, should be a string");
      if (m2 || logger.warn(`Missing 'module' parameter for story with a kind of '${kind}'. It will break your HMR`), m2) {
        let proto = Object.getPrototypeOf(m2);
        proto.exports && proto.exports.default && logger.error(`Illegal mix of CSF default export and storiesOf calls in a single file: ${proto.i}`);
      }
      let baseFilename = m2 && m2.id ? `${m2.id}` : (this.lastFileName++).toString(), fileName = baseFilename, i = 1;
      for (; this._addedExports[fileName]; )
        i += 1, fileName = `${baseFilename}-${i}`;
      m2 && m2.hot && m2.hot.accept && (m2.hot.accept(), m2.hot.dispose(() => {
        this.facade.clearFilenameExports(fileName), delete this._addedExports[fileName], setTimeout(() => {
          var _a;
          this._loadAddedExports(), (_a = this.onImportFnChanged) == null ? void 0 : _a.call(this, { importFn: this.importFn.bind(this) });
        }, 0);
      }));
      let hasAdded = false, api = { kind: kind.toString(), add: () => api, addDecorator: () => api, addLoader: () => api, addParameters: () => api };
      Object.keys(this.addons).forEach((name2) => {
        let addon = this.addons[name2];
        api[name2] = (...args2) => (addon.apply(api, args2), api);
      });
      let meta = { id: O(kind), title: kind, decorators: [], loaders: [], parameters: {} };
      this._addedExports[fileName] = { default: meta };
      let counter = 0;
      return api.add = (storyName, storyFn, parameters = {}) => {
        if (hasAdded = true, typeof storyName != "string")
          throw new Error(`Invalid or missing storyName provided for a "${kind}" story.`);
        if (!storyFn || Array.isArray(storyFn) || invalidStoryTypes.has(typeof storyFn))
          throw new Error(`Cannot load story "${storyName}" in "${kind}" due to invalid format. Storybook expected a function/object but received ${typeof storyFn} instead.`);
        let { decorators, loaders, component, args: args2, argTypes, ...storyParameters } = parameters, storyId = parameters.__id || G(kind, storyName), csfExports = this._addedExports[fileName];
        return csfExports[`story${counter}`] = { name: storyName, parameters: { fileName, __id: storyId, ...storyParameters }, decorators, loaders, args: args2, argTypes, component, render: storyFn }, counter += 1, api;
      }, api.addDecorator = (decorator) => {
        var _a;
        if (hasAdded)
          throw new Error(`You cannot add a decorator after the first story for a kind.
Read more here: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#can-no-longer-add-decoratorsparameters-after-stories`);
        return (_a = meta.decorators) == null ? void 0 : _a.push(decorator), api;
      }, api.addLoader = (loader) => {
        var _a;
        if (hasAdded)
          throw new Error("You cannot add a loader after the first story for a kind.");
        return (_a = meta.loaders) == null ? void 0 : _a.push(loader), api;
      }, api.addParameters = ({ component, args: args2, argTypes, tags, ...parameters }) => {
        if (hasAdded)
          throw new Error(`You cannot add parameters after the first story for a kind.
Read more here: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#can-no-longer-add-decoratorsparameters-after-stories`);
        return meta.parameters = combineParameters(meta.parameters, parameters), component && (meta.component = component), args2 && (meta.args = { ...meta.args, ...args2 }), argTypes && (meta.argTypes = { ...meta.argTypes, ...argTypes }), tags && (meta.tags = tags), api;
      }, api;
    };
    this.raw = () => {
      var _a;
      return (_a = this.storyStore) == null ? void 0 : _a.raw();
    };
    this.facade = new StoryStoreFacade(), this.addons = {}, this.storyStore = storyStore;
  }
  importFn(path) {
    return this.facade.importFn(path);
  }
  getStoryIndex() {
    if (!this.storyStore)
      throw new Error("Cannot get story index before setting storyStore");
    return this.facade.getStoryIndex(this.storyStore);
  }
  _loadAddedExports() {
    Object.entries(this._addedExports).forEach(([fileName, fileExports]) => this.facade.addStoriesFromExports(fileName, fileExports));
  }
  get _storyStore() {
    return this.storyStore;
  }
};

// node_modules/@storybook/preview-api/dist/chunk-JQAFJEXS.mjs
var import_global8 = __toESM(require_global(), 1);
var import_synchronous_promise3 = __toESM(require_synchronous_promise(), 1);
var import_qs3 = __toESM(require_lib(), 1);
var import_isPlainObject2 = __toESM(require_isPlainObject(), 1);
var require_entities = __commonJS3({ "../../node_modules/ansi-to-html/node_modules/entities/lib/maps/entities.json"(exports, module) {
  module.exports = { Aacute: "", aacute: "", Abreve: "", abreve: "", ac: "", acd: "", acE: "", Acirc: "", acirc: "", acute: "", Acy: "", acy: "", AElig: "", aelig: "", af: "", Afr: "", afr: "", Agrave: "", agrave: "", alefsym: "", aleph: "", Alpha: "", alpha: "", Amacr: "", amacr: "", amalg: "", amp: "&", AMP: "&", andand: "", And: "", and: "", andd: "", andslope: "", andv: "", ang: "", ange: "", angle: "", angmsdaa: "", angmsdab: "", angmsdac: "", angmsdad: "", angmsdae: "", angmsdaf: "", angmsdag: "", angmsdah: "", angmsd: "", angrt: "", angrtvb: "", angrtvbd: "", angsph: "", angst: "", angzarr: "", Aogon: "", aogon: "", Aopf: "", aopf: "", apacir: "", ap: "", apE: "", ape: "", apid: "", apos: "'", ApplyFunction: "", approx: "", approxeq: "", Aring: "", aring: "", Ascr: "", ascr: "", Assign: "", ast: "*", asymp: "", asympeq: "", Atilde: "", atilde: "", Auml: "", auml: "", awconint: "", awint: "", backcong: "", backepsilon: "", backprime: "", backsim: "", backsimeq: "", Backslash: "", Barv: "", barvee: "", barwed: "", Barwed: "", barwedge: "", bbrk: "", bbrktbrk: "", bcong: "", Bcy: "", bcy: "", bdquo: "", becaus: "", because: "", Because: "", bemptyv: "", bepsi: "", bernou: "", Bernoullis: "", Beta: "", beta: "", beth: "", between: "", Bfr: "", bfr: "", bigcap: "", bigcirc: "", bigcup: "", bigodot: "", bigoplus: "", bigotimes: "", bigsqcup: "", bigstar: "", bigtriangledown: "", bigtriangleup: "", biguplus: "", bigvee: "", bigwedge: "", bkarow: "", blacklozenge: "", blacksquare: "", blacktriangle: "", blacktriangledown: "", blacktriangleleft: "", blacktriangleright: "", blank: "", blk12: "", blk14: "", blk34: "", block: "", bne: "=", bnequiv: "", bNot: "", bnot: "", Bopf: "", bopf: "", bot: "", bottom: "", bowtie: "", boxbox: "", boxdl: "", boxdL: "", boxDl: "", boxDL: "", boxdr: "", boxdR: "", boxDr: "", boxDR: "", boxh: "", boxH: "", boxhd: "", boxHd: "", boxhD: "", boxHD: "", boxhu: "", boxHu: "", boxhU: "", boxHU: "", boxminus: "", boxplus: "", boxtimes: "", boxul: "", boxuL: "", boxUl: "", boxUL: "", boxur: "", boxuR: "", boxUr: "", boxUR: "", boxv: "", boxV: "", boxvh: "", boxvH: "", boxVh: "", boxVH: "", boxvl: "", boxvL: "", boxVl: "", boxVL: "", boxvr: "", boxvR: "", boxVr: "", boxVR: "", bprime: "", breve: "", Breve: "", brvbar: "", bscr: "", Bscr: "", bsemi: "", bsim: "", bsime: "", bsolb: "", bsol: "\\", bsolhsub: "", bull: "", bullet: "", bump: "", bumpE: "", bumpe: "", Bumpeq: "", bumpeq: "", Cacute: "", cacute: "", capand: "", capbrcup: "", capcap: "", cap: "", Cap: "", capcup: "", capdot: "", CapitalDifferentialD: "", caps: "", caret: "", caron: "", Cayleys: "", ccaps: "", Ccaron: "", ccaron: "", Ccedil: "", ccedil: "", Ccirc: "", ccirc: "", Cconint: "", ccups: "", ccupssm: "", Cdot: "", cdot: "", cedil: "", Cedilla: "", cemptyv: "", cent: "", centerdot: "", CenterDot: "", cfr: "", Cfr: "", CHcy: "", chcy: "", check: "", checkmark: "", Chi: "", chi: "", circ: "", circeq: "", circlearrowleft: "", circlearrowright: "", circledast: "", circledcirc: "", circleddash: "", CircleDot: "", circledR: "", circledS: "", CircleMinus: "", CirclePlus: "", CircleTimes: "", cir: "", cirE: "", cire: "", cirfnint: "", cirmid: "", cirscir: "", ClockwiseContourIntegral: "", CloseCurlyDoubleQuote: "", CloseCurlyQuote: "", clubs: "", clubsuit: "", colon: ":", Colon: "", Colone: "", colone: "", coloneq: "", comma: ",", commat: "@", comp: "", compfn: "", complement: "", complexes: "", cong: "", congdot: "", Congruent: "", conint: "", Conint: "", ContourIntegral: "", copf: "", Copf: "", coprod: "", Coproduct: "", copy: "", COPY: "", copysr: "", CounterClockwiseContourIntegral: "", crarr: "", cross: "", Cross: "", Cscr: "", cscr: "", csub: "", csube: "", csup: "", csupe: "", ctdot: "", cudarrl: "", cudarrr: "", cuepr: "", cuesc: "", cularr: "", cularrp: "", cupbrcap: "", cupcap: "", CupCap: "", cup: "", Cup: "", cupcup: "", cupdot: "", cupor: "", cups: "", curarr: "", curarrm: "", curlyeqprec: "", curlyeqsucc: "", curlyvee: "", curlywedge: "", curren: "", curvearrowleft: "", curvearrowright: "", cuvee: "", cuwed: "", cwconint: "", cwint: "", cylcty: "", dagger: "", Dagger: "", daleth: "", darr: "", Darr: "", dArr: "", dash: "", Dashv: "", dashv: "", dbkarow: "", dblac: "", Dcaron: "", dcaron: "", Dcy: "", dcy: "", ddagger: "", ddarr: "", DD: "", dd: "", DDotrahd: "", ddotseq: "", deg: "", Del: "", Delta: "", delta: "", demptyv: "", dfisht: "", Dfr: "", dfr: "", dHar: "", dharl: "", dharr: "", DiacriticalAcute: "", DiacriticalDot: "", DiacriticalDoubleAcute: "", DiacriticalGrave: "`", DiacriticalTilde: "", diam: "", diamond: "", Diamond: "", diamondsuit: "", diams: "", die: "", DifferentialD: "", digamma: "", disin: "", div: "", divide: "", divideontimes: "", divonx: "", DJcy: "", djcy: "", dlcorn: "", dlcrop: "", dollar: "$", Dopf: "", dopf: "", Dot: "", dot: "", DotDot: "", doteq: "", doteqdot: "", DotEqual: "", dotminus: "", dotplus: "", dotsquare: "", doublebarwedge: "", DoubleContourIntegral: "", DoubleDot: "", DoubleDownArrow: "", DoubleLeftArrow: "", DoubleLeftRightArrow: "", DoubleLeftTee: "", DoubleLongLeftArrow: "", DoubleLongLeftRightArrow: "", DoubleLongRightArrow: "", DoubleRightArrow: "", DoubleRightTee: "", DoubleUpArrow: "", DoubleUpDownArrow: "", DoubleVerticalBar: "", DownArrowBar: "", downarrow: "", DownArrow: "", Downarrow: "", DownArrowUpArrow: "", DownBreve: "", downdownarrows: "", downharpoonleft: "", downharpoonright: "", DownLeftRightVector: "", DownLeftTeeVector: "", DownLeftVectorBar: "", DownLeftVector: "", DownRightTeeVector: "", DownRightVectorBar: "", DownRightVector: "", DownTeeArrow: "", DownTee: "", drbkarow: "", drcorn: "", drcrop: "", Dscr: "", dscr: "", DScy: "", dscy: "", dsol: "", Dstrok: "", dstrok: "", dtdot: "", dtri: "", dtrif: "", duarr: "", duhar: "", dwangle: "", DZcy: "", dzcy: "", dzigrarr: "", Eacute: "", eacute: "", easter: "", Ecaron: "", ecaron: "", Ecirc: "", ecirc: "", ecir: "", ecolon: "", Ecy: "", ecy: "", eDDot: "", Edot: "", edot: "", eDot: "", ee: "", efDot: "", Efr: "", efr: "", eg: "", Egrave: "", egrave: "", egs: "", egsdot: "", el: "", Element: "", elinters: "", ell: "", els: "", elsdot: "", Emacr: "", emacr: "", empty: "", emptyset: "", EmptySmallSquare: "", emptyv: "", EmptyVerySmallSquare: "", emsp13: "", emsp14: "", emsp: "", ENG: "", eng: "", ensp: "", Eogon: "", eogon: "", Eopf: "", eopf: "", epar: "", eparsl: "", eplus: "", epsi: "", Epsilon: "", epsilon: "", epsiv: "", eqcirc: "", eqcolon: "", eqsim: "", eqslantgtr: "", eqslantless: "", Equal: "", equals: "=", EqualTilde: "", equest: "", Equilibrium: "", equiv: "", equivDD: "", eqvparsl: "", erarr: "", erDot: "", escr: "", Escr: "", esdot: "", Esim: "", esim: "", Eta: "", eta: "", ETH: "", eth: "", Euml: "", euml: "", euro: "", excl: "!", exist: "", Exists: "", expectation: "", exponentiale: "", ExponentialE: "", fallingdotseq: "", Fcy: "", fcy: "", female: "", ffilig: "", fflig: "", ffllig: "", Ffr: "", ffr: "", filig: "", FilledSmallSquare: "", FilledVerySmallSquare: "", fjlig: "fj", flat: "", fllig: "", fltns: "", fnof: "", Fopf: "", fopf: "", forall: "", ForAll: "", fork: "", forkv: "", Fouriertrf: "", fpartint: "", frac12: "", frac13: "", frac14: "", frac15: "", frac16: "", frac18: "", frac23: "", frac25: "", frac34: "", frac35: "", frac38: "", frac45: "", frac56: "", frac58: "", frac78: "", frasl: "", frown: "", fscr: "", Fscr: "", gacute: "", Gamma: "", gamma: "", Gammad: "", gammad: "", gap: "", Gbreve: "", gbreve: "", Gcedil: "", Gcirc: "", gcirc: "", Gcy: "", gcy: "", Gdot: "", gdot: "", ge: "", gE: "", gEl: "", gel: "", geq: "", geqq: "", geqslant: "", gescc: "", ges: "", gesdot: "", gesdoto: "", gesdotol: "", gesl: "", gesles: "", Gfr: "", gfr: "", gg: "", Gg: "", ggg: "", gimel: "", GJcy: "", gjcy: "", gla: "", gl: "", glE: "", glj: "", gnap: "", gnapprox: "", gne: "", gnE: "", gneq: "", gneqq: "", gnsim: "", Gopf: "", gopf: "", grave: "`", GreaterEqual: "", GreaterEqualLess: "", GreaterFullEqual: "", GreaterGreater: "", GreaterLess: "", GreaterSlantEqual: "", GreaterTilde: "", Gscr: "", gscr: "", gsim: "", gsime: "", gsiml: "", gtcc: "", gtcir: "", gt: ">", GT: ">", Gt: "", gtdot: "", gtlPar: "", gtquest: "", gtrapprox: "", gtrarr: "", gtrdot: "", gtreqless: "", gtreqqless: "", gtrless: "", gtrsim: "", gvertneqq: "", gvnE: "", Hacek: "", hairsp: "", half: "", hamilt: "", HARDcy: "", hardcy: "", harrcir: "", harr: "", hArr: "", harrw: "", Hat: "^", hbar: "", Hcirc: "", hcirc: "", hearts: "", heartsuit: "", hellip: "", hercon: "", hfr: "", Hfr: "", HilbertSpace: "", hksearow: "", hkswarow: "", hoarr: "", homtht: "", hookleftarrow: "", hookrightarrow: "", hopf: "", Hopf: "", horbar: "", HorizontalLine: "", hscr: "", Hscr: "", hslash: "", Hstrok: "", hstrok: "", HumpDownHump: "", HumpEqual: "", hybull: "", hyphen: "", Iacute: "", iacute: "", ic: "", Icirc: "", icirc: "", Icy: "", icy: "", Idot: "", IEcy: "", iecy: "", iexcl: "", iff: "", ifr: "", Ifr: "", Igrave: "", igrave: "", ii: "", iiiint: "", iiint: "", iinfin: "", iiota: "", IJlig: "", ijlig: "", Imacr: "", imacr: "", image: "", ImaginaryI: "", imagline: "", imagpart: "", imath: "", Im: "", imof: "", imped: "", Implies: "", incare: "", in: "", infin: "", infintie: "", inodot: "", intcal: "", int: "", Int: "", integers: "", Integral: "", intercal: "", Intersection: "", intlarhk: "", intprod: "", InvisibleComma: "", InvisibleTimes: "", IOcy: "", iocy: "", Iogon: "", iogon: "", Iopf: "", iopf: "", Iota: "", iota: "", iprod: "", iquest: "", iscr: "", Iscr: "", isin: "", isindot: "", isinE: "", isins: "", isinsv: "", isinv: "", it: "", Itilde: "", itilde: "", Iukcy: "", iukcy: "", Iuml: "", iuml: "", Jcirc: "", jcirc: "", Jcy: "", jcy: "", Jfr: "", jfr: "", jmath: "", Jopf: "", jopf: "", Jscr: "", jscr: "", Jsercy: "", jsercy: "", Jukcy: "", jukcy: "", Kappa: "", kappa: "", kappav: "", Kcedil: "", kcedil: "", Kcy: "", kcy: "", Kfr: "", kfr: "", kgreen: "", KHcy: "", khcy: "", KJcy: "", kjcy: "", Kopf: "", kopf: "", Kscr: "", kscr: "", lAarr: "", Lacute: "", lacute: "", laemptyv: "", lagran: "", Lambda: "", lambda: "", lang: "", Lang: "", langd: "", langle: "", lap: "", Laplacetrf: "", laquo: "", larrb: "", larrbfs: "", larr: "", Larr: "", lArr: "", larrfs: "", larrhk: "", larrlp: "", larrpl: "", larrsim: "", larrtl: "", latail: "", lAtail: "", lat: "", late: "", lates: "", lbarr: "", lBarr: "", lbbrk: "", lbrace: "{", lbrack: "[", lbrke: "", lbrksld: "", lbrkslu: "", Lcaron: "", lcaron: "", Lcedil: "", lcedil: "", lceil: "", lcub: "{", Lcy: "", lcy: "", ldca: "", ldquo: "", ldquor: "", ldrdhar: "", ldrushar: "", ldsh: "", le: "", lE: "", LeftAngleBracket: "", LeftArrowBar: "", leftarrow: "", LeftArrow: "", Leftarrow: "", LeftArrowRightArrow: "", leftarrowtail: "", LeftCeiling: "", LeftDoubleBracket: "", LeftDownTeeVector: "", LeftDownVectorBar: "", LeftDownVector: "", LeftFloor: "", leftharpoondown: "", leftharpoonup: "", leftleftarrows: "", leftrightarrow: "", LeftRightArrow: "", Leftrightarrow: "", leftrightarrows: "", leftrightharpoons: "", leftrightsquigarrow: "", LeftRightVector: "", LeftTeeArrow: "", LeftTee: "", LeftTeeVector: "", leftthreetimes: "", LeftTriangleBar: "", LeftTriangle: "", LeftTriangleEqual: "", LeftUpDownVector: "", LeftUpTeeVector: "", LeftUpVectorBar: "", LeftUpVector: "", LeftVectorBar: "", LeftVector: "", lEg: "", leg: "", leq: "", leqq: "", leqslant: "", lescc: "", les: "", lesdot: "", lesdoto: "", lesdotor: "", lesg: "", lesges: "", lessapprox: "", lessdot: "", lesseqgtr: "", lesseqqgtr: "", LessEqualGreater: "", LessFullEqual: "", LessGreater: "", lessgtr: "", LessLess: "", lesssim: "", LessSlantEqual: "", LessTilde: "", lfisht: "", lfloor: "", Lfr: "", lfr: "", lg: "", lgE: "", lHar: "", lhard: "", lharu: "", lharul: "", lhblk: "", LJcy: "", ljcy: "", llarr: "", ll: "", Ll: "", llcorner: "", Lleftarrow: "", llhard: "", lltri: "", Lmidot: "", lmidot: "", lmoustache: "", lmoust: "", lnap: "", lnapprox: "", lne: "", lnE: "", lneq: "", lneqq: "", lnsim: "", loang: "", loarr: "", lobrk: "", longleftarrow: "", LongLeftArrow: "", Longleftarrow: "", longleftrightarrow: "", LongLeftRightArrow: "", Longleftrightarrow: "", longmapsto: "", longrightarrow: "", LongRightArrow: "", Longrightarrow: "", looparrowleft: "", looparrowright: "", lopar: "", Lopf: "", lopf: "", loplus: "", lotimes: "", lowast: "", lowbar: "_", LowerLeftArrow: "", LowerRightArrow: "", loz: "", lozenge: "", lozf: "", lpar: "(", lparlt: "", lrarr: "", lrcorner: "", lrhar: "", lrhard: "", lrm: "", lrtri: "", lsaquo: "", lscr: "", Lscr: "", lsh: "", Lsh: "", lsim: "", lsime: "", lsimg: "", lsqb: "[", lsquo: "", lsquor: "", Lstrok: "", lstrok: "", ltcc: "", ltcir: "", lt: "<", LT: "<", Lt: "", ltdot: "", lthree: "", ltimes: "", ltlarr: "", ltquest: "", ltri: "", ltrie: "", ltrif: "", ltrPar: "", lurdshar: "", luruhar: "", lvertneqq: "", lvnE: "", macr: "", male: "", malt: "", maltese: "", Map: "", map: "", mapsto: "", mapstodown: "", mapstoleft: "", mapstoup: "", marker: "", mcomma: "", Mcy: "", mcy: "", mdash: "", mDDot: "", measuredangle: "", MediumSpace: "", Mellintrf: "", Mfr: "", mfr: "", mho: "", micro: "", midast: "*", midcir: "", mid: "", middot: "", minusb: "", minus: "", minusd: "", minusdu: "", MinusPlus: "", mlcp: "", mldr: "", mnplus: "", models: "", Mopf: "", mopf: "", mp: "", mscr: "", Mscr: "", mstpos: "", Mu: "", mu: "", multimap: "", mumap: "", nabla: "", Nacute: "", nacute: "", nang: "", nap: "", napE: "", napid: "", napos: "", napprox: "", natural: "", naturals: "", natur: "", nbsp: "", nbump: "", nbumpe: "", ncap: "", Ncaron: "", ncaron: "", Ncedil: "", ncedil: "", ncong: "", ncongdot: "", ncup: "", Ncy: "", ncy: "", ndash: "", nearhk: "", nearr: "", neArr: "", nearrow: "", ne: "", nedot: "", NegativeMediumSpace: "", NegativeThickSpace: "", NegativeThinSpace: "", NegativeVeryThinSpace: "", nequiv: "", nesear: "", nesim: "", NestedGreaterGreater: "", NestedLessLess: "", NewLine: `
`, nexist: "", nexists: "", Nfr: "", nfr: "", ngE: "", nge: "", ngeq: "", ngeqq: "", ngeqslant: "", nges: "", nGg: "", ngsim: "", nGt: "", ngt: "", ngtr: "", nGtv: "", nharr: "", nhArr: "", nhpar: "", ni: "", nis: "", nisd: "", niv: "", NJcy: "", njcy: "", nlarr: "", nlArr: "", nldr: "", nlE: "", nle: "", nleftarrow: "", nLeftarrow: "", nleftrightarrow: "", nLeftrightarrow: "", nleq: "", nleqq: "", nleqslant: "", nles: "", nless: "", nLl: "", nlsim: "", nLt: "", nlt: "", nltri: "", nltrie: "", nLtv: "", nmid: "", NoBreak: "", NonBreakingSpace: "", nopf: "", Nopf: "", Not: "", not: "", NotCongruent: "", NotCupCap: "", NotDoubleVerticalBar: "", NotElement: "", NotEqual: "", NotEqualTilde: "", NotExists: "", NotGreater: "", NotGreaterEqual: "", NotGreaterFullEqual: "", NotGreaterGreater: "", NotGreaterLess: "", NotGreaterSlantEqual: "", NotGreaterTilde: "", NotHumpDownHump: "", NotHumpEqual: "", notin: "", notindot: "", notinE: "", notinva: "", notinvb: "", notinvc: "", NotLeftTriangleBar: "", NotLeftTriangle: "", NotLeftTriangleEqual: "", NotLess: "", NotLessEqual: "", NotLessGreater: "", NotLessLess: "", NotLessSlantEqual: "", NotLessTilde: "", NotNestedGreaterGreater: "", NotNestedLessLess: "", notni: "", notniva: "", notnivb: "", notnivc: "", NotPrecedes: "", NotPrecedesEqual: "", NotPrecedesSlantEqual: "", NotReverseElement: "", NotRightTriangleBar: "", NotRightTriangle: "", NotRightTriangleEqual: "", NotSquareSubset: "", NotSquareSubsetEqual: "", NotSquareSuperset: "", NotSquareSupersetEqual: "", NotSubset: "", NotSubsetEqual: "", NotSucceeds: "", NotSucceedsEqual: "", NotSucceedsSlantEqual: "", NotSucceedsTilde: "", NotSuperset: "", NotSupersetEqual: "", NotTilde: "", NotTildeEqual: "", NotTildeFullEqual: "", NotTildeTilde: "", NotVerticalBar: "", nparallel: "", npar: "", nparsl: "", npart: "", npolint: "", npr: "", nprcue: "", nprec: "", npreceq: "", npre: "", nrarrc: "", nrarr: "", nrArr: "", nrarrw: "", nrightarrow: "", nRightarrow: "", nrtri: "", nrtrie: "", nsc: "", nsccue: "", nsce: "", Nscr: "", nscr: "", nshortmid: "", nshortparallel: "", nsim: "", nsime: "", nsimeq: "", nsmid: "", nspar: "", nsqsube: "", nsqsupe: "", nsub: "", nsubE: "", nsube: "", nsubset: "", nsubseteq: "", nsubseteqq: "", nsucc: "", nsucceq: "", nsup: "", nsupE: "", nsupe: "", nsupset: "", nsupseteq: "", nsupseteqq: "", ntgl: "", Ntilde: "", ntilde: "", ntlg: "", ntriangleleft: "", ntrianglelefteq: "", ntriangleright: "", ntrianglerighteq: "", Nu: "", nu: "", num: "#", numero: "", numsp: "", nvap: "", nvdash: "", nvDash: "", nVdash: "", nVDash: "", nvge: "", nvgt: ">", nvHarr: "", nvinfin: "", nvlArr: "", nvle: "", nvlt: "<", nvltrie: "", nvrArr: "", nvrtrie: "", nvsim: "", nwarhk: "", nwarr: "", nwArr: "", nwarrow: "", nwnear: "", Oacute: "", oacute: "", oast: "", Ocirc: "", ocirc: "", ocir: "", Ocy: "", ocy: "", odash: "", Odblac: "", odblac: "", odiv: "", odot: "", odsold: "", OElig: "", oelig: "", ofcir: "", Ofr: "", ofr: "", ogon: "", Ograve: "", ograve: "", ogt: "", ohbar: "", ohm: "", oint: "", olarr: "", olcir: "", olcross: "", oline: "", olt: "", Omacr: "", omacr: "", Omega: "", omega: "", Omicron: "", omicron: "", omid: "", ominus: "", Oopf: "", oopf: "", opar: "", OpenCurlyDoubleQuote: "", OpenCurlyQuote: "", operp: "", oplus: "", orarr: "", Or: "", or: "", ord: "", order: "", orderof: "", ordf: "", ordm: "", origof: "", oror: "", orslope: "", orv: "", oS: "", Oscr: "", oscr: "", Oslash: "", oslash: "", osol: "", Otilde: "", otilde: "", otimesas: "", Otimes: "", otimes: "", Ouml: "", ouml: "", ovbar: "", OverBar: "", OverBrace: "", OverBracket: "", OverParenthesis: "", para: "", parallel: "", par: "", parsim: "", parsl: "", part: "", PartialD: "", Pcy: "", pcy: "", percnt: "%", period: ".", permil: "", perp: "", pertenk: "", Pfr: "", pfr: "", Phi: "", phi: "", phiv: "", phmmat: "", phone: "", Pi: "", pi: "", pitchfork: "", piv: "", planck: "", planckh: "", plankv: "", plusacir: "", plusb: "", pluscir: "", plus: "+", plusdo: "", plusdu: "", pluse: "", PlusMinus: "", plusmn: "", plussim: "", plustwo: "", pm: "", Poincareplane: "", pointint: "", popf: "", Popf: "", pound: "", prap: "", Pr: "", pr: "", prcue: "", precapprox: "", prec: "", preccurlyeq: "", Precedes: "", PrecedesEqual: "", PrecedesSlantEqual: "", PrecedesTilde: "", preceq: "", precnapprox: "", precneqq: "", precnsim: "", pre: "", prE: "", precsim: "", prime: "", Prime: "", primes: "", prnap: "", prnE: "", prnsim: "", prod: "", Product: "", profalar: "", profline: "", profsurf: "", prop: "", Proportional: "", Proportion: "", propto: "", prsim: "", prurel: "", Pscr: "", pscr: "", Psi: "", psi: "", puncsp: "", Qfr: "", qfr: "", qint: "", qopf: "", Qopf: "", qprime: "", Qscr: "", qscr: "", quaternions: "", quatint: "", quest: "?", questeq: "", quot: '"', QUOT: '"', rAarr: "", race: "", Racute: "", racute: "", radic: "", raemptyv: "", rang: "", Rang: "", rangd: "", range: "", rangle: "", raquo: "", rarrap: "", rarrb: "", rarrbfs: "", rarrc: "", rarr: "", Rarr: "", rArr: "", rarrfs: "", rarrhk: "", rarrlp: "", rarrpl: "", rarrsim: "", Rarrtl: "", rarrtl: "", rarrw: "", ratail: "", rAtail: "", ratio: "", rationals: "", rbarr: "", rBarr: "", RBarr: "", rbbrk: "", rbrace: "}", rbrack: "]", rbrke: "", rbrksld: "", rbrkslu: "", Rcaron: "", rcaron: "", Rcedil: "", rcedil: "", rceil: "", rcub: "}", Rcy: "", rcy: "", rdca: "", rdldhar: "", rdquo: "", rdquor: "", rdsh: "", real: "", realine: "", realpart: "", reals: "", Re: "", rect: "", reg: "", REG: "", ReverseElement: "", ReverseEquilibrium: "", ReverseUpEquilibrium: "", rfisht: "", rfloor: "", rfr: "", Rfr: "", rHar: "", rhard: "", rharu: "", rharul: "", Rho: "", rho: "", rhov: "", RightAngleBracket: "", RightArrowBar: "", rightarrow: "", RightArrow: "", Rightarrow: "", RightArrowLeftArrow: "", rightarrowtail: "", RightCeiling: "", RightDoubleBracket: "", RightDownTeeVector: "", RightDownVectorBar: "", RightDownVector: "", RightFloor: "", rightharpoondown: "", rightharpoonup: "", rightleftarrows: "", rightleftharpoons: "", rightrightarrows: "", rightsquigarrow: "", RightTeeArrow: "", RightTee: "", RightTeeVector: "", rightthreetimes: "", RightTriangleBar: "", RightTriangle: "", RightTriangleEqual: "", RightUpDownVector: "", RightUpTeeVector: "", RightUpVectorBar: "", RightUpVector: "", RightVectorBar: "", RightVector: "", ring: "", risingdotseq: "", rlarr: "", rlhar: "", rlm: "", rmoustache: "", rmoust: "", rnmid: "", roang: "", roarr: "", robrk: "", ropar: "", ropf: "", Ropf: "", roplus: "", rotimes: "", RoundImplies: "", rpar: ")", rpargt: "", rppolint: "", rrarr: "", Rrightarrow: "", rsaquo: "", rscr: "", Rscr: "", rsh: "", Rsh: "", rsqb: "]", rsquo: "", rsquor: "", rthree: "", rtimes: "", rtri: "", rtrie: "", rtrif: "", rtriltri: "", RuleDelayed: "", ruluhar: "", rx: "", Sacute: "", sacute: "", sbquo: "", scap: "", Scaron: "", scaron: "", Sc: "", sc: "", sccue: "", sce: "", scE: "", Scedil: "", scedil: "", Scirc: "", scirc: "", scnap: "", scnE: "", scnsim: "", scpolint: "", scsim: "", Scy: "", scy: "", sdotb: "", sdot: "", sdote: "", searhk: "", searr: "", seArr: "", searrow: "", sect: "", semi: ";", seswar: "", setminus: "", setmn: "", sext: "", Sfr: "", sfr: "", sfrown: "", sharp: "", SHCHcy: "", shchcy: "", SHcy: "", shcy: "", ShortDownArrow: "", ShortLeftArrow: "", shortmid: "", shortparallel: "", ShortRightArrow: "", ShortUpArrow: "", shy: "", Sigma: "", sigma: "", sigmaf: "", sigmav: "", sim: "", simdot: "", sime: "", simeq: "", simg: "", simgE: "", siml: "", simlE: "", simne: "", simplus: "", simrarr: "", slarr: "", SmallCircle: "", smallsetminus: "", smashp: "", smeparsl: "", smid: "", smile: "", smt: "", smte: "", smtes: "", SOFTcy: "", softcy: "", solbar: "", solb: "", sol: "/", Sopf: "", sopf: "", spades: "", spadesuit: "", spar: "", sqcap: "", sqcaps: "", sqcup: "", sqcups: "", Sqrt: "", sqsub: "", sqsube: "", sqsubset: "", sqsubseteq: "", sqsup: "", sqsupe: "", sqsupset: "", sqsupseteq: "", square: "", Square: "", SquareIntersection: "", SquareSubset: "", SquareSubsetEqual: "", SquareSuperset: "", SquareSupersetEqual: "", SquareUnion: "", squarf: "", squ: "", squf: "", srarr: "", Sscr: "", sscr: "", ssetmn: "", ssmile: "", sstarf: "", Star: "", star: "", starf: "", straightepsilon: "", straightphi: "", strns: "", sub: "", Sub: "", subdot: "", subE: "", sube: "", subedot: "", submult: "", subnE: "", subne: "", subplus: "", subrarr: "", subset: "", Subset: "", subseteq: "", subseteqq: "", SubsetEqual: "", subsetneq: "", subsetneqq: "", subsim: "", subsub: "", subsup: "", succapprox: "", succ: "", succcurlyeq: "", Succeeds: "", SucceedsEqual: "", SucceedsSlantEqual: "", SucceedsTilde: "", succeq: "", succnapprox: "", succneqq: "", succnsim: "", succsim: "", SuchThat: "", sum: "", Sum: "", sung: "", sup1: "", sup2: "", sup3: "", sup: "", Sup: "", supdot: "", supdsub: "", supE: "", supe: "", supedot: "", Superset: "", SupersetEqual: "", suphsol: "", suphsub: "", suplarr: "", supmult: "", supnE: "", supne: "", supplus: "", supset: "", Supset: "", supseteq: "", supseteqq: "", supsetneq: "", supsetneqq: "", supsim: "", supsub: "", supsup: "", swarhk: "", swarr: "", swArr: "", swarrow: "", swnwar: "", szlig: "", Tab: "	", target: "", Tau: "", tau: "", tbrk: "", Tcaron: "", tcaron: "", Tcedil: "", tcedil: "", Tcy: "", tcy: "", tdot: "", telrec: "", Tfr: "", tfr: "", there4: "", therefore: "", Therefore: "", Theta: "", theta: "", thetasym: "", thetav: "", thickapprox: "", thicksim: "", ThickSpace: "", ThinSpace: "", thinsp: "", thkap: "", thksim: "", THORN: "", thorn: "", tilde: "", Tilde: "", TildeEqual: "", TildeFullEqual: "", TildeTilde: "", timesbar: "", timesb: "", times: "", timesd: "", tint: "", toea: "", topbot: "", topcir: "", top: "", Topf: "", topf: "", topfork: "", tosa: "", tprime: "", trade: "", TRADE: "", triangle: "", triangledown: "", triangleleft: "", trianglelefteq: "", triangleq: "", triangleright: "", trianglerighteq: "", tridot: "", trie: "", triminus: "", TripleDot: "", triplus: "", trisb: "", tritime: "", trpezium: "", Tscr: "", tscr: "", TScy: "", tscy: "", TSHcy: "", tshcy: "", Tstrok: "", tstrok: "", twixt: "", twoheadleftarrow: "", twoheadrightarrow: "", Uacute: "", uacute: "", uarr: "", Uarr: "", uArr: "", Uarrocir: "", Ubrcy: "", ubrcy: "", Ubreve: "", ubreve: "", Ucirc: "", ucirc: "", Ucy: "", ucy: "", udarr: "", Udblac: "", udblac: "", udhar: "", ufisht: "", Ufr: "", ufr: "", Ugrave: "", ugrave: "", uHar: "", uharl: "", uharr: "", uhblk: "", ulcorn: "", ulcorner: "", ulcrop: "", ultri: "", Umacr: "", umacr: "", uml: "", UnderBar: "_", UnderBrace: "", UnderBracket: "", UnderParenthesis: "", Union: "", UnionPlus: "", Uogon: "", uogon: "", Uopf: "", uopf: "", UpArrowBar: "", uparrow: "", UpArrow: "", Uparrow: "", UpArrowDownArrow: "", updownarrow: "", UpDownArrow: "", Updownarrow: "", UpEquilibrium: "", upharpoonleft: "", upharpoonright: "", uplus: "", UpperLeftArrow: "", UpperRightArrow: "", upsi: "", Upsi: "", upsih: "", Upsilon: "", upsilon: "", UpTeeArrow: "", UpTee: "", upuparrows: "", urcorn: "", urcorner: "", urcrop: "", Uring: "", uring: "", urtri: "", Uscr: "", uscr: "", utdot: "", Utilde: "", utilde: "", utri: "", utrif: "", uuarr: "", Uuml: "", uuml: "", uwangle: "", vangrt: "", varepsilon: "", varkappa: "", varnothing: "", varphi: "", varpi: "", varpropto: "", varr: "", vArr: "", varrho: "", varsigma: "", varsubsetneq: "", varsubsetneqq: "", varsupsetneq: "", varsupsetneqq: "", vartheta: "", vartriangleleft: "", vartriangleright: "", vBar: "", Vbar: "", vBarv: "", Vcy: "", vcy: "", vdash: "", vDash: "", Vdash: "", VDash: "", Vdashl: "", veebar: "", vee: "", Vee: "", veeeq: "", vellip: "", verbar: "|", Verbar: "", vert: "|", Vert: "", VerticalBar: "", VerticalLine: "|", VerticalSeparator: "", VerticalTilde: "", VeryThinSpace: "", Vfr: "", vfr: "", vltri: "", vnsub: "", vnsup: "", Vopf: "", vopf: "", vprop: "", vrtri: "", Vscr: "", vscr: "", vsubnE: "", vsubne: "", vsupnE: "", vsupne: "", Vvdash: "", vzigzag: "", Wcirc: "", wcirc: "", wedbar: "", wedge: "", Wedge: "", wedgeq: "", weierp: "", Wfr: "", wfr: "", Wopf: "", wopf: "", wp: "", wr: "", wreath: "", Wscr: "", wscr: "", xcap: "", xcirc: "", xcup: "", xdtri: "", Xfr: "", xfr: "", xharr: "", xhArr: "", Xi: "", xi: "", xlarr: "", xlArr: "", xmap: "", xnis: "", xodot: "", Xopf: "", xopf: "", xoplus: "", xotime: "", xrarr: "", xrArr: "", Xscr: "", xscr: "", xsqcup: "", xuplus: "", xutri: "", xvee: "", xwedge: "", Yacute: "", yacute: "", YAcy: "", yacy: "", Ycirc: "", ycirc: "", Ycy: "", ycy: "", yen: "", Yfr: "", yfr: "", YIcy: "", yicy: "", Yopf: "", yopf: "", Yscr: "", yscr: "", YUcy: "", yucy: "", yuml: "", Yuml: "", Zacute: "", zacute: "", Zcaron: "", zcaron: "", Zcy: "", zcy: "", Zdot: "", zdot: "", zeetrf: "", ZeroWidthSpace: "", Zeta: "", zeta: "", zfr: "", Zfr: "", ZHcy: "", zhcy: "", zigrarr: "", zopf: "", Zopf: "", Zscr: "", zscr: "", zwj: "", zwnj: "" };
} });
var require_legacy = __commonJS3({ "../../node_modules/ansi-to-html/node_modules/entities/lib/maps/legacy.json"(exports, module) {
  module.exports = { Aacute: "", aacute: "", Acirc: "", acirc: "", acute: "", AElig: "", aelig: "", Agrave: "", agrave: "", amp: "&", AMP: "&", Aring: "", aring: "", Atilde: "", atilde: "", Auml: "", auml: "", brvbar: "", Ccedil: "", ccedil: "", cedil: "", cent: "", copy: "", COPY: "", curren: "", deg: "", divide: "", Eacute: "", eacute: "", Ecirc: "", ecirc: "", Egrave: "", egrave: "", ETH: "", eth: "", Euml: "", euml: "", frac12: "", frac14: "", frac34: "", gt: ">", GT: ">", Iacute: "", iacute: "", Icirc: "", icirc: "", iexcl: "", Igrave: "", igrave: "", iquest: "", Iuml: "", iuml: "", laquo: "", lt: "<", LT: "<", macr: "", micro: "", middot: "", nbsp: "", not: "", Ntilde: "", ntilde: "", Oacute: "", oacute: "", Ocirc: "", ocirc: "", Ograve: "", ograve: "", ordf: "", ordm: "", Oslash: "", oslash: "", Otilde: "", otilde: "", Ouml: "", ouml: "", para: "", plusmn: "", pound: "", quot: '"', QUOT: '"', raquo: "", reg: "", REG: "", sect: "", shy: "", sup1: "", sup2: "", sup3: "", szlig: "", THORN: "", thorn: "", times: "", Uacute: "", uacute: "", Ucirc: "", ucirc: "", Ugrave: "", ugrave: "", uml: "", Uuml: "", uuml: "", Yacute: "", yacute: "", yen: "", yuml: "" };
} });
var require_xml = __commonJS3({ "../../node_modules/ansi-to-html/node_modules/entities/lib/maps/xml.json"(exports, module) {
  module.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
} });
var require_decode = __commonJS3({ "../../node_modules/ansi-to-html/node_modules/entities/lib/maps/decode.json"(exports, module) {
  module.exports = { "0": 65533, "128": 8364, "130": 8218, "131": 402, "132": 8222, "133": 8230, "134": 8224, "135": 8225, "136": 710, "137": 8240, "138": 352, "139": 8249, "140": 338, "142": 381, "145": 8216, "146": 8217, "147": 8220, "148": 8221, "149": 8226, "150": 8211, "151": 8212, "152": 732, "153": 8482, "154": 353, "155": 8250, "156": 339, "158": 382, "159": 376 };
} });
var require_decode_codepoint = __commonJS3({ "../../node_modules/ansi-to-html/node_modules/entities/lib/decode_codepoint.js"(exports) {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var decode_json_1 = __importDefault(require_decode()), fromCodePoint = String.fromCodePoint || function(codePoint) {
    var output = "";
    return codePoint > 65535 && (codePoint -= 65536, output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296), codePoint = 56320 | codePoint & 1023), output += String.fromCharCode(codePoint), output;
  };
  function decodeCodePoint(codePoint) {
    return codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111 ? "" : (codePoint in decode_json_1.default && (codePoint = decode_json_1.default[codePoint]), fromCodePoint(codePoint));
  }
  exports.default = decodeCodePoint;
} });
var require_decode2 = __commonJS3({ "../../node_modules/ansi-to-html/node_modules/entities/lib/decode.js"(exports) {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;
  var entities_json_1 = __importDefault(require_entities()), legacy_json_1 = __importDefault(require_legacy()), xml_json_1 = __importDefault(require_xml()), decode_codepoint_1 = __importDefault(require_decode_codepoint()), strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
  exports.decodeXML = getStrictDecoder(xml_json_1.default);
  exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
  function getStrictDecoder(map2) {
    var replace = getReplacer(map2);
    return function(str) {
      return String(str).replace(strictEntityRe, replace);
    };
  }
  var sorter = function(a, b) {
    return a < b ? 1 : -1;
  };
  exports.decodeHTML = function() {
    for (var legacy = Object.keys(legacy_json_1.default).sort(sorter), keys = Object.keys(entities_json_1.default).sort(sorter), i = 0, j = 0; i < keys.length; i++)
      legacy[j] === keys[i] ? (keys[i] += ";?", j++) : keys[i] += ";";
    var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), replace = getReplacer(entities_json_1.default);
    function replacer3(str) {
      return str.substr(-1) !== ";" && (str += ";"), replace(str);
    }
    return function(str) {
      return String(str).replace(re, replacer3);
    };
  }();
  function getReplacer(map2) {
    return function(str) {
      if (str.charAt(1) === "#") {
        var secondChar = str.charAt(2);
        return secondChar === "X" || secondChar === "x" ? decode_codepoint_1.default(parseInt(str.substr(3), 16)) : decode_codepoint_1.default(parseInt(str.substr(2), 10));
      }
      return map2[str.slice(1, -1)] || str;
    };
  }
} });
var require_encode = __commonJS3({ "../../node_modules/ansi-to-html/node_modules/entities/lib/encode.js"(exports) {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = void 0;
  var xml_json_1 = __importDefault(require_xml()), inverseXML = getInverseObj(xml_json_1.default), xmlReplacer = getInverseReplacer(inverseXML);
  exports.encodeXML = getASCIIEncoder(inverseXML);
  var entities_json_1 = __importDefault(require_entities()), inverseHTML = getInverseObj(entities_json_1.default), htmlReplacer = getInverseReplacer(inverseHTML);
  exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);
  exports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
  function getInverseObj(obj) {
    return Object.keys(obj).sort().reduce(function(inverse, name2) {
      return inverse[obj[name2]] = "&" + name2 + ";", inverse;
    }, {});
  }
  function getInverseReplacer(inverse) {
    for (var single = [], multiple = [], _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
      var k2 = _a[_i];
      k2.length === 1 ? single.push("\\" + k2) : multiple.push(k2);
    }
    single.sort();
    for (var start2 = 0; start2 < single.length - 1; start2++) {
      for (var end = start2; end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1); )
        end += 1;
      var count = 1 + end - start2;
      count < 3 || single.splice(start2, count, single[start2] + "-" + single[end]);
    }
    return multiple.unshift("[" + single.join("") + "]"), new RegExp(multiple.join("|"), "g");
  }
  var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, getCodePoint = String.prototype.codePointAt != null ? function(str) {
    return str.codePointAt(0);
  } : function(c) {
    return (c.charCodeAt(0) - 55296) * 1024 + c.charCodeAt(1) - 56320 + 65536;
  };
  function singleCharReplacer(c) {
    return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0)).toString(16).toUpperCase() + ";";
  }
  function getInverse(inverse, re) {
    return function(data) {
      return data.replace(re, function(name2) {
        return inverse[name2];
      }).replace(reNonASCII, singleCharReplacer);
    };
  }
  var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
  function escape2(data) {
    return data.replace(reEscapeChars, singleCharReplacer);
  }
  exports.escape = escape2;
  function escapeUTF8(data) {
    return data.replace(xmlReplacer, singleCharReplacer);
  }
  exports.escapeUTF8 = escapeUTF8;
  function getASCIIEncoder(obj) {
    return function(data) {
      return data.replace(reEscapeChars, function(c) {
        return obj[c] || singleCharReplacer(c);
      });
    };
  }
} });
var require_lib2 = __commonJS3({ "../../node_modules/ansi-to-html/node_modules/entities/lib/index.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
  var decode_1 = require_decode2(), encode_1 = require_encode();
  function decode(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
  }
  exports.decode = decode;
  function decodeStrict(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
  }
  exports.decodeStrict = decodeStrict;
  function encode(data, level) {
    return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
  }
  exports.encode = encode;
  var encode_2 = require_encode();
  Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function() {
    return encode_2.encodeXML;
  } });
  Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function() {
    return encode_2.encodeHTML;
  } });
  Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function() {
    return encode_2.encodeNonAsciiHTML;
  } });
  Object.defineProperty(exports, "escape", { enumerable: true, get: function() {
    return encode_2.escape;
  } });
  Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function() {
    return encode_2.escapeUTF8;
  } });
  Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function() {
    return encode_2.encodeHTML;
  } });
  Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function() {
    return encode_2.encodeHTML;
  } });
  var decode_2 = require_decode2();
  Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function() {
    return decode_2.decodeXML;
  } });
  Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function() {
    return decode_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function() {
    return decode_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function() {
    return decode_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function() {
    return decode_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function() {
    return decode_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function() {
    return decode_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function() {
    return decode_2.decodeXML;
  } });
} });
var require_ansi_to_html = __commonJS3({ "../../node_modules/ansi-to-html/lib/ansi_to_html.js"(exports, module) {
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor))
      throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor && (descriptor.writable = true), Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
  }
  function _createForOfIteratorHelper(o) {
    if (typeof Symbol > "u" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {
        var i = 0, F2 = function() {
        };
        return { s: F2, n: function() {
          return i >= o.length ? { done: true } : { done: false, value: o[i++] };
        }, e: function(_e) {
          throw _e;
        }, f: F2 };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var it, normalCompletion = true, didErr = false, err;
    return { s: function() {
      it = o[Symbol.iterator]();
    }, n: function() {
      var step = it.next();
      return normalCompletion = step.done, step;
    }, e: function(_e2) {
      didErr = true, err = _e2;
    }, f: function() {
      try {
        !normalCompletion && it.return != null && it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (o) {
      if (typeof o == "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
  }
  function _arrayLikeToArray(arr, len) {
    (len == null || len > arr.length) && (len = arr.length);
    for (var i = 0, arr2 = new Array(len); i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }
  var entities = require_lib2(), defaults = { fg: "#FFF", bg: "#000", newline: false, escapeXML: false, stream: false, colors: getDefaultColors() };
  function getDefaultColors() {
    var colors = { 0: "#000", 1: "#A00", 2: "#0A0", 3: "#A50", 4: "#00A", 5: "#A0A", 6: "#0AA", 7: "#AAA", 8: "#555", 9: "#F55", 10: "#5F5", 11: "#FF5", 12: "#55F", 13: "#F5F", 14: "#5FF", 15: "#FFF" };
    return range(0, 5).forEach(function(red) {
      range(0, 5).forEach(function(green) {
        range(0, 5).forEach(function(blue) {
          return setStyleColor(red, green, blue, colors);
        });
      });
    }), range(0, 23).forEach(function(gray) {
      var c = gray + 232, l2 = toHexString(gray * 10 + 8);
      colors[c] = "#" + l2 + l2 + l2;
    }), colors;
  }
  function setStyleColor(red, green, blue, colors) {
    var c = 16 + red * 36 + green * 6 + blue, r = red > 0 ? red * 40 + 55 : 0, g = green > 0 ? green * 40 + 55 : 0, b = blue > 0 ? blue * 40 + 55 : 0;
    colors[c] = toColorHexString([r, g, b]);
  }
  function toHexString(num) {
    for (var str = num.toString(16); str.length < 2; )
      str = "0" + str;
    return str;
  }
  function toColorHexString(ref) {
    var results = [], _iterator = _createForOfIteratorHelper(ref), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var r = _step.value;
        results.push(toHexString(r));
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return "#" + results.join("");
  }
  function generateOutput(stack, token, data, options2) {
    var result2;
    return token === "text" ? result2 = pushText(data, options2) : token === "display" ? result2 = handleDisplay(stack, data, options2) : token === "xterm256" ? result2 = pushForegroundColor(stack, options2.colors[data]) : token === "rgb" && (result2 = handleRgb(stack, data)), result2;
  }
  function handleRgb(stack, data) {
    data = data.substring(2).slice(0, -1);
    var operation = +data.substr(0, 2), color = data.substring(5).split(";"), rgb = color.map(function(value2) {
      return ("0" + Number(value2).toString(16)).substr(-2);
    }).join("");
    return pushStyle(stack, (operation === 38 ? "color:#" : "background-color:#") + rgb);
  }
  function handleDisplay(stack, code, options2) {
    code = parseInt(code, 10);
    var codeMap = { "-1": function() {
      return "<br/>";
    }, 0: function() {
      return stack.length && resetStyles(stack);
    }, 1: function() {
      return pushTag(stack, "b");
    }, 3: function() {
      return pushTag(stack, "i");
    }, 4: function() {
      return pushTag(stack, "u");
    }, 8: function() {
      return pushStyle(stack, "display:none");
    }, 9: function() {
      return pushTag(stack, "strike");
    }, 22: function() {
      return pushStyle(stack, "font-weight:normal;text-decoration:none;font-style:normal");
    }, 23: function() {
      return closeTag(stack, "i");
    }, 24: function() {
      return closeTag(stack, "u");
    }, 39: function() {
      return pushForegroundColor(stack, options2.fg);
    }, 49: function() {
      return pushBackgroundColor(stack, options2.bg);
    }, 53: function() {
      return pushStyle(stack, "text-decoration:overline");
    } }, result2;
    return codeMap[code] ? result2 = codeMap[code]() : 4 < code && code < 7 ? result2 = pushTag(stack, "blink") : 29 < code && code < 38 ? result2 = pushForegroundColor(stack, options2.colors[code - 30]) : 39 < code && code < 48 ? result2 = pushBackgroundColor(stack, options2.colors[code - 40]) : 89 < code && code < 98 ? result2 = pushForegroundColor(stack, options2.colors[8 + (code - 90)]) : 99 < code && code < 108 && (result2 = pushBackgroundColor(stack, options2.colors[8 + (code - 100)])), result2;
  }
  function resetStyles(stack) {
    var stackClone = stack.slice(0);
    return stack.length = 0, stackClone.reverse().map(function(tag) {
      return "</" + tag + ">";
    }).join("");
  }
  function range(low, high) {
    for (var results = [], j = low; j <= high; j++)
      results.push(j);
    return results;
  }
  function notCategory(category) {
    return function(e) {
      return (category === null || e.category !== category) && category !== "all";
    };
  }
  function categoryForCode(code) {
    code = parseInt(code, 10);
    var result2 = null;
    return code === 0 ? result2 = "all" : code === 1 ? result2 = "bold" : 2 < code && code < 5 ? result2 = "underline" : 4 < code && code < 7 ? result2 = "blink" : code === 8 ? result2 = "hide" : code === 9 ? result2 = "strike" : 29 < code && code < 38 || code === 39 || 89 < code && code < 98 ? result2 = "foreground-color" : (39 < code && code < 48 || code === 49 || 99 < code && code < 108) && (result2 = "background-color"), result2;
  }
  function pushText(text, options2) {
    return options2.escapeXML ? entities.encodeXML(text) : text;
  }
  function pushTag(stack, tag, style) {
    return style || (style = ""), stack.push(tag), "<".concat(tag).concat(style ? ' style="'.concat(style, '"') : "", ">");
  }
  function pushStyle(stack, style) {
    return pushTag(stack, "span", style);
  }
  function pushForegroundColor(stack, color) {
    return pushTag(stack, "span", "color:" + color);
  }
  function pushBackgroundColor(stack, color) {
    return pushTag(stack, "span", "background-color:" + color);
  }
  function closeTag(stack, style) {
    var last;
    if (stack.slice(-1)[0] === style && (last = stack.pop()), last)
      return "</" + style + ">";
  }
  function tokenize(text, options2, callback) {
    var ansiMatch = false, ansiHandler = 3;
    function remove() {
      return "";
    }
    function removeXterm256(m2, g1) {
      return callback("xterm256", g1), "";
    }
    function newline(m2) {
      return options2.newline ? callback("display", -1) : callback("text", m2), "";
    }
    function ansiMess(m2, g1) {
      ansiMatch = true, g1.trim().length === 0 && (g1 = "0"), g1 = g1.trimRight(";").split(";");
      var _iterator2 = _createForOfIteratorHelper(g1), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var g = _step2.value;
          callback("display", g);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return "";
    }
    function realText(m2) {
      return callback("text", m2), "";
    }
    function rgb(m2) {
      return callback("rgb", m2), "";
    }
    var tokens = [{ pattern: /^\x08+/, sub: remove }, { pattern: /^\x1b\[[012]?K/, sub: remove }, { pattern: /^\x1b\[\(B/, sub: remove }, { pattern: /^\x1b\[[34]8;2;\d+;\d+;\d+m/, sub: rgb }, { pattern: /^\x1b\[38;5;(\d+)m/, sub: removeXterm256 }, { pattern: /^\n/, sub: newline }, { pattern: /^\r+\n/, sub: newline }, { pattern: /^\x1b\[((?:\d{1,3};?)+|)m/, sub: ansiMess }, { pattern: /^\x1b\[\d?J/, sub: remove }, { pattern: /^\x1b\[\d{0,3};\d{0,3}f/, sub: remove }, { pattern: /^\x1b\[?[\d;]{0,3}/, sub: remove }, { pattern: /^(([^\x1b\x08\r\n])+)/, sub: realText }];
    function process2(handler2, i2) {
      i2 > ansiHandler && ansiMatch || (ansiMatch = false, text = text.replace(handler2.pattern, handler2.sub));
    }
    var results1 = [], _text = text, length = _text.length;
    outer:
      for (; length > 0; ) {
        for (var i = 0, o = 0, len = tokens.length; o < len; i = ++o) {
          var handler = tokens[i];
          if (process2(handler, i), text.length !== length) {
            length = text.length;
            continue outer;
          }
        }
        if (text.length === length)
          break;
        results1.push(0), length = text.length;
      }
    return results1;
  }
  function updateStickyStack(stickyStack, token, data) {
    return token !== "text" && (stickyStack = stickyStack.filter(notCategory(categoryForCode(data))), stickyStack.push({ token, data, category: categoryForCode(data) })), stickyStack;
  }
  var Filter = function() {
    function Filter2(options2) {
      _classCallCheck(this, Filter2), options2 = options2 || {}, options2.colors && (options2.colors = Object.assign({}, defaults.colors, options2.colors)), this.options = Object.assign({}, defaults, options2), this.stack = [], this.stickyStack = [];
    }
    return _createClass(Filter2, [{ key: "toHtml", value: function(input) {
      var _this = this;
      input = typeof input == "string" ? [input] : input;
      var stack = this.stack, options2 = this.options, buf = [];
      return this.stickyStack.forEach(function(element) {
        var output = generateOutput(stack, element.token, element.data, options2);
        output && buf.push(output);
      }), tokenize(input.join(""), options2, function(token, data) {
        var output = generateOutput(stack, token, data, options2);
        output && buf.push(output), options2.stream && (_this.stickyStack = updateStickyStack(_this.stickyStack, token, data));
      }), stack.length && buf.push(resetStyles(stack)), buf.join("");
    } }]), Filter2;
  }();
  module.exports = Filter;
} });
var PREPARE_ABORTED = new Error("prepareAborted");
var { AbortController } = globalThis;
function serializeError(error) {
  try {
    let { name: name2 = "Error", message = String(error), stack } = error;
    return { name: name2, message, stack };
  } catch {
    return { name: "Error", message: String(error) };
  }
}
var StoryRender = class {
  constructor(channel, store, renderToScreen, callbacks, id, viewMode, renderOptions = { autoplay: true, forceInitialArgs: false }, story) {
    this.channel = channel;
    this.store = store;
    this.renderToScreen = renderToScreen;
    this.callbacks = callbacks;
    this.id = id;
    this.viewMode = viewMode;
    this.renderOptions = renderOptions;
    this.type = "story";
    this.notYetRendered = true;
    this.disableKeyListeners = false;
    this.teardownRender = () => {
    };
    this.torndown = false;
    this.abortController = new AbortController(), story && (this.story = story, this.phase = "preparing");
  }
  async runPhase(signal, phase, phaseFn) {
    this.phase = phase, this.channel.emit(STORY_RENDER_PHASE_CHANGED, { newPhase: this.phase, storyId: this.id }), phaseFn && await phaseFn(), signal.aborted && (this.phase = "aborted", this.channel.emit(STORY_RENDER_PHASE_CHANGED, { newPhase: this.phase, storyId: this.id }));
  }
  async prepare() {
    if (await this.runPhase(this.abortController.signal, "preparing", async () => {
      this.story = await this.store.loadStory({ storyId: this.id });
    }), this.abortController.signal.aborted)
      throw this.store.cleanupStory(this.story), PREPARE_ABORTED;
  }
  isEqual(other) {
    return !!(this.id === other.id && this.story && this.story === other.story);
  }
  isPreparing() {
    return ["preparing"].includes(this.phase);
  }
  isPending() {
    return ["rendering", "playing"].includes(this.phase);
  }
  async renderToElement(canvasElement) {
    return this.canvasElement = canvasElement, this.render({ initial: true, forceRemount: true });
  }
  storyContext() {
    if (!this.story)
      throw new Error("Cannot call storyContext before preparing");
    let { forceInitialArgs } = this.renderOptions;
    return this.store.getStoryContext(this.story, { forceInitialArgs });
  }
  async render({ initial = false, forceRemount = false } = {}) {
    let { canvasElement } = this;
    if (!this.story)
      throw new Error("cannot render when not prepared");
    if (!canvasElement)
      throw new Error("cannot render when canvasElement is unset");
    let { id, componentId, title, name: name2, tags, applyLoaders, unboundStoryFn, playFunction } = this.story;
    forceRemount && !initial && (this.cancelRender(), this.abortController = new AbortController());
    let abortSignal = this.abortController.signal;
    try {
      let loadedContext;
      if (await this.runPhase(abortSignal, "loading", async () => {
        loadedContext = await applyLoaders({ ...this.storyContext(), viewMode: this.viewMode });
      }), abortSignal.aborted)
        return;
      let renderStoryContext = { ...loadedContext, ...this.storyContext(), abortSignal, canvasElement }, renderContext = { componentId, title, kind: title, id, name: name2, story: name2, tags, ...this.callbacks, showError: (error) => (this.phase = "errored", this.callbacks.showError(error)), showException: (error) => (this.phase = "errored", this.callbacks.showException(error)), forceRemount: forceRemount || this.notYetRendered, storyContext: renderStoryContext, storyFn: () => unboundStoryFn(renderStoryContext), unboundStoryFn };
      if (await this.runPhase(abortSignal, "rendering", async () => {
        let teardown = await this.renderToScreen(renderContext, canvasElement);
        this.teardownRender = teardown || (() => {
        });
      }), this.notYetRendered = false, abortSignal.aborted)
        return;
      if (this.renderOptions.autoplay && forceRemount && playFunction && this.phase !== "errored") {
        this.disableKeyListeners = true;
        try {
          await this.runPhase(abortSignal, "playing", async () => {
            await playFunction(renderContext.storyContext);
          }), await this.runPhase(abortSignal, "played");
        } catch (error) {
          if (logger.error(error), await this.runPhase(abortSignal, "errored", async () => {
            this.channel.emit(PLAY_FUNCTION_THREW_EXCEPTION, serializeError(error));
          }), this.story.parameters.throwPlayFunctionExceptions !== false)
            throw error;
        }
        if (this.disableKeyListeners = false, abortSignal.aborted)
          return;
      }
      await this.runPhase(abortSignal, "completed", async () => this.channel.emit(STORY_RENDERED, id));
    } catch (err) {
      this.phase = "errored", this.callbacks.showException(err);
    }
  }
  async rerender() {
    return this.render();
  }
  async remount() {
    return this.render({ forceRemount: true });
  }
  cancelRender() {
    var _a;
    (_a = this.abortController) == null ? void 0 : _a.abort();
  }
  async teardown() {
    this.torndown = true, this.cancelRender(), this.story && this.store.cleanupStory(this.story);
    for (let i = 0; i < 3; i += 1) {
      if (!this.isPending()) {
        await this.teardownRender();
        return;
      }
      await new Promise((resolve) => setTimeout(resolve, 0));
    }
    window.location.reload(), await new Promise(() => {
    });
  }
};
var { fetch } = import_global8.global;
var STORY_INDEX_PATH = "./index.json";
var Preview = class {
  constructor(channel = addons.getChannel()) {
    var _a;
    this.channel = channel;
    this.storyRenders = [];
    ((_a = import_global8.global.FEATURES) == null ? void 0 : _a.storyStoreV7) && addons.hasServerChannel() && (this.serverChannel = addons.getServerChannel()), this.storyStore = new StoryStore();
  }
  initialize({ getStoryIndex, importFn, getProjectAnnotations }) {
    return this.getStoryIndex = getStoryIndex, this.importFn = importFn, this.setupListeners(), this.getProjectAnnotationsOrRenderError(getProjectAnnotations).then((projectAnnotations) => this.initializeWithProjectAnnotations(projectAnnotations));
  }
  setupListeners() {
    this.channel.on(STORY_INDEX_INVALIDATED, this.onStoryIndexChanged.bind(this)), this.channel.on(UPDATE_GLOBALS, this.onUpdateGlobals.bind(this)), this.channel.on(UPDATE_STORY_ARGS, this.onUpdateArgs.bind(this)), this.channel.on(RESET_STORY_ARGS, this.onResetArgs.bind(this)), this.channel.on(FORCE_RE_RENDER, this.onForceReRender.bind(this)), this.channel.on(FORCE_REMOUNT, this.onForceRemount.bind(this));
  }
  getProjectAnnotationsOrRenderError(getProjectAnnotations) {
    return import_synchronous_promise3.SynchronousPromise.resolve().then(getProjectAnnotations).then((projectAnnotations) => {
      if (projectAnnotations.renderToDOM && deprecate("`renderToDOM` is deprecated, please rename to `renderToCanvas`"), this.renderToCanvas = projectAnnotations.renderToCanvas || projectAnnotations.renderToDOM, !this.renderToCanvas)
        throw new Error(dedent`
            Expected your framework's preset to export a \`renderToCanvas\` field.

            Perhaps it needs to be upgraded for Storybook 6.4?

            More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field
          `);
      return projectAnnotations;
    }).catch((err) => {
      throw this.renderPreviewEntryError("Error reading preview.js:", err), err;
    });
  }
  initializeWithProjectAnnotations(projectAnnotations) {
    var _a;
    this.storyStore.setProjectAnnotations(projectAnnotations), this.setInitialGlobals();
    let storyIndexPromise;
    if ((_a = import_global8.global.FEATURES) == null ? void 0 : _a.storyStoreV7)
      storyIndexPromise = this.getStoryIndexFromServer();
    else {
      if (!this.getStoryIndex)
        throw new Error("No `getStoryIndex` passed defined in v6 mode");
      storyIndexPromise = import_synchronous_promise3.SynchronousPromise.resolve().then(this.getStoryIndex);
    }
    return storyIndexPromise.then((storyIndex) => this.initializeWithStoryIndex(storyIndex)).catch((err) => {
      throw this.renderPreviewEntryError("Error loading story index:", err), err;
    });
  }
  async setInitialGlobals() {
    this.emitGlobals();
  }
  emitGlobals() {
    if (!this.storyStore.globals || !this.storyStore.projectAnnotations)
      throw new Error("Cannot emit before initialization");
    let payload = { globals: this.storyStore.globals.get() || {}, globalTypes: this.storyStore.projectAnnotations.globalTypes || {} };
    this.channel.emit(SET_GLOBALS, payload);
  }
  async getStoryIndexFromServer() {
    let result2 = await fetch(STORY_INDEX_PATH);
    if (result2.status === 200)
      return result2.json();
    throw new Error(await result2.text());
  }
  initializeWithStoryIndex(storyIndex) {
    var _a;
    if (!this.importFn)
      throw new Error("Cannot call initializeWithStoryIndex before initialization");
    return this.storyStore.initialize({ storyIndex, importFn: this.importFn, cache: !((_a = import_global8.global.FEATURES) == null ? void 0 : _a.storyStoreV7) });
  }
  async onGetProjectAnnotationsChanged({ getProjectAnnotations }) {
    delete this.previewEntryError;
    let projectAnnotations = await this.getProjectAnnotationsOrRenderError(getProjectAnnotations);
    if (!this.storyStore.projectAnnotations) {
      await this.initializeWithProjectAnnotations(projectAnnotations);
      return;
    }
    await this.storyStore.setProjectAnnotations(projectAnnotations), this.emitGlobals();
  }
  async onStoryIndexChanged() {
    if (delete this.previewEntryError, !!this.storyStore.projectAnnotations)
      try {
        let storyIndex = await this.getStoryIndexFromServer();
        this.storyStore.storyIndex || await this.initializeWithStoryIndex(storyIndex), await this.onStoriesChanged({ storyIndex });
      } catch (err) {
        throw this.renderPreviewEntryError("Error loading story index:", err), err;
      }
  }
  async onStoriesChanged({ importFn, storyIndex }) {
    await this.storyStore.onStoriesChanged({ importFn, storyIndex });
  }
  async onUpdateGlobals({ globals }) {
    if (!this.storyStore.globals)
      throw new Error("Cannot call onUpdateGlobals before initialization");
    this.storyStore.globals.update(globals), await Promise.all(this.storyRenders.map((r) => r.rerender())), this.channel.emit(GLOBALS_UPDATED, { globals: this.storyStore.globals.get(), initialGlobals: this.storyStore.globals.initialGlobals });
  }
  async onUpdateArgs({ storyId, updatedArgs }) {
    this.storyStore.args.update(storyId, updatedArgs), await Promise.all(this.storyRenders.filter((r) => r.id === storyId && !r.renderOptions.forceInitialArgs).map((r) => r.rerender())), this.channel.emit(STORY_ARGS_UPDATED, { storyId, args: this.storyStore.args.get(storyId) });
  }
  async onResetArgs({ storyId, argNames }) {
    var _a;
    let story = ((_a = this.storyRenders.find((r) => r.id === storyId)) == null ? void 0 : _a.story) || await this.storyStore.loadStory({ storyId }), updatedArgs = (argNames || [.../* @__PURE__ */ new Set([...Object.keys(story.initialArgs), ...Object.keys(this.storyStore.args.get(storyId))])]).reduce((acc, argName) => (acc[argName] = story.initialArgs[argName], acc), {});
    await this.onUpdateArgs({ storyId, updatedArgs });
  }
  async onForceReRender() {
    await Promise.all(this.storyRenders.map((r) => r.rerender()));
  }
  async onForceRemount({ storyId }) {
    await Promise.all(this.storyRenders.filter((r) => r.id === storyId).map((r) => r.remount()));
  }
  renderStoryToElement(story, element, callbacks, options2) {
    if (!this.renderToCanvas)
      throw new Error("Cannot call renderStoryToElement before initialization");
    let render = new StoryRender(this.channel, this.storyStore, this.renderToCanvas, callbacks, story.id, "docs", options2, story);
    return render.renderToElement(element), this.storyRenders.push(render), async () => {
      await this.teardownRender(render);
    };
  }
  async teardownRender(render, { viewModeChanged } = {}) {
    var _a;
    this.storyRenders = this.storyRenders.filter((r) => r !== render), await ((_a = render == null ? void 0 : render.teardown) == null ? void 0 : _a.call(render, { viewModeChanged }));
  }
  async extract(options2) {
    var _a;
    if (this.previewEntryError)
      throw this.previewEntryError;
    if (!this.storyStore.projectAnnotations)
      throw new Error(dedent`Failed to initialize Storybook.

      Do you have an error in your \`preview.js\`? Check your Storybook's browser console for errors.`);
    return ((_a = import_global8.global.FEATURES) == null ? void 0 : _a.storyStoreV7) && await this.storyStore.cacheAllCSFFiles(), this.storyStore.extract(options2);
  }
  renderPreviewEntryError(reason, err) {
    this.previewEntryError = err, logger.error(reason), logger.error(err), this.channel.emit(CONFIG_ERROR, err);
  }
};
var DocsContext = class {
  constructor(channel, store, renderStoryToElement, csfFiles) {
    this.channel = channel;
    this.store = store;
    this.renderStoryToElement = renderStoryToElement;
    this.storyIdByName = (storyName) => {
      let storyId = this.nameToStoryId.get(storyName);
      if (storyId)
        return storyId;
      throw new Error(`No story found with that name: ${storyName}`);
    };
    this.componentStories = () => this.componentStoriesValue;
    this.storyById = (storyId) => {
      if (!storyId) {
        if (!this.primaryStory)
          throw new Error("No primary story defined for docs entry. Did you forget to use `<Meta>`?");
        return this.primaryStory;
      }
      let csfFile = this.storyIdToCSFFile.get(storyId);
      if (!csfFile)
        throw new Error(`Called \`storyById\` for story that was never loaded: ${storyId}`);
      return this.store.storyFromCSFFile({ storyId, csfFile });
    };
    this.getStoryContext = (story) => ({ ...this.store.getStoryContext(story), viewMode: "docs" });
    this.loadStory = (id) => this.store.loadStory({ storyId: id });
    this.storyIdToCSFFile = /* @__PURE__ */ new Map(), this.exportToStory = /* @__PURE__ */ new Map(), this.exportsToCSFFile = /* @__PURE__ */ new Map(), this.nameToStoryId = /* @__PURE__ */ new Map(), this.componentStoriesValue = [], csfFiles.forEach((csfFile, index) => {
      this.referenceCSFFile(csfFile);
    });
  }
  referenceCSFFile(csfFile) {
    this.exportsToCSFFile.set(csfFile.moduleExports, csfFile), this.exportsToCSFFile.set(csfFile.moduleExports.default, csfFile), this.store.componentStoriesFromCSFFile({ csfFile }).forEach((story) => {
      let annotation = csfFile.stories[story.id];
      this.storyIdToCSFFile.set(annotation.id, csfFile), this.exportToStory.set(annotation.moduleExport, story);
    });
  }
  attachCSFFile(csfFile) {
    if (!this.exportsToCSFFile.has(csfFile.moduleExports))
      throw new Error("Cannot attach a CSF file that has not been referenced");
    this.attachedCSFFile = csfFile, this.store.componentStoriesFromCSFFile({ csfFile }).forEach((story) => {
      this.nameToStoryId.set(story.name, story.id), this.componentStoriesValue.push(story), this.primaryStory || (this.primaryStory = story);
    });
  }
  referenceMeta(metaExports, attach) {
    let resolved = this.resolveModuleExport(metaExports);
    if (resolved.type !== "meta")
      throw new Error("<Meta of={} /> must reference a CSF file module export or meta export. Did you mistakenly reference your component instead of your CSF file?");
    attach && this.attachCSFFile(resolved.csfFile);
  }
  get projectAnnotations() {
    let { projectAnnotations } = this.store;
    if (!projectAnnotations)
      throw new Error("Can't get projectAnnotations from DocsContext before they are initialized");
    return projectAnnotations;
  }
  resolveAttachedModuleExportType(moduleExportType) {
    if (moduleExportType === "story") {
      if (!this.primaryStory)
        throw new Error("No primary story attached to this docs file, did you forget to use <Meta of={} />?");
      return { type: "story", story: this.primaryStory };
    }
    if (!this.attachedCSFFile)
      throw new Error("No CSF file attached to this docs file, did you forget to use <Meta of={} />?");
    if (moduleExportType === "meta")
      return { type: "meta", csfFile: this.attachedCSFFile };
    let { component } = this.attachedCSFFile.meta;
    if (!component)
      throw new Error("Attached CSF file does not defined a component, did you forget to export one?");
    return { type: "component", component };
  }
  resolveModuleExport(moduleExportOrType) {
    let csfFile = this.exportsToCSFFile.get(moduleExportOrType);
    if (csfFile)
      return { type: "meta", csfFile };
    let story = this.exportToStory.get(moduleExportOrType);
    return story ? { type: "story", story } : { type: "component", component: moduleExportOrType };
  }
  resolveOf(moduleExportOrType, validTypes = []) {
    let resolved;
    if (["component", "meta", "story"].includes(moduleExportOrType)) {
      let type = moduleExportOrType;
      resolved = this.resolveAttachedModuleExportType(type);
    } else
      resolved = this.resolveModuleExport(moduleExportOrType);
    if (validTypes.length && !validTypes.includes(resolved.type)) {
      let prettyType = resolved.type === "component" ? "component or unknown" : resolved.type;
      throw new Error(esm_default`Invalid value passed to the 'of' prop. The value was resolved to a '${prettyType}' type but the only types for this block are: ${validTypes.join(", ")}.
        - Did you pass a component to the 'of' prop when the block only supports a story or a meta?
        - ... or vice versa?
        - Did you pass a story, CSF file or meta to the 'of' prop that is not indexed, ie. is not targeted by the 'stories' globs in the main configuration?`);
    }
    switch (resolved.type) {
      case "component":
        return { ...resolved, projectAnnotations: this.projectAnnotations };
      case "meta":
        return { ...resolved, preparedMeta: this.store.preparedMetaFromCSFFile({ csfFile: resolved.csfFile }) };
      case "story":
      default:
        return resolved;
    }
  }
};
var CsfDocsRender = class {
  constructor(channel, store, entry, callbacks) {
    this.channel = channel;
    this.store = store;
    this.entry = entry;
    this.callbacks = callbacks;
    this.type = "docs";
    this.subtype = "csf";
    this.torndown = false;
    this.disableKeyListeners = false;
    this.preparing = false;
    this.id = entry.id;
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = true;
    let { entryExports, csfFiles = [] } = await this.store.loadEntry(this.id);
    if (this.torndown)
      throw PREPARE_ABORTED;
    let { importPath, title } = this.entry, primaryCsfFile = this.store.processCSFFileWithCache(entryExports, importPath, title), primaryStoryId = Object.keys(primaryCsfFile.stories)[0];
    this.story = this.store.storyFromCSFFile({ storyId: primaryStoryId, csfFile: primaryCsfFile }), this.csfFiles = [primaryCsfFile, ...csfFiles], this.preparing = false;
  }
  isEqual(other) {
    return !!(this.id === other.id && this.story && this.story === other.story);
  }
  docsContext(renderStoryToElement) {
    if (!this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    let docsContext = new DocsContext(this.channel, this.store, renderStoryToElement, this.csfFiles);
    return this.csfFiles.forEach((csfFile) => docsContext.attachCSFFile(csfFile)), docsContext;
  }
  async renderToElement(canvasElement, renderStoryToElement) {
    if (!this.story || !this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    let docsContext = this.docsContext(renderStoryToElement), { docs: docsParameter } = this.story.parameters || {};
    if (!docsParameter)
      throw new Error("Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed");
    let renderer = await docsParameter.renderer(), { render } = renderer, renderDocs = async () => {
      try {
        await render(docsContext, docsParameter, canvasElement), this.channel.emit(DOCS_RENDERED, this.id);
      } catch (err) {
        this.callbacks.showException(err);
      }
    };
    return this.rerender = async () => renderDocs(), this.teardownRender = async ({ viewModeChanged }) => {
      !viewModeChanged || !canvasElement || renderer.unmount(canvasElement);
    }, renderDocs();
  }
  async teardown({ viewModeChanged } = {}) {
    var _a;
    (_a = this.teardownRender) == null ? void 0 : _a.call(this, { viewModeChanged }), this.torndown = true;
  }
};
var MdxDocsRender = class {
  constructor(channel, store, entry, callbacks) {
    this.channel = channel;
    this.store = store;
    this.entry = entry;
    this.callbacks = callbacks;
    this.type = "docs";
    this.subtype = "mdx";
    this.torndown = false;
    this.disableKeyListeners = false;
    this.preparing = false;
    this.id = entry.id;
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = true;
    let { entryExports, csfFiles = [] } = await this.store.loadEntry(this.id);
    if (this.torndown)
      throw PREPARE_ABORTED;
    this.csfFiles = csfFiles, this.exports = entryExports, this.preparing = false;
  }
  isEqual(other) {
    return !!(this.id === other.id && this.exports && this.exports === other.exports);
  }
  docsContext(renderStoryToElement) {
    if (!this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    return new DocsContext(this.channel, this.store, renderStoryToElement, this.csfFiles);
  }
  async renderToElement(canvasElement, renderStoryToElement) {
    if (!this.exports || !this.csfFiles || !this.store.projectAnnotations)
      throw new Error("Cannot render docs before preparing");
    let docsContext = this.docsContext(renderStoryToElement), { docs } = this.store.projectAnnotations.parameters || {};
    if (!docs)
      throw new Error("Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed");
    let docsParameter = { ...docs, page: this.exports.default }, renderer = await docs.renderer(), { render } = renderer, renderDocs = async () => {
      try {
        await render(docsContext, docsParameter, canvasElement), this.channel.emit(DOCS_RENDERED, this.id);
      } catch (err) {
        this.callbacks.showException(err);
      }
    };
    return this.rerender = async () => renderDocs(), this.teardownRender = async ({ viewModeChanged } = {}) => {
      !viewModeChanged || !canvasElement || (renderer.unmount(canvasElement), this.torndown = true);
    }, renderDocs();
  }
  async teardown({ viewModeChanged } = {}) {
    var _a;
    (_a = this.teardownRender) == null ? void 0 : _a.call(this, { viewModeChanged }), this.torndown = true;
  }
};
var globalWindow = globalThis;
function focusInInput(event) {
  let target = event.composedPath && event.composedPath()[0] || event.target;
  return /input|textarea/i.test(target.tagName) || target.getAttribute("contenteditable") !== null;
}
var AUTODOCS_TAG2 = "autodocs";
var STORIES_MDX_TAG2 = "stories-mdx";
var ATTACHED_MDX_TAG = "attached-mdx";
function isMdxEntry({ tags }) {
  return !(tags == null ? void 0 : tags.includes(AUTODOCS_TAG2)) && !(tags == null ? void 0 : tags.includes(STORIES_MDX_TAG2));
}
function isStoryRender(r) {
  return r.type === "story";
}
function isDocsRender(r) {
  return r.type === "docs";
}
function isCsfDocsRender(r) {
  return isDocsRender(r) && r.subtype === "csf";
}
var PreviewWithSelection = class extends Preview {
  constructor(selectionStore, view) {
    super();
    this.selectionStore = selectionStore;
    this.view = view;
  }
  setupListeners() {
    super.setupListeners(), globalWindow.onkeydown = this.onKeydown.bind(this), this.channel.on(SET_CURRENT_STORY, this.onSetCurrentStory.bind(this)), this.channel.on(UPDATE_QUERY_PARAMS, this.onUpdateQueryParams.bind(this)), this.channel.on(PRELOAD_ENTRIES, this.onPreloadStories.bind(this));
  }
  async setInitialGlobals() {
    if (!this.storyStore.globals)
      throw new Error("Cannot call setInitialGlobals before initialization");
    let { globals } = this.selectionStore.selectionSpecifier || {};
    globals && this.storyStore.globals.updateFromPersisted(globals), this.emitGlobals();
  }
  initializeWithStoryIndex(storyIndex) {
    return super.initializeWithStoryIndex(storyIndex).then(() => {
      var _a;
      return ((_a = import_global8.global.FEATURES) == null ? void 0 : _a.storyStoreV7) || this.channel.emit(SET_INDEX, this.storyStore.getSetIndexPayload()), this.selectSpecifiedStory();
    });
  }
  async selectSpecifiedStory() {
    if (!this.storyStore.storyIndex)
      throw new Error("Cannot call selectSpecifiedStory before initialization");
    if (this.selectionStore.selection) {
      await this.renderSelection();
      return;
    }
    if (!this.selectionStore.selectionSpecifier) {
      this.renderMissingStory();
      return;
    }
    let { storySpecifier, args: args2 } = this.selectionStore.selectionSpecifier, entry = this.storyStore.storyIndex.entryFromSpecifier(storySpecifier);
    if (!entry) {
      storySpecifier === "*" ? this.renderStoryLoadingException(storySpecifier, new Error(dedent`
            Couldn't find any stories in your Storybook.
            - Please check your stories field of your main.js config.
            - Also check the browser console and terminal for error messages.
          `)) : this.renderStoryLoadingException(storySpecifier, new Error(dedent`
            Couldn't find story matching '${storySpecifier}'.
            - Are you sure a story with that id exists?
            - Please check your stories field of your main.js config.
            - Also check the browser console and terminal for error messages.
          `));
      return;
    }
    let { id: storyId, type: viewMode } = entry;
    this.selectionStore.setSelection({ storyId, viewMode }), this.channel.emit(STORY_SPECIFIED, this.selectionStore.selection), this.channel.emit(CURRENT_STORY_WAS_SET, this.selectionStore.selection), await this.renderSelection({ persistedArgs: args2 });
  }
  async onGetProjectAnnotationsChanged({ getProjectAnnotations }) {
    await super.onGetProjectAnnotationsChanged({ getProjectAnnotations }), this.selectionStore.selection && this.renderSelection();
  }
  async onStoriesChanged({ importFn, storyIndex }) {
    var _a;
    await super.onStoriesChanged({ importFn, storyIndex }), ((_a = import_global8.global.FEATURES) == null ? void 0 : _a.storyStoreV7) || this.channel.emit(SET_INDEX, await this.storyStore.getSetIndexPayload()), this.selectionStore.selection ? await this.renderSelection() : await this.selectSpecifiedStory();
  }
  onKeydown(event) {
    if (!this.storyRenders.find((r) => r.disableKeyListeners) && !focusInInput(event)) {
      let { altKey, ctrlKey, metaKey, shiftKey, key: key2, code, keyCode } = event;
      this.channel.emit(PREVIEW_KEYDOWN, { event: { altKey, ctrlKey, metaKey, shiftKey, key: key2, code, keyCode } });
    }
  }
  async onSetCurrentStory(selection) {
    this.selectionStore.setSelection({ viewMode: "story", ...selection }), await this.storyStore.initializationPromise, this.channel.emit(CURRENT_STORY_WAS_SET, this.selectionStore.selection), this.renderSelection();
  }
  onUpdateQueryParams(queryParams) {
    this.selectionStore.setQueryParams(queryParams);
  }
  async onUpdateGlobals({ globals }) {
    var _a, _b;
    super.onUpdateGlobals({ globals }), (this.currentRender instanceof MdxDocsRender || this.currentRender instanceof CsfDocsRender) && await ((_b = (_a = this.currentRender).rerender) == null ? void 0 : _b.call(_a));
  }
  async onUpdateArgs({ storyId, updatedArgs }) {
    super.onUpdateArgs({ storyId, updatedArgs });
  }
  async onPreloadStories({ ids }) {
    await Promise.allSettled(ids.map((id) => this.storyStore.loadEntry(id)));
  }
  async renderSelection({ persistedArgs } = {}) {
    var _a, _b, _c, _d, _e, _f;
    let { renderToCanvas } = this;
    if (!renderToCanvas)
      throw new Error("Cannot call renderSelection before initialization");
    let { selection } = this.selectionStore;
    if (!selection)
      throw new Error("Cannot call renderSelection as no selection was made");
    let { storyId } = selection, entry;
    try {
      entry = await this.storyStore.storyIdToEntry(storyId);
    } catch (err) {
      this.currentRender && await this.teardownRender(this.currentRender), this.renderStoryLoadingException(storyId, err);
      return;
    }
    let storyIdChanged = ((_a = this.currentSelection) == null ? void 0 : _a.storyId) !== storyId, viewModeChanged = ((_b = this.currentRender) == null ? void 0 : _b.type) !== entry.type;
    entry.type === "story" ? this.view.showPreparingStory({ immediate: viewModeChanged }) : this.view.showPreparingDocs({ immediate: viewModeChanged }), ((_c = this.currentRender) == null ? void 0 : _c.isPreparing()) && await this.teardownRender(this.currentRender);
    let render;
    entry.type === "story" ? render = new StoryRender(this.channel, this.storyStore, (...args2) => (this.view.showStoryDuringRender(), renderToCanvas(...args2)), this.mainStoryCallbacks(storyId), storyId, "story") : isMdxEntry(entry) ? render = new MdxDocsRender(this.channel, this.storyStore, entry, this.mainStoryCallbacks(storyId)) : render = new CsfDocsRender(this.channel, this.storyStore, entry, this.mainStoryCallbacks(storyId));
    let lastSelection = this.currentSelection;
    this.currentSelection = selection;
    let lastRender = this.currentRender;
    this.currentRender = render;
    try {
      await render.prepare();
    } catch (err) {
      err !== PREPARE_ABORTED && (lastRender && await this.teardownRender(lastRender), this.renderStoryLoadingException(storyId, err));
      return;
    }
    let implementationChanged = !storyIdChanged && lastRender && !render.isEqual(lastRender);
    if (persistedArgs && isStoryRender(render)) {
      if (!render.story)
        throw new Error("Render has not been prepared!");
      this.storyStore.args.updateFromPersisted(render.story, persistedArgs);
    }
    if (lastRender && !lastRender.torndown && !storyIdChanged && !implementationChanged && !viewModeChanged) {
      this.currentRender = lastRender, this.channel.emit(STORY_UNCHANGED, storyId), this.view.showMain();
      return;
    }
    if (lastRender && await this.teardownRender(lastRender, { viewModeChanged }), lastSelection && (storyIdChanged || viewModeChanged) && this.channel.emit(STORY_CHANGED, storyId), isStoryRender(render)) {
      if (!render.story)
        throw new Error("Render has not been prepared!");
      let { parameters, initialArgs, argTypes, unmappedArgs } = this.storyStore.getStoryContext(render.story);
      ((_d = import_global8.global.FEATURES) == null ? void 0 : _d.storyStoreV7) && this.channel.emit(STORY_PREPARED, { id: storyId, parameters, initialArgs, argTypes, args: unmappedArgs }), (implementationChanged || persistedArgs) && this.channel.emit(STORY_ARGS_UPDATED, { storyId, args: unmappedArgs });
    } else if ((_e = import_global8.global.FEATURES) == null ? void 0 : _e.storyStoreV7) {
      if (!this.storyStore.projectAnnotations)
        throw new Error("Store not initialized");
      let { parameters } = this.storyStore.projectAnnotations;
      if (isCsfDocsRender(render) || ((_f = render.entry.tags) == null ? void 0 : _f.includes(ATTACHED_MDX_TAG))) {
        if (!render.csfFiles)
          throw new Error("Render not prepared, or attached MDX file has no CSF references");
        ({ parameters } = this.storyStore.preparedMetaFromCSFFile({ csfFile: render.csfFiles[0] }));
      }
      this.channel.emit(DOCS_PREPARED, { id: storyId, parameters });
    }
    if (isStoryRender(render)) {
      if (!render.story)
        throw new Error("Render has not been prepared!");
      this.storyRenders.push(render), this.currentRender.renderToElement(this.view.prepareForStory(render.story));
    } else
      this.currentRender.renderToElement(this.view.prepareForDocs(), this.renderStoryToElement.bind(this));
  }
  async teardownRender(render, { viewModeChanged = false } = {}) {
    var _a;
    this.storyRenders = this.storyRenders.filter((r) => r !== render), await ((_a = render == null ? void 0 : render.teardown) == null ? void 0 : _a.call(render, { viewModeChanged }));
  }
  async extract(options2) {
    var _a;
    if (this.previewEntryError)
      throw this.previewEntryError;
    if (!this.storyStore.projectAnnotations)
      throw new Error(dedent`Failed to initialize Storybook.

      Do you have an error in your \`preview.js\`? Check your Storybook's browser console for errors.`);
    return ((_a = import_global8.global.FEATURES) == null ? void 0 : _a.storyStoreV7) && await this.storyStore.cacheAllCSFFiles(), this.storyStore.extract(options2);
  }
  mainStoryCallbacks(storyId) {
    return { showMain: () => this.view.showMain(), showError: (err) => this.renderError(storyId, err), showException: (err) => this.renderException(storyId, err) };
  }
  renderPreviewEntryError(reason, err) {
    super.renderPreviewEntryError(reason, err), this.view.showErrorDisplay(err);
  }
  renderMissingStory() {
    this.view.showNoPreview(), this.channel.emit(STORY_MISSING);
  }
  renderStoryLoadingException(storySpecifier, err) {
    logger.error(err), this.view.showErrorDisplay(err), this.channel.emit(STORY_MISSING, storySpecifier);
  }
  renderException(storyId, error) {
    var _a;
    let { name: name2 = "Error", message = String(error), stack } = error;
    this.channel.emit(STORY_THREW_EXCEPTION, { name: name2, message, stack }), this.channel.emit(STORY_RENDER_PHASE_CHANGED, { newPhase: "errored", storyId }), ((_a = error.message) == null ? void 0 : _a.startsWith("ignoredException")) || (this.view.showErrorDisplay(error), logger.error(`Error rendering story '${storyId}':`), logger.error(error));
  }
  renderError(storyId, { title, description }) {
    logger.error(`Error rendering story ${title}: ${description}`), this.channel.emit(STORY_ERRORED, { title, description }), this.channel.emit(STORY_RENDER_PHASE_CHANGED, { newPhase: "errored", storyId }), this.view.showErrorDisplay({ message: title, stack: description });
  }
};
var VALIDATION_REGEXP = /^[a-zA-Z0-9 _-]*$/;
var NUMBER_REGEXP = /^-?[0-9]+(\.[0-9]+)?$/;
var HEX_REGEXP = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i;
var COLOR_REGEXP = /^(rgba?|hsla?)\(([0-9]{1,3}),\s?([0-9]{1,3})%?,\s?([0-9]{1,3})%?,?\s?([0-9](\.[0-9]{1,2})?)?\)$/i;
var validateArgs = (key2 = "", value2) => key2 === null || key2 === "" || !VALIDATION_REGEXP.test(key2) ? false : value2 == null || value2 instanceof Date || typeof value2 == "number" || typeof value2 == "boolean" ? true : typeof value2 == "string" ? VALIDATION_REGEXP.test(value2) || NUMBER_REGEXP.test(value2) || HEX_REGEXP.test(value2) || COLOR_REGEXP.test(value2) : Array.isArray(value2) ? value2.every((v2) => validateArgs(key2, v2)) : (0, import_isPlainObject2.default)(value2) ? Object.entries(value2).every(([k2, v2]) => validateArgs(k2, v2)) : false;
var QS_OPTIONS = { delimiter: ";", allowDots: true, allowSparse: true, decoder(str, defaultDecoder, charset, type) {
  if (type === "value" && str.startsWith("!")) {
    if (str === "!undefined")
      return;
    if (str === "!null")
      return null;
    if (str === "!true")
      return true;
    if (str === "!false")
      return false;
    if (str.startsWith("!date(") && str.endsWith(")"))
      return new Date(str.slice(6, -1));
    if (str.startsWith("!hex(") && str.endsWith(")"))
      return `#${str.slice(5, -1)}`;
    let color = str.slice(1).match(COLOR_REGEXP);
    if (color)
      return str.startsWith("!rgba") ? `${color[1]}(${color[2]}, ${color[3]}, ${color[4]}, ${color[5]})` : str.startsWith("!hsla") ? `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%, ${color[5]})` : str.startsWith("!rgb") ? `${color[1]}(${color[2]}, ${color[3]}, ${color[4]})` : `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%)`;
  }
  return type === "value" && NUMBER_REGEXP.test(str) ? Number(str) : defaultDecoder(str, defaultDecoder, charset);
} };
var parseArgsParam = (argsString) => {
  let parts = argsString.split(";").map((part) => part.replace("=", "~").replace(":", "="));
  return Object.entries(import_qs3.default.parse(parts.join(";"), QS_OPTIONS)).reduce((acc, [key2, value2]) => validateArgs(key2, value2) ? Object.assign(acc, { [key2]: value2 }) : (once.warn(dedent`
      Omitted potentially unsafe URL args.

      More info: https://storybook.js.org/docs/react/writing-stories/args#setting-args-through-the-url
    `), acc), {});
};
var { history, document: document3 } = import_global8.global;
function pathToId(path) {
  let match = (path || "").match(/^\/story\/(.+)/);
  if (!match)
    throw new Error(`Invalid path '${path}',  must start with '/story/'`);
  return match[1];
}
var getQueryString = ({ selection, extraParams }) => {
  let { search = "" } = document3.location, { path, selectedKind, selectedStory, ...rest } = import_qs3.default.parse(search, { ignoreQueryPrefix: true });
  return import_qs3.default.stringify({ ...rest, ...extraParams, ...selection && { id: selection.storyId, viewMode: selection.viewMode } }, { encode: false, addQueryPrefix: true });
};
var setPath = (selection) => {
  if (!selection)
    return;
  let query = getQueryString({ selection }), { hash = "" } = document3.location;
  document3.title = selection.storyId, history.replaceState({}, "", `${document3.location.pathname}${query}${hash}`);
};
var isObject4 = (val) => val != null && typeof val == "object" && Array.isArray(val) === false;
var getFirstString = (v2) => {
  if (v2 !== void 0) {
    if (typeof v2 == "string")
      return v2;
    if (Array.isArray(v2))
      return getFirstString(v2[0]);
    if (isObject4(v2))
      return getFirstString(Object.values(v2).filter(Boolean));
  }
};
var getSelectionSpecifierFromPath = () => {
  var _a;
  let query = import_qs3.default.parse((_a = document3 == null ? void 0 : document3.location) == null ? void 0 : _a.search, { ignoreQueryPrefix: true }), args2 = typeof query.args == "string" ? parseArgsParam(query.args) : void 0, globals = typeof query.globals == "string" ? parseArgsParam(query.globals) : void 0, viewMode = getFirstString(query.viewMode);
  (typeof viewMode != "string" || !viewMode.match(/docs|story/)) && (viewMode = "story");
  let path = getFirstString(query.path), storyId = path ? pathToId(path) : getFirstString(query.id);
  return storyId ? { storySpecifier: storyId, args: args2, globals, viewMode } : null;
};
var UrlStore = class {
  constructor() {
    this.selectionSpecifier = getSelectionSpecifierFromPath();
  }
  setSelection(selection) {
    this.selection = selection, setPath(this.selection);
  }
  setQueryParams(queryParams) {
    let query = getQueryString({ extraParams: queryParams }), { hash = "" } = document3.location;
    history.replaceState({}, "", `${document3.location.pathname}${query}${hash}`);
  }
};
var import_ansi_to_html = __toESM3(require_ansi_to_html());
var { document: document22 } = import_global8.global;
var PREPARING_DELAY = 100;
var Mode = ((Mode2) => (Mode2.MAIN = "MAIN", Mode2.NOPREVIEW = "NOPREVIEW", Mode2.PREPARING_STORY = "PREPARING_STORY", Mode2.PREPARING_DOCS = "PREPARING_DOCS", Mode2.ERROR = "ERROR", Mode2))(Mode || {});
var classes = { PREPARING_STORY: "sb-show-preparing-story", PREPARING_DOCS: "sb-show-preparing-docs", MAIN: "sb-show-main", NOPREVIEW: "sb-show-nopreview", ERROR: "sb-show-errordisplay" };
var layoutClassMap = { centered: "sb-main-centered", fullscreen: "sb-main-fullscreen", padded: "sb-main-padded" };
var ansiConverter = new import_ansi_to_html.default({ escapeXML: true });
var WebView = class {
  constructor() {
    var _a;
    this.testing = false;
    let { __SPECIAL_TEST_PARAMETER__ } = import_qs3.default.parse((_a = document22 == null ? void 0 : document22.location) == null ? void 0 : _a.search, { ignoreQueryPrefix: true });
    switch (__SPECIAL_TEST_PARAMETER__) {
      case "preparing-story": {
        this.showPreparingStory(), this.testing = true;
        break;
      }
      case "preparing-docs": {
        this.showPreparingDocs(), this.testing = true;
        break;
      }
    }
  }
  prepareForStory(story) {
    return this.showStory(), this.applyLayout(story.parameters.layout), document22.documentElement.scrollTop = 0, document22.documentElement.scrollLeft = 0, this.storyRoot();
  }
  storyRoot() {
    return document22.getElementById("storybook-root");
  }
  prepareForDocs() {
    return this.showMain(), this.showDocs(), this.applyLayout("fullscreen"), document22.documentElement.scrollTop = 0, document22.documentElement.scrollLeft = 0, this.docsRoot();
  }
  docsRoot() {
    return document22.getElementById("storybook-docs");
  }
  applyLayout(layout = "padded") {
    if (layout === "none") {
      document22.body.classList.remove(this.currentLayoutClass), this.currentLayoutClass = null;
      return;
    }
    this.checkIfLayoutExists(layout);
    let layoutClass = layoutClassMap[layout];
    document22.body.classList.remove(this.currentLayoutClass), document22.body.classList.add(layoutClass), this.currentLayoutClass = layoutClass;
  }
  checkIfLayoutExists(layout) {
    layoutClassMap[layout] || logger.warn(dedent`The desired layout: ${layout} is not a valid option.
         The possible options are: ${Object.keys(layoutClassMap).join(", ")}, none.`);
  }
  showMode(mode) {
    clearTimeout(this.preparingTimeout), Object.keys(Mode).forEach((otherMode) => {
      otherMode === mode ? document22.body.classList.add(classes[otherMode]) : document22.body.classList.remove(classes[otherMode]);
    });
  }
  showErrorDisplay({ message = "", stack = "" }) {
    let header = message, detail = stack, parts = message.split(`
`);
    parts.length > 1 && ([header] = parts, detail = parts.slice(1).join(`
`)), document22.getElementById("error-message").innerHTML = ansiConverter.toHtml(header), document22.getElementById("error-stack").innerHTML = ansiConverter.toHtml(detail), this.showMode("ERROR");
  }
  showNoPreview() {
    var _a, _b;
    this.testing || (this.showMode("NOPREVIEW"), (_a = this.storyRoot()) == null ? void 0 : _a.setAttribute("hidden", "true"), (_b = this.docsRoot()) == null ? void 0 : _b.setAttribute("hidden", "true"));
  }
  showPreparingStory({ immediate = false } = {}) {
    clearTimeout(this.preparingTimeout), immediate ? this.showMode("PREPARING_STORY") : this.preparingTimeout = setTimeout(() => this.showMode("PREPARING_STORY"), PREPARING_DELAY);
  }
  showPreparingDocs({ immediate = false } = {}) {
    clearTimeout(this.preparingTimeout), immediate ? this.showMode("PREPARING_DOCS") : this.preparingTimeout = setTimeout(() => this.showMode("PREPARING_DOCS"), PREPARING_DELAY);
  }
  showMain() {
    this.showMode("MAIN");
  }
  showDocs() {
    this.storyRoot().setAttribute("hidden", "true"), this.docsRoot().removeAttribute("hidden");
  }
  showStory() {
    this.docsRoot().setAttribute("hidden", "true"), this.storyRoot().removeAttribute("hidden");
  }
  showStoryDuringRender() {
    document22.body.classList.add(classes.MAIN);
  }
};
var PreviewWeb = class extends PreviewWithSelection {
  constructor() {
    super(new UrlStore(), new WebView()), import_global8.global.__STORYBOOK_PREVIEW__ = this;
  }
};
var { document: document32 } = import_global8.global;

// node_modules/@storybook/preview-api/dist/chunk-7XX3T4UM.mjs
var import_global9 = __toESM(require_global(), 1);
function executeLoadable(loadable) {
  let reqs = null;
  Array.isArray(loadable) ? reqs = loadable : loadable.keys && (reqs = [loadable]);
  let exportsMap = /* @__PURE__ */ new Map();
  if (reqs)
    reqs.forEach((req) => {
      req.keys().forEach((filename) => {
        try {
          let fileExports = req(filename);
          exportsMap.set(typeof req.resolve == "function" ? req.resolve(filename) : filename, fileExports);
        } catch (error) {
          let errorString = error.message && error.stack ? `${error.message}
 ${error.stack}` : error.toString();
          logger.error(`Unexpected error while loading ${filename}: ${errorString}`);
        }
      });
    });
  else {
    let exported = loadable();
    Array.isArray(exported) && exported.every((obj) => obj.default != null) ? exportsMap = new Map(exported.map((fileExports, index) => [`exports-map-${index}`, fileExports])) : exported && logger.warn(`Loader function passed to 'configure' should return void or an array of module exports that all contain a 'default' export. Received: ${JSON.stringify(exported)}`);
  }
  return exportsMap;
}
function executeLoadableForChanges(loadable, m2) {
  var _a, _b, _c;
  let lastExportsMap = ((_b = (_a = m2 == null ? void 0 : m2.hot) == null ? void 0 : _a.data) == null ? void 0 : _b.lastExportsMap) || /* @__PURE__ */ new Map();
  ((_c = m2 == null ? void 0 : m2.hot) == null ? void 0 : _c.dispose) && (m2.hot.accept(), m2.hot.dispose((data) => {
    data.lastExportsMap = lastExportsMap;
  }));
  let exportsMap = executeLoadable(loadable), added = /* @__PURE__ */ new Map();
  Array.from(exportsMap.entries()).filter(([, fileExports]) => !!fileExports.default).filter(([fileName, fileExports]) => lastExportsMap.get(fileName) !== fileExports).forEach(([fileName, fileExports]) => added.set(fileName, fileExports));
  let removed = /* @__PURE__ */ new Map();
  return Array.from(lastExportsMap.keys()).filter((fileName) => !exportsMap.has(fileName)).forEach((fileName) => {
    let value2 = lastExportsMap.get(fileName);
    value2 && removed.set(fileName, value2);
  }), lastExportsMap = exportsMap, { added, removed };
}
var { FEATURES } = import_global9.global;
var removedApi = (name2) => () => {
  throw new Error(`@storybook/client-api:${name2} was removed in storyStoreV7.`);
};
function start(renderToCanvas, { decorateStory: decorateStory2, render } = {}) {
  var _a, _b;
  if (import_global9.global && (import_global9.global.IS_STORYBOOK = true), FEATURES == null ? void 0 : FEATURES.storyStoreV7)
    return { forceReRender: removedApi("forceReRender"), configure: removedApi("configure"), clientApi: { storiesOf: removedApi("clientApi.storiesOf"), raw: removedApi("raw") } };
  let channel = createBrowserChannel({ page: "preview" });
  addons.setChannel(channel);
  let clientApi = ((_a = import_global9.global) == null ? void 0 : _a.__STORYBOOK_CLIENT_API__) || new ClientApi(), preview = ((_b = import_global9.global) == null ? void 0 : _b.__STORYBOOK_PREVIEW__) || new PreviewWeb(), initialized = false, importFn = (path) => clientApi.importFn(path);
  function onStoriesChanged() {
    let storyIndex = clientApi.getStoryIndex();
    preview.onStoriesChanged({ storyIndex, importFn });
  }
  return clientApi.onImportFnChanged = onStoriesChanged, clientApi.storyStore = preview.storyStore, import_global9.global && (import_global9.global.__STORYBOOK_CLIENT_API__ = clientApi, import_global9.global.__STORYBOOK_ADDONS_CHANNEL__ = channel, import_global9.global.__STORYBOOK_PREVIEW__ = preview, import_global9.global.__STORYBOOK_STORY_STORE__ = preview.storyStore), { forceReRender: () => channel.emit(FORCE_RE_RENDER), clientApi, configure(renderer, loadable, m2, disableBackwardCompatibility = true) {
    if (disableBackwardCompatibility)
      throw new Error("unexpected configure() call");
    clientApi.addParameters({ renderer });
    let getProjectAnnotations = () => {
      let { added, removed } = executeLoadableForChanges(loadable, m2);
      return clientApi._loadAddedExports(), Array.from(added.entries()).forEach(([fileName, fileExports]) => clientApi.facade.addStoriesFromExports(fileName, fileExports)), Array.from(removed.entries()).forEach(([fileName]) => clientApi.facade.clearFilenameExports(fileName)), { render, ...clientApi.facade.projectAnnotations, renderToCanvas, applyDecorators: decorateStory2 };
    };
    initialized ? (getProjectAnnotations(), onStoriesChanged()) : (preview.initialize({ getStoryIndex: () => clientApi.getStoryIndex(), importFn, getProjectAnnotations }), initialized = true);
  } };
}

export {
  require_type,
  require_es_object_atoms,
  require_syntax,
  require_gopd,
  require_es_define_property,
  require_shams3 as require_shams,
  require_function_bind2 as require_function_bind,
  require_functionApply,
  require_actualApply,
  require_call_bind_apply_helpers,
  require_get_proto,
  require_hasown,
  require_get_intrinsic2 as require_get_intrinsic,
  require_call_bound,
  addons,
  combineParameters,
  sanitizeStoryContextUpdate,
  start
};
/*! Bundled license information:

telejson/dist/index.mjs:
  (*!
   * isobject <https://github.com/jonschlinkert/isobject>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
//# sourceMappingURL=chunk-JD2ZCI3T.js.map
