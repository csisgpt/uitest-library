{
  "version": 3,
  "sources": ["../../../../../@jridgewell/resolve-uri/src/resolve-uri.ts", "../../../../../@jridgewell/sourcemap-codec/src/sourcemap-codec.ts", "../../../../../@jridgewell/sourcemap-codec/src/vlq.ts", "../../../../../@jridgewell/sourcemap-codec/src/strings.ts", "../../../../../@jridgewell/sourcemap-codec/src/scopes.ts", "../../../../../@jridgewell/trace-mapping/dist/umd:@jridgewell/sourcemap-codec", "../../../../../@jridgewell/trace-mapping/dist/umd:@jridgewell/resolve-uri", "../../../../../@jridgewell/trace-mapping/src/trace-mapping.ts", "../../../../../@jridgewell/trace-mapping/src/resolve.ts", "../../../../../@jridgewell/trace-mapping/src/strip-filename.ts", "../../../../../@jridgewell/trace-mapping/src/sourcemap-segment.ts", "../../../../../@jridgewell/trace-mapping/src/sort.ts", "../../../../../@jridgewell/trace-mapping/src/binary-search.ts", "../../../../../@jridgewell/trace-mapping/src/by-source.ts", "../../../../../@jridgewell/trace-mapping/src/types.ts", "../../../../../@jridgewell/trace-mapping/src/flatten-map.ts", "../../../../../@jridgewell/gen-mapping/dist/umd:@jridgewell/sourcemap-codec", "../../../../../@jridgewell/gen-mapping/dist/umd:@jridgewell/trace-mapping", "../../../../../@jridgewell/gen-mapping/src/gen-mapping.ts", "../../../../../@jridgewell/gen-mapping/src/set-array.ts", "../../../../../@jridgewell/gen-mapping/src/sourcemap-segment.ts", "../../../../../@ampproject/remapping/src/source-map-tree.ts", "../../../../../@ampproject/remapping/src/build-source-map-tree.ts", "../../../../../@ampproject/remapping/src/source-map.ts", "../../../../../@ampproject/remapping/src/remapping.ts"],
  "sourcesContent": ["// Matches the scheme of a URL, eg \"http://\"\nconst schemeRegex = /^[\\w+.-]+:\\/\\//;\n\n/**\n * Matches the parts of a URL:\n * 1. Scheme, including \":\", guaranteed.\n * 2. User/password, including \"@\", optional.\n * 3. Host, guaranteed.\n * 4. Port, including \":\", optional.\n * 5. Path, including \"/\", optional.\n * 6. Query, including \"?\", optional.\n * 7. Hash, including \"#\", optional.\n */\nconst urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n\n/**\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n *\n * 1. Host, optional.\n * 2. Path, which may include \"/\", guaranteed.\n * 3. Query, including \"?\", optional.\n * 4. Hash, including \"#\", optional.\n */\nconst fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\n\ntype Url = {\n  scheme: string;\n  user: string;\n  host: string;\n  port: string;\n  path: string;\n  query: string;\n  hash: string;\n  type: UrlType;\n};\n\nconst enum UrlType {\n  Empty = 1,\n  Hash = 2,\n  Query = 3,\n  RelativePath = 4,\n  AbsolutePath = 5,\n  SchemeRelative = 6,\n  Absolute = 7,\n}\n\nfunction isAbsoluteUrl(input: string): boolean {\n  return schemeRegex.test(input);\n}\n\nfunction isSchemeRelativeUrl(input: string): boolean {\n  return input.startsWith('//');\n}\n\nfunction isAbsolutePath(input: string): boolean {\n  return input.startsWith('/');\n}\n\nfunction isFileUrl(input: string): boolean {\n  return input.startsWith('file:');\n}\n\nfunction isRelative(input: string): boolean {\n  return /^[.?#]/.test(input);\n}\n\nfunction parseAbsoluteUrl(input: string): Url {\n  const match = urlRegex.exec(input)!;\n  return makeUrl(\n    match[1],\n    match[2] || '',\n    match[3],\n    match[4] || '',\n    match[5] || '/',\n    match[6] || '',\n    match[7] || '',\n  );\n}\n\nfunction parseFileUrl(input: string): Url {\n  const match = fileRegex.exec(input)!;\n  const path = match[2];\n  return makeUrl(\n    'file:',\n    '',\n    match[1] || '',\n    '',\n    isAbsolutePath(path) ? path : '/' + path,\n    match[3] || '',\n    match[4] || '',\n  );\n}\n\nfunction makeUrl(\n  scheme: string,\n  user: string,\n  host: string,\n  port: string,\n  path: string,\n  query: string,\n  hash: string,\n): Url {\n  return {\n    scheme,\n    user,\n    host,\n    port,\n    path,\n    query,\n    hash,\n    type: UrlType.Absolute,\n  };\n}\n\nfunction parseUrl(input: string): Url {\n  if (isSchemeRelativeUrl(input)) {\n    const url = parseAbsoluteUrl('http:' + input);\n    url.scheme = '';\n    url.type = UrlType.SchemeRelative;\n    return url;\n  }\n\n  if (isAbsolutePath(input)) {\n    const url = parseAbsoluteUrl('http://foo.com' + input);\n    url.scheme = '';\n    url.host = '';\n    url.type = UrlType.AbsolutePath;\n    return url;\n  }\n\n  if (isFileUrl(input)) return parseFileUrl(input);\n\n  if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\n\n  const url = parseAbsoluteUrl('http://foo.com/' + input);\n  url.scheme = '';\n  url.host = '';\n  url.type = input\n    ? input.startsWith('?')\n      ? UrlType.Query\n      : input.startsWith('#')\n      ? UrlType.Hash\n      : UrlType.RelativePath\n    : UrlType.Empty;\n  return url;\n}\n\nfunction stripPathFilename(path: string): string {\n  // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n  // paths. It's not a file, so we can't strip it.\n  if (path.endsWith('/..')) return path;\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\n\nfunction mergePaths(url: Url, base: Url) {\n  normalizePath(base, base.type);\n\n  // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n  // path).\n  if (url.path === '/') {\n    url.path = base.path;\n  } else {\n    // Resolution happens relative to the base path's directory, not the file.\n    url.path = stripPathFilename(base.path) + url.path;\n  }\n}\n\n/**\n * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n * \"foo/.\". We need to normalize to a standard representation.\n */\nfunction normalizePath(url: Url, type: UrlType) {\n  const rel = type <= UrlType.RelativePath;\n  const pieces = url.path.split('/');\n\n  // We need to preserve the first piece always, so that we output a leading slash. The item at\n  // pieces[0] is an empty string.\n  let pointer = 1;\n\n  // Positive is the number of real directories we've output, used for popping a parent directory.\n  // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n  let positive = 0;\n\n  // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n  // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n  // real directory, we won't need to append, unless the other conditions happen again.\n  let addTrailingSlash = false;\n\n  for (let i = 1; i < pieces.length; i++) {\n    const piece = pieces[i];\n\n    // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n    if (!piece) {\n      addTrailingSlash = true;\n      continue;\n    }\n\n    // If we encounter a real directory, then we don't need to append anymore.\n    addTrailingSlash = false;\n\n    // A current directory, which we can always drop.\n    if (piece === '.') continue;\n\n    // A parent directory, we need to see if there are any real directories we can pop. Else, we\n    // have an excess of parents, and we'll need to keep the \"..\".\n    if (piece === '..') {\n      if (positive) {\n        addTrailingSlash = true;\n        positive--;\n        pointer--;\n      } else if (rel) {\n        // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n        // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n        pieces[pointer++] = piece;\n      }\n      continue;\n    }\n\n    // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n    // any popped or dropped directories.\n    pieces[pointer++] = piece;\n    positive++;\n  }\n\n  let path = '';\n  for (let i = 1; i < pointer; i++) {\n    path += '/' + pieces[i];\n  }\n  if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n    path += '/';\n  }\n  url.path = path;\n}\n\n/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */\nexport default function resolve(input: string, base: string | undefined): string {\n  if (!input && !base) return '';\n\n  const url = parseUrl(input);\n  let inputType = url.type;\n\n  if (base && inputType !== UrlType.Absolute) {\n    const baseUrl = parseUrl(base);\n    const baseType = baseUrl.type;\n\n    switch (inputType) {\n      case UrlType.Empty:\n        url.hash = baseUrl.hash;\n      // fall through\n\n      case UrlType.Hash:\n        url.query = baseUrl.query;\n      // fall through\n\n      case UrlType.Query:\n      case UrlType.RelativePath:\n        mergePaths(url, baseUrl);\n      // fall through\n\n      case UrlType.AbsolutePath:\n        // The host, user, and port are joined, you can't copy one without the others.\n        url.user = baseUrl.user;\n        url.host = baseUrl.host;\n        url.port = baseUrl.port;\n      // fall through\n\n      case UrlType.SchemeRelative:\n        // The input doesn't have a schema at least, so we need to copy at least that over.\n        url.scheme = baseUrl.scheme;\n    }\n    if (baseType > inputType) inputType = baseType;\n  }\n\n  normalizePath(url, inputType);\n\n  const queryHash = url.query + url.hash;\n  switch (inputType) {\n    // This is impossible, because of the empty checks at the start of the function.\n    // case UrlType.Empty:\n\n    case UrlType.Hash:\n    case UrlType.Query:\n      return queryHash;\n\n    case UrlType.RelativePath: {\n      // The first char is always a \"/\", and we need it to be relative.\n      const path = url.path.slice(1);\n\n      if (!path) return queryHash || '.';\n\n      if (isRelative(base || input) && !isRelative(path)) {\n        // If base started with a leading \".\", or there is no base and input started with a \".\",\n        // then we need to ensure that the relative path starts with a \".\". We don't know if\n        // relative starts with a \"..\", though, so check before prepending.\n        return './' + path + queryHash;\n      }\n\n      return path + queryHash;\n    }\n\n    case UrlType.AbsolutePath:\n      return url.path + queryHash;\n\n    default:\n      return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n  }\n}\n", "import { comma, decodeInteger, encodeInteger, hasMoreVlq, semicolon } from './vlq';\r\nimport { StringWriter, StringReader } from './strings';\r\n\r\nexport {\r\n  decodeOriginalScopes,\r\n  encodeOriginalScopes,\r\n  decodeGeneratedRanges,\r\n  encodeGeneratedRanges,\r\n} from './scopes';\r\nexport type { OriginalScope, GeneratedRange, CallSite, BindingExpressionRange } from './scopes';\r\n\r\nexport type SourceMapSegment =\r\n  | [number]\r\n  | [number, number, number, number]\r\n  | [number, number, number, number, number];\r\nexport type SourceMapLine = SourceMapSegment[];\r\nexport type SourceMapMappings = SourceMapLine[];\r\n\r\nexport function decode(mappings: string): SourceMapMappings {\r\n  const { length } = mappings;\r\n  const reader = new StringReader(mappings);\r\n  const decoded: SourceMapMappings = [];\r\n  let genColumn = 0;\r\n  let sourcesIndex = 0;\r\n  let sourceLine = 0;\r\n  let sourceColumn = 0;\r\n  let namesIndex = 0;\r\n\r\n  do {\r\n    const semi = reader.indexOf(';');\r\n    const line: SourceMapLine = [];\r\n    let sorted = true;\r\n    let lastCol = 0;\r\n    genColumn = 0;\r\n\r\n    while (reader.pos < semi) {\r\n      let seg: SourceMapSegment;\r\n\r\n      genColumn = decodeInteger(reader, genColumn);\r\n      if (genColumn < lastCol) sorted = false;\r\n      lastCol = genColumn;\r\n\r\n      if (hasMoreVlq(reader, semi)) {\r\n        sourcesIndex = decodeInteger(reader, sourcesIndex);\r\n        sourceLine = decodeInteger(reader, sourceLine);\r\n        sourceColumn = decodeInteger(reader, sourceColumn);\r\n\r\n        if (hasMoreVlq(reader, semi)) {\r\n          namesIndex = decodeInteger(reader, namesIndex);\r\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];\r\n        } else {\r\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];\r\n        }\r\n      } else {\r\n        seg = [genColumn];\r\n      }\r\n\r\n      line.push(seg);\r\n      reader.pos++;\r\n    }\r\n\r\n    if (!sorted) sort(line);\r\n    decoded.push(line);\r\n    reader.pos = semi + 1;\r\n  } while (reader.pos <= length);\r\n\r\n  return decoded;\r\n}\r\n\r\nfunction sort(line: SourceMapSegment[]) {\r\n  line.sort(sortComparator);\r\n}\r\n\r\nfunction sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {\r\n  return a[0] - b[0];\r\n}\r\n\r\nexport function encode(decoded: SourceMapMappings): string;\r\nexport function encode(decoded: Readonly<SourceMapMappings>): string;\r\nexport function encode(decoded: Readonly<SourceMapMappings>): string {\r\n  const writer = new StringWriter();\r\n  let sourcesIndex = 0;\r\n  let sourceLine = 0;\r\n  let sourceColumn = 0;\r\n  let namesIndex = 0;\r\n\r\n  for (let i = 0; i < decoded.length; i++) {\r\n    const line = decoded[i];\r\n    if (i > 0) writer.write(semicolon);\r\n    if (line.length === 0) continue;\r\n\r\n    let genColumn = 0;\r\n\r\n    for (let j = 0; j < line.length; j++) {\r\n      const segment = line[j];\r\n      if (j > 0) writer.write(comma);\r\n\r\n      genColumn = encodeInteger(writer, segment[0], genColumn);\r\n\r\n      if (segment.length === 1) continue;\r\n      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);\r\n      sourceLine = encodeInteger(writer, segment[2], sourceLine);\r\n      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);\r\n\r\n      if (segment.length === 4) continue;\r\n      namesIndex = encodeInteger(writer, segment[4], namesIndex);\r\n    }\r\n  }\r\n\r\n  return writer.flush();\r\n}\r\n", "import type { StringReader, StringWriter } from './strings';\r\n\r\nexport const comma = ','.charCodeAt(0);\r\nexport const semicolon = ';'.charCodeAt(0);\r\n\r\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\r\nconst intToChar = new Uint8Array(64); // 64 possible chars.\r\nconst charToInt = new Uint8Array(128); // z is 122 in ASCII\r\n\r\nfor (let i = 0; i < chars.length; i++) {\r\n  const c = chars.charCodeAt(i);\r\n  intToChar[i] = c;\r\n  charToInt[c] = i;\r\n}\r\n\r\nexport function decodeInteger(reader: StringReader, relative: number): number {\r\n  let value = 0;\r\n  let shift = 0;\r\n  let integer = 0;\r\n\r\n  do {\r\n    const c = reader.next();\r\n    integer = charToInt[c];\r\n    value |= (integer & 31) << shift;\r\n    shift += 5;\r\n  } while (integer & 32);\r\n\r\n  const shouldNegate = value & 1;\r\n  value >>>= 1;\r\n\r\n  if (shouldNegate) {\r\n    value = -0x80000000 | -value;\r\n  }\r\n\r\n  return relative + value;\r\n}\r\n\r\nexport function encodeInteger(builder: StringWriter, num: number, relative: number): number {\r\n  let delta = num - relative;\r\n\r\n  delta = delta < 0 ? (-delta << 1) | 1 : delta << 1;\r\n  do {\r\n    let clamped = delta & 0b011111;\r\n    delta >>>= 5;\r\n    if (delta > 0) clamped |= 0b100000;\r\n    builder.write(intToChar[clamped]);\r\n  } while (delta > 0);\r\n\r\n  return num;\r\n}\r\n\r\nexport function hasMoreVlq(reader: StringReader, max: number) {\r\n  if (reader.pos >= max) return false;\r\n  return reader.peek() !== comma;\r\n}\r\n", "const bufLength = 1024 * 16;\r\n\r\n// Provide a fallback for older environments.\r\nconst td =\r\n  typeof TextDecoder !== 'undefined'\r\n    ? /* #__PURE__ */ new TextDecoder()\r\n    : typeof Buffer !== 'undefined'\r\n      ? {\r\n          decode(buf: Uint8Array): string {\r\n            const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\r\n            return out.toString();\r\n          },\r\n        }\r\n      : {\r\n          decode(buf: Uint8Array): string {\r\n            let out = '';\r\n            for (let i = 0; i < buf.length; i++) {\r\n              out += String.fromCharCode(buf[i]);\r\n            }\r\n            return out;\r\n          },\r\n        };\r\n\r\nexport class StringWriter {\r\n  pos = 0;\r\n  private out = '';\r\n  private buffer = new Uint8Array(bufLength);\r\n\r\n  write(v: number): void {\r\n    const { buffer } = this;\r\n    buffer[this.pos++] = v;\r\n    if (this.pos === bufLength) {\r\n      this.out += td.decode(buffer);\r\n      this.pos = 0;\r\n    }\r\n  }\r\n\r\n  flush(): string {\r\n    const { buffer, out, pos } = this;\r\n    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\r\n  }\r\n}\r\n\r\nexport class StringReader {\r\n  pos = 0;\r\n  declare private buffer: string;\r\n\r\n  constructor(buffer: string) {\r\n    this.buffer = buffer;\r\n  }\r\n\r\n  next(): number {\r\n    return this.buffer.charCodeAt(this.pos++);\r\n  }\r\n\r\n  peek(): number {\r\n    return this.buffer.charCodeAt(this.pos);\r\n  }\r\n\r\n  indexOf(char: string): number {\r\n    const { buffer, pos } = this;\r\n    const idx = buffer.indexOf(char, pos);\r\n    return idx === -1 ? buffer.length : idx;\r\n  }\r\n}\r\n", "import { StringReader, StringWriter } from './strings';\r\nimport { comma, decodeInteger, encodeInteger, hasMoreVlq, semicolon } from './vlq';\r\n\r\nconst EMPTY: any[] = [];\r\n\r\ntype Line = number;\r\ntype Column = number;\r\ntype Kind = number;\r\ntype Name = number;\r\ntype Var = number;\r\ntype SourcesIndex = number;\r\ntype ScopesIndex = number;\r\n\r\ntype Mix<A, B, O> = (A & O) | (B & O);\r\n\r\nexport type OriginalScope = Mix<\r\n  [Line, Column, Line, Column, Kind],\r\n  [Line, Column, Line, Column, Kind, Name],\r\n  { vars: Var[] }\r\n>;\r\n\r\nexport type GeneratedRange = Mix<\r\n  [Line, Column, Line, Column],\r\n  [Line, Column, Line, Column, SourcesIndex, ScopesIndex],\r\n  {\r\n    callsite: CallSite | null;\r\n    bindings: Binding[];\r\n    isScope: boolean;\r\n  }\r\n>;\r\nexport type CallSite = [SourcesIndex, Line, Column];\r\ntype Binding = BindingExpressionRange[];\r\nexport type BindingExpressionRange = [Name] | [Name, Line, Column];\r\n\r\nexport function decodeOriginalScopes(input: string): OriginalScope[] {\r\n  const { length } = input;\r\n  const reader = new StringReader(input);\r\n  const scopes: OriginalScope[] = [];\r\n  const stack: OriginalScope[] = [];\r\n  let line = 0;\r\n\r\n  for (; reader.pos < length; reader.pos++) {\r\n    line = decodeInteger(reader, line);\r\n    const column = decodeInteger(reader, 0);\r\n\r\n    if (!hasMoreVlq(reader, length)) {\r\n      const last = stack.pop()!;\r\n      last[2] = line;\r\n      last[3] = column;\r\n      continue;\r\n    }\r\n\r\n    const kind = decodeInteger(reader, 0);\r\n    const fields = decodeInteger(reader, 0);\r\n    const hasName = fields & 0b0001;\r\n\r\n    const scope: OriginalScope = (\r\n      hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind]\r\n    ) as OriginalScope;\r\n\r\n    let vars: Var[] = EMPTY;\r\n    if (hasMoreVlq(reader, length)) {\r\n      vars = [];\r\n      do {\r\n        const varsIndex = decodeInteger(reader, 0);\r\n        vars.push(varsIndex);\r\n      } while (hasMoreVlq(reader, length));\r\n    }\r\n    scope.vars = vars;\r\n\r\n    scopes.push(scope);\r\n    stack.push(scope);\r\n  }\r\n\r\n  return scopes;\r\n}\r\n\r\nexport function encodeOriginalScopes(scopes: OriginalScope[]): string {\r\n  const writer = new StringWriter();\r\n\r\n  for (let i = 0; i < scopes.length; ) {\r\n    i = _encodeOriginalScopes(scopes, i, writer, [0]);\r\n  }\r\n\r\n  return writer.flush();\r\n}\r\n\r\nfunction _encodeOriginalScopes(\r\n  scopes: OriginalScope[],\r\n  index: number,\r\n  writer: StringWriter,\r\n  state: [\r\n    number, // GenColumn\r\n  ],\r\n): number {\r\n  const scope = scopes[index];\r\n  const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;\r\n\r\n  if (index > 0) writer.write(comma);\r\n\r\n  state[0] = encodeInteger(writer, startLine, state[0]);\r\n  encodeInteger(writer, startColumn, 0);\r\n  encodeInteger(writer, kind, 0);\r\n\r\n  const fields = scope.length === 6 ? 0b0001 : 0;\r\n  encodeInteger(writer, fields, 0);\r\n  if (scope.length === 6) encodeInteger(writer, scope[5], 0);\r\n\r\n  for (const v of vars) {\r\n    encodeInteger(writer, v, 0);\r\n  }\r\n\r\n  for (index++; index < scopes.length; ) {\r\n    const next = scopes[index];\r\n    const { 0: l, 1: c } = next;\r\n    if (l > endLine || (l === endLine && c >= endColumn)) {\r\n      break;\r\n    }\r\n    index = _encodeOriginalScopes(scopes, index, writer, state);\r\n  }\r\n\r\n  writer.write(comma);\r\n  state[0] = encodeInteger(writer, endLine, state[0]);\r\n  encodeInteger(writer, endColumn, 0);\r\n\r\n  return index;\r\n}\r\n\r\nexport function decodeGeneratedRanges(input: string): GeneratedRange[] {\r\n  const { length } = input;\r\n  const reader = new StringReader(input);\r\n  const ranges: GeneratedRange[] = [];\r\n  const stack: GeneratedRange[] = [];\r\n\r\n  let genLine = 0;\r\n  let definitionSourcesIndex = 0;\r\n  let definitionScopeIndex = 0;\r\n  let callsiteSourcesIndex = 0;\r\n  let callsiteLine = 0;\r\n  let callsiteColumn = 0;\r\n  let bindingLine = 0;\r\n  let bindingColumn = 0;\r\n\r\n  do {\r\n    const semi = reader.indexOf(';');\r\n    let genColumn = 0;\r\n\r\n    for (; reader.pos < semi; reader.pos++) {\r\n      genColumn = decodeInteger(reader, genColumn);\r\n\r\n      if (!hasMoreVlq(reader, semi)) {\r\n        const last = stack.pop()!;\r\n        last[2] = genLine;\r\n        last[3] = genColumn;\r\n        continue;\r\n      }\r\n\r\n      const fields = decodeInteger(reader, 0);\r\n      const hasDefinition = fields & 0b0001;\r\n      const hasCallsite = fields & 0b0010;\r\n      const hasScope = fields & 0b0100;\r\n\r\n      let callsite: CallSite | null = null;\r\n      let bindings: Binding[] = EMPTY;\r\n      let range: GeneratedRange;\r\n      if (hasDefinition) {\r\n        const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);\r\n        definitionScopeIndex = decodeInteger(\r\n          reader,\r\n          definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0,\r\n        );\r\n\r\n        definitionSourcesIndex = defSourcesIndex;\r\n        range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex] as GeneratedRange;\r\n      } else {\r\n        range = [genLine, genColumn, 0, 0] as GeneratedRange;\r\n      }\r\n\r\n      range.isScope = !!hasScope;\r\n\r\n      if (hasCallsite) {\r\n        const prevCsi = callsiteSourcesIndex;\r\n        const prevLine = callsiteLine;\r\n        callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);\r\n        const sameSource = prevCsi === callsiteSourcesIndex;\r\n        callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);\r\n        callsiteColumn = decodeInteger(\r\n          reader,\r\n          sameSource && prevLine === callsiteLine ? callsiteColumn : 0,\r\n        );\r\n\r\n        callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];\r\n      }\r\n      range.callsite = callsite;\r\n\r\n      if (hasMoreVlq(reader, semi)) {\r\n        bindings = [];\r\n        do {\r\n          bindingLine = genLine;\r\n          bindingColumn = genColumn;\r\n          const expressionsCount = decodeInteger(reader, 0);\r\n          let expressionRanges: BindingExpressionRange[];\r\n          if (expressionsCount < -1) {\r\n            expressionRanges = [[decodeInteger(reader, 0)]];\r\n            for (let i = -1; i > expressionsCount; i--) {\r\n              const prevBl = bindingLine;\r\n              bindingLine = decodeInteger(reader, bindingLine);\r\n              bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);\r\n              const expression = decodeInteger(reader, 0);\r\n              expressionRanges.push([expression, bindingLine, bindingColumn]);\r\n            }\r\n          } else {\r\n            expressionRanges = [[expressionsCount]];\r\n          }\r\n          bindings.push(expressionRanges);\r\n        } while (hasMoreVlq(reader, semi));\r\n      }\r\n      range.bindings = bindings;\r\n\r\n      ranges.push(range);\r\n      stack.push(range);\r\n    }\r\n\r\n    genLine++;\r\n    reader.pos = semi + 1;\r\n  } while (reader.pos < length);\r\n\r\n  return ranges;\r\n}\r\n\r\nexport function encodeGeneratedRanges(ranges: GeneratedRange[]): string {\r\n  if (ranges.length === 0) return '';\r\n\r\n  const writer = new StringWriter();\r\n\r\n  for (let i = 0; i < ranges.length; ) {\r\n    i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);\r\n  }\r\n\r\n  return writer.flush();\r\n}\r\n\r\nfunction _encodeGeneratedRanges(\r\n  ranges: GeneratedRange[],\r\n  index: number,\r\n  writer: StringWriter,\r\n  state: [\r\n    number, // GenLine\r\n    number, // GenColumn\r\n    number, // DefSourcesIndex\r\n    number, // DefScopesIndex\r\n    number, // CallSourcesIndex\r\n    number, // CallLine\r\n    number, // CallColumn\r\n  ],\r\n): number {\r\n  const range = ranges[index];\r\n  const {\r\n    0: startLine,\r\n    1: startColumn,\r\n    2: endLine,\r\n    3: endColumn,\r\n    isScope,\r\n    callsite,\r\n    bindings,\r\n  } = range;\r\n\r\n  if (state[0] < startLine) {\r\n    catchupLine(writer, state[0], startLine);\r\n    state[0] = startLine;\r\n    state[1] = 0;\r\n  } else if (index > 0) {\r\n    writer.write(comma);\r\n  }\r\n\r\n  state[1] = encodeInteger(writer, range[1], state[1]);\r\n\r\n  const fields =\r\n    (range.length === 6 ? 0b0001 : 0) | (callsite ? 0b0010 : 0) | (isScope ? 0b0100 : 0);\r\n  encodeInteger(writer, fields, 0);\r\n\r\n  if (range.length === 6) {\r\n    const { 4: sourcesIndex, 5: scopesIndex } = range;\r\n    if (sourcesIndex !== state[2]) {\r\n      state[3] = 0;\r\n    }\r\n    state[2] = encodeInteger(writer, sourcesIndex, state[2]);\r\n    state[3] = encodeInteger(writer, scopesIndex, state[3]);\r\n  }\r\n\r\n  if (callsite) {\r\n    const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite!;\r\n    if (sourcesIndex !== state[4]) {\r\n      state[5] = 0;\r\n      state[6] = 0;\r\n    } else if (callLine !== state[5]) {\r\n      state[6] = 0;\r\n    }\r\n    state[4] = encodeInteger(writer, sourcesIndex, state[4]);\r\n    state[5] = encodeInteger(writer, callLine, state[5]);\r\n    state[6] = encodeInteger(writer, callColumn, state[6]);\r\n  }\r\n\r\n  if (bindings) {\r\n    for (const binding of bindings) {\r\n      if (binding.length > 1) encodeInteger(writer, -binding.length, 0);\r\n      const expression = binding[0][0];\r\n      encodeInteger(writer, expression, 0);\r\n      let bindingStartLine = startLine;\r\n      let bindingStartColumn = startColumn;\r\n      for (let i = 1; i < binding.length; i++) {\r\n        const expRange = binding[i];\r\n        bindingStartLine = encodeInteger(writer, expRange[1]!, bindingStartLine);\r\n        bindingStartColumn = encodeInteger(writer, expRange[2]!, bindingStartColumn);\r\n        encodeInteger(writer, expRange[0]!, 0);\r\n      }\r\n    }\r\n  }\r\n\r\n  for (index++; index < ranges.length; ) {\r\n    const next = ranges[index];\r\n    const { 0: l, 1: c } = next;\r\n    if (l > endLine || (l === endLine && c >= endColumn)) {\r\n      break;\r\n    }\r\n    index = _encodeGeneratedRanges(ranges, index, writer, state);\r\n  }\r\n\r\n  if (state[0] < endLine) {\r\n    catchupLine(writer, state[0], endLine);\r\n    state[0] = endLine;\r\n    state[1] = 0;\r\n  } else {\r\n    writer.write(comma);\r\n  }\r\n  state[1] = encodeInteger(writer, endColumn, state[1]);\r\n\r\n  return index;\r\n}\r\n\r\nfunction catchupLine(writer: StringWriter, lastLine: number, line: number) {\r\n  do {\r\n    writer.write(semicolon);\r\n  } while (++lastLine < line);\r\n}\r\n", null, null, "import { encode, decode } from '@jridgewell/sourcemap-codec';\r\n\r\nimport resolver from './resolve';\r\nimport maybeSort from './sort';\r\nimport buildBySources from './by-source';\r\nimport {\r\n  memoizedState,\r\n  memoizedBinarySearch,\r\n  upperBound,\r\n  lowerBound,\r\n  found as bsFound,\r\n} from './binary-search';\r\nimport {\r\n  COLUMN,\r\n  SOURCES_INDEX,\r\n  SOURCE_LINE,\r\n  SOURCE_COLUMN,\r\n  NAMES_INDEX,\r\n  REV_GENERATED_LINE,\r\n  REV_GENERATED_COLUMN,\r\n} from './sourcemap-segment';\r\nimport { parse } from './types';\r\n\r\nimport type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';\r\nimport type {\r\n  SourceMapV3,\r\n  DecodedSourceMap,\r\n  EncodedSourceMap,\r\n  InvalidOriginalMapping,\r\n  OriginalMapping,\r\n  InvalidGeneratedMapping,\r\n  GeneratedMapping,\r\n  SourceMapInput,\r\n  Needle,\r\n  SourceNeedle,\r\n  SourceMap,\r\n  EachMapping,\r\n  Bias,\r\n  XInput,\r\n  SectionedSourceMap,\r\n  Ro,\r\n} from './types';\r\nimport type { Source } from './by-source';\r\nimport type { MemoState } from './binary-search';\r\n\r\nexport type { SourceMapSegment } from './sourcemap-segment';\r\nexport type {\r\n  SourceMap,\r\n  DecodedSourceMap,\r\n  EncodedSourceMap,\r\n  Section,\r\n  SectionedSourceMap,\r\n  SourceMapV3,\r\n  Bias,\r\n  EachMapping,\r\n  GeneratedMapping,\r\n  InvalidGeneratedMapping,\r\n  InvalidOriginalMapping,\r\n  Needle,\r\n  OriginalMapping,\r\n  OriginalMapping as Mapping,\r\n  SectionedSourceMapInput,\r\n  SourceMapInput,\r\n  SourceNeedle,\r\n  XInput,\r\n  EncodedSourceMapXInput,\r\n  DecodedSourceMapXInput,\r\n  SectionedSourceMapXInput,\r\n  SectionXInput,\r\n} from './types';\r\n\r\ninterface PublicMap {\r\n  _encoded: TraceMap['_encoded'];\r\n  _decoded: TraceMap['_decoded'];\r\n  _decodedMemo: TraceMap['_decodedMemo'];\r\n  _bySources: TraceMap['_bySources'];\r\n  _bySourceMemos: TraceMap['_bySourceMemos'];\r\n}\r\n\r\nconst LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\r\nconst COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\r\n\r\nexport const LEAST_UPPER_BOUND = -1;\r\nexport const GREATEST_LOWER_BOUND = 1;\r\n\r\nexport { FlattenMap, FlattenMap as AnyMap } from './flatten-map';\r\n\r\nexport class TraceMap implements SourceMap {\r\n  declare version: SourceMapV3['version'];\r\n  declare file: SourceMapV3['file'];\r\n  declare names: SourceMapV3['names'];\r\n  declare sourceRoot: SourceMapV3['sourceRoot'];\r\n  declare sources: SourceMapV3['sources'];\r\n  declare sourcesContent: SourceMapV3['sourcesContent'];\r\n  declare ignoreList: SourceMapV3['ignoreList'];\r\n\r\n  declare resolvedSources: string[];\r\n  declare private _encoded: string | undefined;\r\n\r\n  declare private _decoded: SourceMapSegment[][] | undefined;\r\n  declare private _decodedMemo: MemoState;\r\n\r\n  declare private _bySources: Source[] | undefined;\r\n  declare private _bySourceMemos: MemoState[] | undefined;\r\n\r\n  constructor(map: Ro<SourceMapInput>, mapUrl?: string | null) {\r\n    const isString = typeof map === 'string';\r\n    if (!isString && (map as unknown as { _decodedMemo: any })._decodedMemo) return map as TraceMap;\r\n\r\n    const parsed = parse(map as Exclude<SourceMapInput, TraceMap>);\r\n\r\n    const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\r\n    this.version = version;\r\n    this.file = file;\r\n    this.names = names || [];\r\n    this.sourceRoot = sourceRoot;\r\n    this.sources = sources;\r\n    this.sourcesContent = sourcesContent;\r\n    this.ignoreList = parsed.ignoreList || (parsed as XInput).x_google_ignoreList || undefined;\r\n\r\n    const resolve = resolver(mapUrl, sourceRoot);\r\n    this.resolvedSources = sources.map(resolve);\r\n\r\n    const { mappings } = parsed;\r\n    if (typeof mappings === 'string') {\r\n      this._encoded = mappings;\r\n      this._decoded = undefined;\r\n    } else if (Array.isArray(mappings)) {\r\n      this._encoded = undefined;\r\n      this._decoded = maybeSort(mappings, isString);\r\n    } else if ((parsed as unknown as SectionedSourceMap).sections) {\r\n      throw new Error(`TraceMap passed sectioned source map, please use FlattenMap export instead`);\r\n    } else {\r\n      throw new Error(`invalid source map: ${JSON.stringify(parsed)}`);\r\n    }\r\n\r\n    this._decodedMemo = memoizedState();\r\n    this._bySources = undefined;\r\n    this._bySourceMemos = undefined;\r\n  }\r\n}\r\n\r\n/**\r\n * Typescript doesn't allow friend access to private fields, so this just casts the map into a type\r\n * with public access modifiers.\r\n */\r\nfunction cast(map: unknown): PublicMap {\r\n  return map as any;\r\n}\r\n\r\n/**\r\n * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\r\n */\r\nexport function encodedMappings(map: TraceMap): EncodedSourceMap['mappings'] {\r\n  return (cast(map)._encoded ??= encode(cast(map)._decoded!));\r\n}\r\n\r\n/**\r\n * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\r\n */\r\nexport function decodedMappings(map: TraceMap): Readonly<DecodedSourceMap['mappings']> {\r\n  return (cast(map)._decoded ||= decode(cast(map)._encoded!));\r\n}\r\n\r\n/**\r\n * A low-level API to find the segment associated with a generated line/column (think, from a\r\n * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\r\n */\r\nexport function traceSegment(\r\n  map: TraceMap,\r\n  line: number,\r\n  column: number,\r\n): Readonly<SourceMapSegment> | null {\r\n  const decoded = decodedMappings(map);\r\n\r\n  // It's common for parent source maps to have pointers to lines that have no\r\n  // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\r\n  if (line >= decoded.length) return null;\r\n\r\n  const segments = decoded[line];\r\n  const index = traceSegmentInternal(\r\n    segments,\r\n    cast(map)._decodedMemo,\r\n    line,\r\n    column,\r\n    GREATEST_LOWER_BOUND,\r\n  );\r\n\r\n  return index === -1 ? null : segments[index];\r\n}\r\n\r\n/**\r\n * A higher-level API to find the source/line/column associated with a generated line/column\r\n * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\r\n * `source-map` library.\r\n */\r\nexport function originalPositionFor(\r\n  map: TraceMap,\r\n  needle: Needle,\r\n): OriginalMapping | InvalidOriginalMapping {\r\n  let { line, column, bias } = needle;\r\n  line--;\r\n  if (line < 0) throw new Error(LINE_GTR_ZERO);\r\n  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\r\n\r\n  const decoded = decodedMappings(map);\r\n\r\n  // It's common for parent source maps to have pointers to lines that have no\r\n  // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\r\n  if (line >= decoded.length) return OMapping(null, null, null, null);\r\n\r\n  const segments = decoded[line];\r\n  const index = traceSegmentInternal(\r\n    segments,\r\n    cast(map)._decodedMemo,\r\n    line,\r\n    column,\r\n    bias || GREATEST_LOWER_BOUND,\r\n  );\r\n\r\n  if (index === -1) return OMapping(null, null, null, null);\r\n\r\n  const segment = segments[index];\r\n  if (segment.length === 1) return OMapping(null, null, null, null);\r\n\r\n  const { names, resolvedSources } = map;\r\n  return OMapping(\r\n    resolvedSources[segment[SOURCES_INDEX]],\r\n    segment[SOURCE_LINE] + 1,\r\n    segment[SOURCE_COLUMN],\r\n    segment.length === 5 ? names[segment[NAMES_INDEX]] : null,\r\n  );\r\n}\r\n\r\n/**\r\n * Finds the generated line/column position of the provided source/line/column source position.\r\n */\r\nexport function generatedPositionFor(\r\n  map: TraceMap,\r\n  needle: SourceNeedle,\r\n): GeneratedMapping | InvalidGeneratedMapping {\r\n  const { source, line, column, bias } = needle;\r\n  return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\r\n}\r\n\r\n/**\r\n * Finds all generated line/column positions of the provided source/line/column source position.\r\n */\r\nexport function allGeneratedPositionsFor(map: TraceMap, needle: SourceNeedle): GeneratedMapping[] {\r\n  const { source, line, column, bias } = needle;\r\n  // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.\r\n  return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\r\n}\r\n\r\n/**\r\n * Iterates each mapping in generated position order.\r\n */\r\nexport function eachMapping(map: TraceMap, cb: (mapping: EachMapping) => void): void {\r\n  const decoded = decodedMappings(map);\r\n  const { names, resolvedSources } = map;\r\n\r\n  for (let i = 0; i < decoded.length; i++) {\r\n    const line = decoded[i];\r\n    for (let j = 0; j < line.length; j++) {\r\n      const seg = line[j];\r\n\r\n      const generatedLine = i + 1;\r\n      const generatedColumn = seg[0];\r\n      let source = null;\r\n      let originalLine = null;\r\n      let originalColumn = null;\r\n      let name = null;\r\n      if (seg.length !== 1) {\r\n        source = resolvedSources[seg[1]];\r\n        originalLine = seg[2] + 1;\r\n        originalColumn = seg[3];\r\n      }\r\n      if (seg.length === 5) name = names[seg[4]];\r\n\r\n      cb({\r\n        generatedLine,\r\n        generatedColumn,\r\n        source,\r\n        originalLine,\r\n        originalColumn,\r\n        name,\r\n      } as EachMapping);\r\n    }\r\n  }\r\n}\r\n\r\nfunction sourceIndex(map: TraceMap, source: string): number {\r\n  const { sources, resolvedSources } = map;\r\n  let index = sources.indexOf(source);\r\n  if (index === -1) index = resolvedSources.indexOf(source);\r\n  return index;\r\n}\r\n\r\n/**\r\n * Retrieves the source content for a particular source, if its found. Returns null if not.\r\n */\r\nexport function sourceContentFor(map: TraceMap, source: string): string | null {\r\n  const { sourcesContent } = map;\r\n  if (sourcesContent == null) return null;\r\n  const index = sourceIndex(map, source);\r\n  return index === -1 ? null : sourcesContent[index];\r\n}\r\n\r\n/**\r\n * Determines if the source is marked to ignore by the source map.\r\n */\r\nexport function isIgnored(map: TraceMap, source: string): boolean {\r\n  const { ignoreList } = map;\r\n  if (ignoreList == null) return false;\r\n  const index = sourceIndex(map, source);\r\n  return index === -1 ? false : ignoreList.includes(index);\r\n}\r\n\r\n/**\r\n * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\r\n * maps.\r\n */\r\nexport function presortedDecodedMap(map: DecodedSourceMap, mapUrl?: string): TraceMap {\r\n  const tracer = new TraceMap(clone(map, []), mapUrl);\r\n  cast(tracer)._decoded = map.mappings;\r\n  return tracer;\r\n}\r\n\r\n/**\r\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\r\n * a sourcemap, or to JSON.stringify.\r\n */\r\nexport function decodedMap(\r\n  map: TraceMap,\r\n): Omit<DecodedSourceMap, 'mappings'> & { mappings: readonly SourceMapSegment[][] } {\r\n  return clone(map, decodedMappings(map));\r\n}\r\n\r\n/**\r\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\r\n * a sourcemap, or to JSON.stringify.\r\n */\r\nexport function encodedMap(map: TraceMap): EncodedSourceMap {\r\n  return clone(map, encodedMappings(map));\r\n}\r\n\r\nfunction clone<T extends string | readonly SourceMapSegment[][]>(\r\n  map: TraceMap | DecodedSourceMap,\r\n  mappings: T,\r\n): T extends string ? EncodedSourceMap : DecodedSourceMap {\r\n  return {\r\n    version: map.version,\r\n    file: map.file,\r\n    names: map.names,\r\n    sourceRoot: map.sourceRoot,\r\n    sources: map.sources,\r\n    sourcesContent: map.sourcesContent,\r\n    mappings,\r\n    ignoreList: map.ignoreList || (map as XInput).x_google_ignoreList,\r\n  } as any;\r\n}\r\n\r\nfunction OMapping(source: null, line: null, column: null, name: null): InvalidOriginalMapping;\r\nfunction OMapping(\r\n  source: string,\r\n  line: number,\r\n  column: number,\r\n  name: string | null,\r\n): OriginalMapping;\r\nfunction OMapping(\r\n  source: string | null,\r\n  line: number | null,\r\n  column: number | null,\r\n  name: string | null,\r\n): OriginalMapping | InvalidOriginalMapping {\r\n  return { source, line, column, name } as any;\r\n}\r\n\r\nfunction GMapping(line: null, column: null): InvalidGeneratedMapping;\r\nfunction GMapping(line: number, column: number): GeneratedMapping;\r\nfunction GMapping(\r\n  line: number | null,\r\n  column: number | null,\r\n): GeneratedMapping | InvalidGeneratedMapping {\r\n  return { line, column } as any;\r\n}\r\n\r\nfunction traceSegmentInternal(\r\n  segments: SourceMapSegment[],\r\n  memo: MemoState,\r\n  line: number,\r\n  column: number,\r\n  bias: Bias,\r\n): number;\r\nfunction traceSegmentInternal(\r\n  segments: ReverseSegment[],\r\n  memo: MemoState,\r\n  line: number,\r\n  column: number,\r\n  bias: Bias,\r\n): number;\r\nfunction traceSegmentInternal(\r\n  segments: SourceMapSegment[] | ReverseSegment[],\r\n  memo: MemoState,\r\n  line: number,\r\n  column: number,\r\n  bias: Bias,\r\n): number {\r\n  let index = memoizedBinarySearch(segments, column, memo, line);\r\n  if (bsFound) {\r\n    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\r\n  } else if (bias === LEAST_UPPER_BOUND) index++;\r\n\r\n  if (index === -1 || index === segments.length) return -1;\r\n  return index;\r\n}\r\n\r\nfunction sliceGeneratedPositions(\r\n  segments: ReverseSegment[],\r\n  memo: MemoState,\r\n  line: number,\r\n  column: number,\r\n  bias: Bias,\r\n): GeneratedMapping[] {\r\n  let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\r\n\r\n  // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in\r\n  // insertion order) segment that matched. Even if we did respect the bias when tracing, we would\r\n  // still need to call `lowerBound()` to find the first segment, which is slower than just looking\r\n  // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the\r\n  // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to\r\n  // match LEAST_UPPER_BOUND.\r\n  if (!bsFound && bias === LEAST_UPPER_BOUND) min++;\r\n\r\n  if (min === -1 || min === segments.length) return [];\r\n\r\n  // We may have found the segment that started at an earlier column. If this is the case, then we\r\n  // need to slice all generated segments that match _that_ column, because all such segments span\r\n  // to our desired column.\r\n  const matchedColumn = bsFound ? column : segments[min][COLUMN];\r\n\r\n  // The binary search is not guaranteed to find the lower bound when a match wasn't found.\r\n  if (!bsFound) min = lowerBound(segments, matchedColumn, min);\r\n  const max = upperBound(segments, matchedColumn, min);\r\n\r\n  const result = [];\r\n  for (; min <= max; min++) {\r\n    const segment = segments[min];\r\n    result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction generatedPosition(\r\n  map: TraceMap,\r\n  source: string,\r\n  line: number,\r\n  column: number,\r\n  bias: Bias,\r\n  all: false,\r\n): GeneratedMapping | InvalidGeneratedMapping;\r\nfunction generatedPosition(\r\n  map: TraceMap,\r\n  source: string,\r\n  line: number,\r\n  column: number,\r\n  bias: Bias,\r\n  all: true,\r\n): GeneratedMapping[];\r\nfunction generatedPosition(\r\n  map: TraceMap,\r\n  source: string,\r\n  line: number,\r\n  column: number,\r\n  bias: Bias,\r\n  all: boolean,\r\n): GeneratedMapping | InvalidGeneratedMapping | GeneratedMapping[] {\r\n  line--;\r\n  if (line < 0) throw new Error(LINE_GTR_ZERO);\r\n  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\r\n\r\n  const { sources, resolvedSources } = map;\r\n  let sourceIndex = sources.indexOf(source);\r\n  if (sourceIndex === -1) sourceIndex = resolvedSources.indexOf(source);\r\n  if (sourceIndex === -1) return all ? [] : GMapping(null, null);\r\n\r\n  const generated = (cast(map)._bySources ||= buildBySources(\r\n    decodedMappings(map),\r\n    (cast(map)._bySourceMemos = sources.map(memoizedState)),\r\n  ));\r\n\r\n  const segments = generated[sourceIndex][line];\r\n  if (segments == null) return all ? [] : GMapping(null, null);\r\n\r\n  const memo = cast(map)._bySourceMemos![sourceIndex];\r\n\r\n  if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);\r\n\r\n  const index = traceSegmentInternal(segments, memo, line, column, bias);\r\n  if (index === -1) return GMapping(null, null);\r\n\r\n  const segment = segments[index];\r\n  return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\r\n}\r\n", "import resolveUri from '@jridgewell/resolve-uri';\r\nimport stripFilename from './strip-filename';\r\n\r\ntype Resolve = (source: string | null) => string;\r\nexport default function resolver(\r\n  mapUrl: string | null | undefined,\r\n  sourceRoot: string | undefined,\r\n): Resolve {\r\n  const from = stripFilename(mapUrl);\r\n  // The sourceRoot is always treated as a directory, if it's not empty.\r\n  // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\r\n  // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\r\n  const prefix = sourceRoot ? sourceRoot + '/' : '';\r\n\r\n  return (source) => resolveUri(prefix + (source || ''), from);\r\n}\r\n", "/**\r\n * Removes everything after the last \"/\", but leaves the slash.\r\n */\r\nexport default function stripFilename(path: string | undefined | null): string {\r\n  if (!path) return '';\r\n  const index = path.lastIndexOf('/');\r\n  return path.slice(0, index + 1);\r\n}\r\n", "type GeneratedColumn = number;\r\ntype SourcesIndex = number;\r\ntype SourceLine = number;\r\ntype SourceColumn = number;\r\ntype NamesIndex = number;\r\n\r\ntype GeneratedLine = number;\r\n\r\nexport type SourceMapSegment =\r\n  | [GeneratedColumn]\r\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn]\r\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn, NamesIndex];\r\n\r\nexport type ReverseSegment = [SourceColumn, GeneratedLine, GeneratedColumn];\r\n\r\nexport const COLUMN = 0;\r\nexport const SOURCES_INDEX = 1;\r\nexport const SOURCE_LINE = 2;\r\nexport const SOURCE_COLUMN = 3;\r\nexport const NAMES_INDEX = 4;\r\n\r\nexport const REV_GENERATED_LINE = 1;\r\nexport const REV_GENERATED_COLUMN = 2;\r\n", "import { COLUMN } from './sourcemap-segment';\r\n\r\nimport type { SourceMapSegment } from './sourcemap-segment';\r\n\r\nexport default function maybeSort(\r\n  mappings: SourceMapSegment[][],\r\n  owned: boolean,\r\n): SourceMapSegment[][] {\r\n  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\r\n  if (unsortedIndex === mappings.length) return mappings;\r\n\r\n  // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\r\n  // not, we do not want to modify the consumer's input array.\r\n  if (!owned) mappings = mappings.slice();\r\n\r\n  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\r\n    mappings[i] = sortSegments(mappings[i], owned);\r\n  }\r\n  return mappings;\r\n}\r\n\r\nfunction nextUnsortedSegmentLine(mappings: SourceMapSegment[][], start: number): number {\r\n  for (let i = start; i < mappings.length; i++) {\r\n    if (!isSorted(mappings[i])) return i;\r\n  }\r\n  return mappings.length;\r\n}\r\n\r\nfunction isSorted(line: SourceMapSegment[]): boolean {\r\n  for (let j = 1; j < line.length; j++) {\r\n    if (line[j][COLUMN] < line[j - 1][COLUMN]) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction sortSegments(line: SourceMapSegment[], owned: boolean): SourceMapSegment[] {\r\n  if (!owned) line = line.slice();\r\n  return line.sort(sortComparator);\r\n}\r\n\r\nfunction sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {\r\n  return a[COLUMN] - b[COLUMN];\r\n}\r\n", "import type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';\r\nimport { COLUMN } from './sourcemap-segment';\r\n\r\nexport type MemoState = {\r\n  lastKey: number;\r\n  lastNeedle: number;\r\n  lastIndex: number;\r\n};\r\n\r\nexport let found = false;\r\n\r\n/**\r\n * A binary search implementation that returns the index if a match is found.\r\n * If no match is found, then the left-index (the index associated with the item that comes just\r\n * before the desired index) is returned. To maintain proper sort order, a splice would happen at\r\n * the next index:\r\n *\r\n * ```js\r\n * const array = [1, 3];\r\n * const needle = 2;\r\n * const index = binarySearch(array, needle, (item, needle) => item - needle);\r\n *\r\n * assert.equal(index, 0);\r\n * array.splice(index + 1, 0, needle);\r\n * assert.deepEqual(array, [1, 2, 3]);\r\n * ```\r\n */\r\nexport function binarySearch(\r\n  haystack: SourceMapSegment[] | ReverseSegment[],\r\n  needle: number,\r\n  low: number,\r\n  high: number,\r\n): number {\r\n  while (low <= high) {\r\n    const mid = low + ((high - low) >> 1);\r\n    const cmp = haystack[mid][COLUMN] - needle;\r\n\r\n    if (cmp === 0) {\r\n      found = true;\r\n      return mid;\r\n    }\r\n\r\n    if (cmp < 0) {\r\n      low = mid + 1;\r\n    } else {\r\n      high = mid - 1;\r\n    }\r\n  }\r\n\r\n  found = false;\r\n  return low - 1;\r\n}\r\n\r\nexport function upperBound(\r\n  haystack: SourceMapSegment[] | ReverseSegment[],\r\n  needle: number,\r\n  index: number,\r\n): number {\r\n  for (let i = index + 1; i < haystack.length; index = i++) {\r\n    if (haystack[i][COLUMN] !== needle) break;\r\n  }\r\n  return index;\r\n}\r\n\r\nexport function lowerBound(\r\n  haystack: SourceMapSegment[] | ReverseSegment[],\r\n  needle: number,\r\n  index: number,\r\n): number {\r\n  for (let i = index - 1; i >= 0; index = i--) {\r\n    if (haystack[i][COLUMN] !== needle) break;\r\n  }\r\n  return index;\r\n}\r\n\r\nexport function memoizedState(): MemoState {\r\n  return {\r\n    lastKey: -1,\r\n    lastNeedle: -1,\r\n    lastIndex: -1,\r\n  };\r\n}\r\n\r\n/**\r\n * This overly complicated beast is just to record the last tested line/column and the resulting\r\n * index, allowing us to skip a few tests if mappings are monotonically increasing.\r\n */\r\nexport function memoizedBinarySearch(\r\n  haystack: SourceMapSegment[] | ReverseSegment[],\r\n  needle: number,\r\n  state: MemoState,\r\n  key: number,\r\n): number {\r\n  const { lastKey, lastNeedle, lastIndex } = state;\r\n\r\n  let low = 0;\r\n  let high = haystack.length - 1;\r\n  if (key === lastKey) {\r\n    if (needle === lastNeedle) {\r\n      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\r\n      return lastIndex;\r\n    }\r\n\r\n    if (needle >= lastNeedle) {\r\n      // lastIndex may be -1 if the previous needle was not found.\r\n      low = lastIndex === -1 ? 0 : lastIndex;\r\n    } else {\r\n      high = lastIndex;\r\n    }\r\n  }\r\n  state.lastKey = key;\r\n  state.lastNeedle = needle;\r\n\r\n  return (state.lastIndex = binarySearch(haystack, needle, low, high));\r\n}\r\n", "import { COLUMN, SOURCES_INDEX, SOURCE_LINE, SOURCE_COLUMN } from './sourcemap-segment';\r\nimport { memoizedBinarySearch, upperBound } from './binary-search';\r\n\r\nimport type { ReverseSegment, SourceMapSegment } from './sourcemap-segment';\r\nimport type { MemoState } from './binary-search';\r\n\r\nexport type Source = {\r\n  __proto__: null;\r\n  [line: number]: Exclude<ReverseSegment, [number]>[];\r\n};\r\n\r\n// Rebuilds the original source files, with mappings that are ordered by source line/column instead\r\n// of generated line/column.\r\nexport default function buildBySources(\r\n  decoded: readonly SourceMapSegment[][],\r\n  memos: MemoState[],\r\n): Source[] {\r\n  const sources: Source[] = memos.map(buildNullArray);\r\n\r\n  for (let i = 0; i < decoded.length; i++) {\r\n    const line = decoded[i];\r\n    for (let j = 0; j < line.length; j++) {\r\n      const seg = line[j];\r\n      if (seg.length === 1) continue;\r\n\r\n      const sourceIndex = seg[SOURCES_INDEX];\r\n      const sourceLine = seg[SOURCE_LINE];\r\n      const sourceColumn = seg[SOURCE_COLUMN];\r\n      const originalSource = sources[sourceIndex];\r\n      const originalLine = (originalSource[sourceLine] ||= []);\r\n      const memo = memos[sourceIndex];\r\n\r\n      // The binary search either found a match, or it found the left-index just before where the\r\n      // segment should go. Either way, we want to insert after that. And there may be multiple\r\n      // generated segments associated with an original location, so there may need to move several\r\n      // indexes before we find where we need to insert.\r\n      let index = upperBound(\r\n        originalLine,\r\n        sourceColumn,\r\n        memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine),\r\n      );\r\n\r\n      memo.lastIndex = ++index;\r\n      insert(originalLine, index, [sourceColumn, i, seg[COLUMN]]);\r\n    }\r\n  }\r\n\r\n  return sources;\r\n}\r\n\r\nfunction insert<T>(array: T[], index: number, value: T) {\r\n  for (let i = array.length; i > index; i--) {\r\n    array[i] = array[i - 1];\r\n  }\r\n  array[index] = value;\r\n}\r\n\r\n// Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\r\n// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\r\n// Numeric properties on objects are magically sorted in ascending order by the engine regardless of\r\n// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\r\n// order when iterating with for-in.\r\nfunction buildNullArray<T extends { __proto__: null }>(): T {\r\n  return { __proto__: null } as T;\r\n}\r\n", "import type { SourceMapSegment } from './sourcemap-segment';\r\nimport type { GREATEST_LOWER_BOUND, LEAST_UPPER_BOUND, TraceMap } from './trace-mapping';\r\n\r\nexport interface SourceMapV3 {\r\n  file?: string | null;\r\n  names: string[];\r\n  sourceRoot?: string;\r\n  sources: (string | null)[];\r\n  sourcesContent?: (string | null)[];\r\n  version: 3;\r\n  ignoreList?: number[];\r\n}\r\n\r\nexport interface EncodedSourceMap extends SourceMapV3 {\r\n  mappings: string;\r\n}\r\n\r\nexport interface DecodedSourceMap extends SourceMapV3 {\r\n  mappings: SourceMapSegment[][];\r\n}\r\n\r\nexport interface Section {\r\n  offset: { line: number; column: number };\r\n  map: EncodedSourceMap | DecodedSourceMap | SectionedSourceMap;\r\n}\r\n\r\nexport interface SectionedSourceMap {\r\n  file?: string | null;\r\n  sections: Section[];\r\n  version: 3;\r\n}\r\n\r\nexport type OriginalMapping = {\r\n  source: string | null;\r\n  line: number;\r\n  column: number;\r\n  name: string | null;\r\n};\r\n\r\nexport type InvalidOriginalMapping = {\r\n  source: null;\r\n  line: null;\r\n  column: null;\r\n  name: null;\r\n};\r\n\r\nexport type GeneratedMapping = {\r\n  line: number;\r\n  column: number;\r\n};\r\nexport type InvalidGeneratedMapping = {\r\n  line: null;\r\n  column: null;\r\n};\r\n\r\nexport type Bias = typeof GREATEST_LOWER_BOUND | typeof LEAST_UPPER_BOUND;\r\n\r\nexport type XInput = { x_google_ignoreList?: SourceMapV3['ignoreList'] };\r\nexport type EncodedSourceMapXInput = EncodedSourceMap & XInput;\r\nexport type DecodedSourceMapXInput = DecodedSourceMap & XInput;\r\nexport type SectionedSourceMapXInput = Omit<SectionedSourceMap, 'sections'> & {\r\n  sections: SectionXInput[];\r\n};\r\nexport type SectionXInput = Omit<Section, 'map'> & {\r\n  map: SectionedSourceMapInput;\r\n};\r\n\r\nexport type SourceMapInput = string | EncodedSourceMapXInput | DecodedSourceMapXInput | TraceMap;\r\nexport type SectionedSourceMapInput = SourceMapInput | SectionedSourceMapXInput;\r\n\r\nexport type Needle = { line: number; column: number; bias?: Bias };\r\nexport type SourceNeedle = { source: string; line: number; column: number; bias?: Bias };\r\n\r\nexport type EachMapping =\r\n  | {\r\n      generatedLine: number;\r\n      generatedColumn: number;\r\n      source: null;\r\n      originalLine: null;\r\n      originalColumn: null;\r\n      name: null;\r\n    }\r\n  | {\r\n      generatedLine: number;\r\n      generatedColumn: number;\r\n      source: string | null;\r\n      originalLine: number;\r\n      originalColumn: number;\r\n      name: string | null;\r\n    };\r\n\r\nexport abstract class SourceMap {\r\n  declare version: SourceMapV3['version'];\r\n  declare file: SourceMapV3['file'];\r\n  declare names: SourceMapV3['names'];\r\n  declare sourceRoot: SourceMapV3['sourceRoot'];\r\n  declare sources: SourceMapV3['sources'];\r\n  declare sourcesContent: SourceMapV3['sourcesContent'];\r\n  declare resolvedSources: SourceMapV3['sources'];\r\n  declare ignoreList: SourceMapV3['ignoreList'];\r\n}\r\n\r\nexport type Ro<T> =\r\n  T extends Array<infer V>\r\n    ? V[] | Readonly<V[]> | RoArray<V> | Readonly<RoArray<V>>\r\n    : T extends object\r\n      ? T | Readonly<T> | RoObject<T> | Readonly<RoObject<T>>\r\n      : T;\r\ntype RoArray<T> = Ro<T>[];\r\ntype RoObject<T> = { [K in keyof T]: T[K] | Ro<T[K]> };\r\n\r\nexport function parse<T>(map: T): Exclude<T, string> {\r\n  return typeof map === 'string' ? JSON.parse(map) : (map as Exclude<T, string>);\r\n}\r\n", "import { TraceMap, presortedDecodedMap, decodedMappings } from './trace-mapping';\r\nimport {\r\n  COLUMN,\r\n  SOURCES_INDEX,\r\n  SOURCE_LINE,\r\n  SOURCE_COLUMN,\r\n  NAMES_INDEX,\r\n} from './sourcemap-segment';\r\nimport { parse } from './types';\r\n\r\nimport type {\r\n  DecodedSourceMap,\r\n  DecodedSourceMapXInput,\r\n  EncodedSourceMapXInput,\r\n  SectionedSourceMapXInput,\r\n  SectionedSourceMapInput,\r\n  SectionXInput,\r\n  Ro,\r\n} from './types';\r\nimport type { SourceMapSegment } from './sourcemap-segment';\r\n\r\ntype FlattenMap = {\r\n  new (map: Ro<SectionedSourceMapInput>, mapUrl?: string | null): TraceMap;\r\n  (map: Ro<SectionedSourceMapInput>, mapUrl?: string | null): TraceMap;\r\n};\r\n\r\nexport const FlattenMap: FlattenMap = function (map, mapUrl) {\r\n  const parsed = parse(map as SectionedSourceMapInput);\r\n\r\n  if (!('sections' in parsed)) {\r\n    return new TraceMap(parsed as DecodedSourceMapXInput | EncodedSourceMapXInput, mapUrl);\r\n  }\r\n\r\n  const mappings: SourceMapSegment[][] = [];\r\n  const sources: string[] = [];\r\n  const sourcesContent: (string | null)[] = [];\r\n  const names: string[] = [];\r\n  const ignoreList: number[] = [];\r\n\r\n  recurse(\r\n    parsed,\r\n    mapUrl,\r\n    mappings,\r\n    sources,\r\n    sourcesContent,\r\n    names,\r\n    ignoreList,\r\n    0,\r\n    0,\r\n    Infinity,\r\n    Infinity,\r\n  );\r\n\r\n  const joined: DecodedSourceMap = {\r\n    version: 3,\r\n    file: parsed.file,\r\n    names,\r\n    sources,\r\n    sourcesContent,\r\n    mappings,\r\n    ignoreList,\r\n  };\r\n\r\n  return presortedDecodedMap(joined);\r\n} as FlattenMap;\r\n\r\nfunction recurse(\r\n  input: SectionedSourceMapXInput,\r\n  mapUrl: string | null | undefined,\r\n  mappings: SourceMapSegment[][],\r\n  sources: string[],\r\n  sourcesContent: (string | null)[],\r\n  names: string[],\r\n  ignoreList: number[],\r\n  lineOffset: number,\r\n  columnOffset: number,\r\n  stopLine: number,\r\n  stopColumn: number,\r\n) {\r\n  const { sections } = input;\r\n  for (let i = 0; i < sections.length; i++) {\r\n    const { map, offset } = sections[i];\r\n\r\n    let sl = stopLine;\r\n    let sc = stopColumn;\r\n    if (i + 1 < sections.length) {\r\n      const nextOffset = sections[i + 1].offset;\r\n      sl = Math.min(stopLine, lineOffset + nextOffset.line);\r\n\r\n      if (sl === stopLine) {\r\n        sc = Math.min(stopColumn, columnOffset + nextOffset.column);\r\n      } else if (sl < stopLine) {\r\n        sc = columnOffset + nextOffset.column;\r\n      }\r\n    }\r\n\r\n    addSection(\r\n      map,\r\n      mapUrl,\r\n      mappings,\r\n      sources,\r\n      sourcesContent,\r\n      names,\r\n      ignoreList,\r\n      lineOffset + offset.line,\r\n      columnOffset + offset.column,\r\n      sl,\r\n      sc,\r\n    );\r\n  }\r\n}\r\n\r\nfunction addSection(\r\n  input: SectionXInput['map'],\r\n  mapUrl: string | null | undefined,\r\n  mappings: SourceMapSegment[][],\r\n  sources: string[],\r\n  sourcesContent: (string | null)[],\r\n  names: string[],\r\n  ignoreList: number[],\r\n  lineOffset: number,\r\n  columnOffset: number,\r\n  stopLine: number,\r\n  stopColumn: number,\r\n) {\r\n  const parsed = parse(input);\r\n  if ('sections' in parsed) return recurse(...(arguments as unknown as Parameters<typeof recurse>));\r\n\r\n  const map = new TraceMap(parsed, mapUrl);\r\n  const sourcesOffset = sources.length;\r\n  const namesOffset = names.length;\r\n  const decoded = decodedMappings(map);\r\n  const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;\r\n\r\n  append(sources, resolvedSources);\r\n  append(names, map.names);\r\n\r\n  if (contents) append(sourcesContent, contents);\r\n  else for (let i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);\r\n\r\n  if (ignores) for (let i = 0; i < ignores.length; i++) ignoreList.push(ignores[i] + sourcesOffset);\r\n\r\n  for (let i = 0; i < decoded.length; i++) {\r\n    const lineI = lineOffset + i;\r\n\r\n    // We can only add so many lines before we step into the range that the next section's map\r\n    // controls. When we get to the last line, then we'll start checking the segments to see if\r\n    // they've crossed into the column range. But it may not have any columns that overstep, so we\r\n    // still need to check that we don't overstep lines, too.\r\n    if (lineI > stopLine) return;\r\n\r\n    // The out line may already exist in mappings (if we're continuing the line started by a\r\n    // previous section). Or, we may have jumped ahead several lines to start this section.\r\n    const out = getLine(mappings, lineI);\r\n    // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\r\n    // map can be multiple lines), it doesn't.\r\n    const cOffset = i === 0 ? columnOffset : 0;\r\n\r\n    const line = decoded[i];\r\n    for (let j = 0; j < line.length; j++) {\r\n      const seg = line[j];\r\n      const column = cOffset + seg[COLUMN];\r\n\r\n      // If this segment steps into the column range that the next section's map controls, we need\r\n      // to stop early.\r\n      if (lineI === stopLine && column >= stopColumn) return;\r\n\r\n      if (seg.length === 1) {\r\n        out.push([column]);\r\n        continue;\r\n      }\r\n\r\n      const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\r\n      const sourceLine = seg[SOURCE_LINE];\r\n      const sourceColumn = seg[SOURCE_COLUMN];\r\n      out.push(\r\n        seg.length === 4\r\n          ? [column, sourcesIndex, sourceLine, sourceColumn]\r\n          : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]],\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction append<T>(arr: T[], other: T[]) {\r\n  for (let i = 0; i < other.length; i++) arr.push(other[i]);\r\n}\r\n\r\nfunction getLine<T>(arr: T[][], index: number): T[] {\r\n  for (let i = arr.length; i <= index; i++) arr[i] = [];\r\n  return arr[index];\r\n}\r\n", null, null, "import { SetArray, put, remove } from './set-array';\r\nimport {\r\n  encode,\r\n  // encodeGeneratedRanges,\r\n  // encodeOriginalScopes\r\n} from '@jridgewell/sourcemap-codec';\r\nimport { TraceMap, decodedMappings } from '@jridgewell/trace-mapping';\r\n\r\nimport {\r\n  COLUMN,\r\n  SOURCES_INDEX,\r\n  SOURCE_LINE,\r\n  SOURCE_COLUMN,\r\n  NAMES_INDEX,\r\n} from './sourcemap-segment';\r\n\r\nimport type { SourceMapInput } from '@jridgewell/trace-mapping';\r\n// import type { OriginalScope, GeneratedRange } from '@jridgewell/sourcemap-codec';\r\nimport type { SourceMapSegment } from './sourcemap-segment';\r\nimport type {\r\n  DecodedSourceMap,\r\n  EncodedSourceMap,\r\n  Pos,\r\n  Mapping,\r\n  // BindingExpressionRange,\r\n  // OriginalPos,\r\n  // OriginalScopeInfo,\r\n  // GeneratedRangeInfo,\r\n} from './types';\r\n\r\nexport type { DecodedSourceMap, EncodedSourceMap, Mapping };\r\n\r\nexport type Options = {\r\n  file?: string | null;\r\n  sourceRoot?: string | null;\r\n};\r\n\r\nconst NO_NAME = -1;\r\n\r\n/**\r\n * Provides the state to generate a sourcemap.\r\n */\r\nexport class GenMapping {\r\n  declare private _names: SetArray<string>;\r\n  declare private _sources: SetArray<string>;\r\n  declare private _sourcesContent: (string | null)[];\r\n  declare private _mappings: SourceMapSegment[][];\r\n  // private declare _originalScopes: OriginalScope[][];\r\n  // private declare _generatedRanges: GeneratedRange[];\r\n  declare private _ignoreList: SetArray<number>;\r\n  declare file: string | null | undefined;\r\n  declare sourceRoot: string | null | undefined;\r\n\r\n  constructor({ file, sourceRoot }: Options = {}) {\r\n    this._names = new SetArray();\r\n    this._sources = new SetArray();\r\n    this._sourcesContent = [];\r\n    this._mappings = [];\r\n    // this._originalScopes = [];\r\n    // this._generatedRanges = [];\r\n    this.file = file;\r\n    this.sourceRoot = sourceRoot;\r\n    this._ignoreList = new SetArray();\r\n  }\r\n}\r\n\r\ninterface PublicMap {\r\n  _names: GenMapping['_names'];\r\n  _sources: GenMapping['_sources'];\r\n  _sourcesContent: GenMapping['_sourcesContent'];\r\n  _mappings: GenMapping['_mappings'];\r\n  // _originalScopes: GenMapping['_originalScopes'];\r\n  // _generatedRanges: GenMapping['_generatedRanges'];\r\n  _ignoreList: GenMapping['_ignoreList'];\r\n}\r\n\r\n/**\r\n * Typescript doesn't allow friend access to private fields, so this just casts the map into a type\r\n * with public access modifiers.\r\n */\r\nfunction cast(map: unknown): PublicMap {\r\n  return map as any;\r\n}\r\n\r\n/**\r\n * A low-level API to associate a generated position with an original source position. Line and\r\n * column here are 0-based, unlike `addMapping`.\r\n */\r\nexport function addSegment(\r\n  map: GenMapping,\r\n  genLine: number,\r\n  genColumn: number,\r\n  source?: null,\r\n  sourceLine?: null,\r\n  sourceColumn?: null,\r\n  name?: null,\r\n  content?: null,\r\n): void;\r\nexport function addSegment(\r\n  map: GenMapping,\r\n  genLine: number,\r\n  genColumn: number,\r\n  source: string,\r\n  sourceLine: number,\r\n  sourceColumn: number,\r\n  name?: null,\r\n  content?: string | null,\r\n): void;\r\nexport function addSegment(\r\n  map: GenMapping,\r\n  genLine: number,\r\n  genColumn: number,\r\n  source: string,\r\n  sourceLine: number,\r\n  sourceColumn: number,\r\n  name: string,\r\n  content?: string | null,\r\n): void;\r\nexport function addSegment(\r\n  map: GenMapping,\r\n  genLine: number,\r\n  genColumn: number,\r\n  source?: string | null,\r\n  sourceLine?: number | null,\r\n  sourceColumn?: number | null,\r\n  name?: string | null,\r\n  content?: string | null,\r\n): void {\r\n  return addSegmentInternal(\r\n    false,\r\n    map,\r\n    genLine,\r\n    genColumn,\r\n    source,\r\n    sourceLine,\r\n    sourceColumn,\r\n    name,\r\n    content,\r\n  );\r\n}\r\n\r\n/**\r\n * A high-level API to associate a generated position with an original source position. Line is\r\n * 1-based, but column is 0-based, due to legacy behavior in `source-map` library.\r\n */\r\nexport function addMapping(\r\n  map: GenMapping,\r\n  mapping: {\r\n    generated: Pos;\r\n    source?: null;\r\n    original?: null;\r\n    name?: null;\r\n    content?: null;\r\n  },\r\n): void;\r\nexport function addMapping(\r\n  map: GenMapping,\r\n  mapping: {\r\n    generated: Pos;\r\n    source: string;\r\n    original: Pos;\r\n    name?: null;\r\n    content?: string | null;\r\n  },\r\n): void;\r\nexport function addMapping(\r\n  map: GenMapping,\r\n  mapping: {\r\n    generated: Pos;\r\n    source: string;\r\n    original: Pos;\r\n    name: string;\r\n    content?: string | null;\r\n  },\r\n): void;\r\nexport function addMapping(\r\n  map: GenMapping,\r\n  mapping: {\r\n    generated: Pos;\r\n    source?: string | null;\r\n    original?: Pos | null;\r\n    name?: string | null;\r\n    content?: string | null;\r\n  },\r\n): void {\r\n  return addMappingInternal(false, map, mapping as Parameters<typeof addMappingInternal>[2]);\r\n}\r\n\r\n/**\r\n * Same as `addSegment`, but will only add the segment if it generates useful information in the\r\n * resulting map. This only works correctly if segments are added **in order**, meaning you should\r\n * not add a segment with a lower generated line/column than one that came before.\r\n */\r\nexport const maybeAddSegment: typeof addSegment = (\r\n  map,\r\n  genLine,\r\n  genColumn,\r\n  source,\r\n  sourceLine,\r\n  sourceColumn,\r\n  name,\r\n  content,\r\n) => {\r\n  return addSegmentInternal(\r\n    true,\r\n    map,\r\n    genLine,\r\n    genColumn,\r\n    source,\r\n    sourceLine,\r\n    sourceColumn,\r\n    name,\r\n    content,\r\n  );\r\n};\r\n\r\n/**\r\n * Same as `addMapping`, but will only add the mapping if it generates useful information in the\r\n * resulting map. This only works correctly if mappings are added **in order**, meaning you should\r\n * not add a mapping with a lower generated line/column than one that came before.\r\n */\r\nexport const maybeAddMapping: typeof addMapping = (map, mapping) => {\r\n  return addMappingInternal(true, map, mapping as Parameters<typeof addMappingInternal>[2]);\r\n};\r\n\r\n/**\r\n * Adds/removes the content of the source file to the source map.\r\n */\r\nexport function setSourceContent(map: GenMapping, source: string, content: string | null): void {\r\n  const {\r\n    _sources: sources,\r\n    _sourcesContent: sourcesContent,\r\n    // _originalScopes: originalScopes,\r\n  } = cast(map);\r\n  const index = put(sources, source);\r\n  sourcesContent[index] = content;\r\n  // if (index === originalScopes.length) originalScopes[index] = [];\r\n}\r\n\r\nexport function setIgnore(map: GenMapping, source: string, ignore = true) {\r\n  const {\r\n    _sources: sources,\r\n    _sourcesContent: sourcesContent,\r\n    _ignoreList: ignoreList,\r\n    // _originalScopes: originalScopes,\r\n  } = cast(map);\r\n  const index = put(sources, source);\r\n  if (index === sourcesContent.length) sourcesContent[index] = null;\r\n  // if (index === originalScopes.length) originalScopes[index] = [];\r\n  if (ignore) put(ignoreList, index);\r\n  else remove(ignoreList, index);\r\n}\r\n\r\n/**\r\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\r\n * a sourcemap, or to JSON.stringify.\r\n */\r\nexport function toDecodedMap(map: GenMapping): DecodedSourceMap {\r\n  const {\r\n    _mappings: mappings,\r\n    _sources: sources,\r\n    _sourcesContent: sourcesContent,\r\n    _names: names,\r\n    _ignoreList: ignoreList,\r\n    // _originalScopes: originalScopes,\r\n    // _generatedRanges: generatedRanges,\r\n  } = cast(map);\r\n  removeEmptyFinalLines(mappings);\r\n\r\n  return {\r\n    version: 3,\r\n    file: map.file || undefined,\r\n    names: names.array,\r\n    sourceRoot: map.sourceRoot || undefined,\r\n    sources: sources.array,\r\n    sourcesContent,\r\n    mappings,\r\n    // originalScopes,\r\n    // generatedRanges,\r\n    ignoreList: ignoreList.array,\r\n  };\r\n}\r\n\r\n/**\r\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\r\n * a sourcemap, or to JSON.stringify.\r\n */\r\nexport function toEncodedMap(map: GenMapping): EncodedSourceMap {\r\n  const decoded = toDecodedMap(map);\r\n  return Object.assign({}, decoded, {\r\n    // originalScopes: decoded.originalScopes.map((os) => encodeOriginalScopes(os)),\r\n    // generatedRanges: encodeGeneratedRanges(decoded.generatedRanges as GeneratedRange[]),\r\n    mappings: encode(decoded.mappings as SourceMapSegment[][]),\r\n  });\r\n}\r\n\r\n/**\r\n * Constructs a new GenMapping, using the already present mappings of the input.\r\n */\r\nexport function fromMap(input: SourceMapInput): GenMapping {\r\n  const map = new TraceMap(input);\r\n  const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });\r\n\r\n  putAll(cast(gen)._names, map.names);\r\n  putAll(cast(gen)._sources, map.sources as string[]);\r\n  cast(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);\r\n  cast(gen)._mappings = decodedMappings(map) as GenMapping['_mappings'];\r\n  // TODO: implement originalScopes/generatedRanges\r\n  if (map.ignoreList) putAll(cast(gen)._ignoreList, map.ignoreList);\r\n\r\n  return gen;\r\n}\r\n\r\n/**\r\n * Returns an array of high-level mapping objects for every recorded segment, which could then be\r\n * passed to the `source-map` library.\r\n */\r\nexport function allMappings(map: GenMapping): Mapping[] {\r\n  const out: Mapping[] = [];\r\n  const { _mappings: mappings, _sources: sources, _names: names } = cast(map);\r\n\r\n  for (let i = 0; i < mappings.length; i++) {\r\n    const line = mappings[i];\r\n    for (let j = 0; j < line.length; j++) {\r\n      const seg = line[j];\r\n\r\n      const generated = { line: i + 1, column: seg[COLUMN] };\r\n      let source: string | undefined = undefined;\r\n      let original: Pos | undefined = undefined;\r\n      let name: string | undefined = undefined;\r\n\r\n      if (seg.length !== 1) {\r\n        source = sources.array[seg[SOURCES_INDEX]];\r\n        original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };\r\n\r\n        if (seg.length === 5) name = names.array[seg[NAMES_INDEX]];\r\n      }\r\n\r\n      out.push({ generated, source, original, name } as Mapping);\r\n    }\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n// This split declaration is only so that terser can elminiate the static initialization block.\r\nfunction addSegmentInternal<S extends string | null | undefined>(\r\n  skipable: boolean,\r\n  map: GenMapping,\r\n  genLine: number,\r\n  genColumn: number,\r\n  source: S,\r\n  sourceLine: S extends string ? number : null | undefined,\r\n  sourceColumn: S extends string ? number : null | undefined,\r\n  name: S extends string ? string | null | undefined : null | undefined,\r\n  content: S extends string ? string | null | undefined : null | undefined,\r\n): void {\r\n  const {\r\n    _mappings: mappings,\r\n    _sources: sources,\r\n    _sourcesContent: sourcesContent,\r\n    _names: names,\r\n    // _originalScopes: originalScopes,\r\n  } = cast(map);\r\n  const line = getIndex(mappings, genLine);\r\n  const index = getColumnIndex(line, genColumn);\r\n\r\n  if (!source) {\r\n    if (skipable && skipSourceless(line, index)) return;\r\n    return insert(line, index, [genColumn]);\r\n  }\r\n\r\n  // Sigh, TypeScript can't figure out sourceLine and sourceColumn aren't nullish if source\r\n  // isn't nullish.\r\n  assert<number>(sourceLine);\r\n  assert<number>(sourceColumn);\r\n\r\n  const sourcesIndex = put(sources, source);\r\n  const namesIndex = name ? put(names, name) : NO_NAME;\r\n  if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content ?? null;\r\n  // if (sourcesIndex === originalScopes.length) originalScopes[sourcesIndex] = [];\r\n\r\n  if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {\r\n    return;\r\n  }\r\n\r\n  return insert(\r\n    line,\r\n    index,\r\n    name\r\n      ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]\r\n      : [genColumn, sourcesIndex, sourceLine, sourceColumn],\r\n  );\r\n}\r\n\r\nfunction assert<T>(_val: unknown): asserts _val is T {\r\n  // noop.\r\n}\r\n\r\nfunction getIndex<T>(arr: T[][], index: number): T[] {\r\n  for (let i = arr.length; i <= index; i++) {\r\n    arr[i] = [];\r\n  }\r\n  return arr[index];\r\n}\r\n\r\nfunction getColumnIndex(line: SourceMapSegment[], genColumn: number): number {\r\n  let index = line.length;\r\n  for (let i = index - 1; i >= 0; index = i--) {\r\n    const current = line[i];\r\n    if (genColumn >= current[COLUMN]) break;\r\n  }\r\n  return index;\r\n}\r\n\r\nfunction insert<T>(array: T[], index: number, value: T) {\r\n  for (let i = array.length; i > index; i--) {\r\n    array[i] = array[i - 1];\r\n  }\r\n  array[index] = value;\r\n}\r\n\r\nfunction removeEmptyFinalLines(mappings: SourceMapSegment[][]) {\r\n  const { length } = mappings;\r\n  let len = length;\r\n  for (let i = len - 1; i >= 0; len = i, i--) {\r\n    if (mappings[i].length > 0) break;\r\n  }\r\n  if (len < length) mappings.length = len;\r\n}\r\n\r\nfunction putAll<T extends string | number>(setarr: SetArray<T>, array: T[]) {\r\n  for (let i = 0; i < array.length; i++) put(setarr, array[i]);\r\n}\r\n\r\nfunction skipSourceless(line: SourceMapSegment[], index: number): boolean {\r\n  // The start of a line is already sourceless, so adding a sourceless segment to the beginning\r\n  // doesn't generate any useful information.\r\n  if (index === 0) return true;\r\n\r\n  const prev = line[index - 1];\r\n  // If the previous segment is also sourceless, then adding another sourceless segment doesn't\r\n  // genrate any new information. Else, this segment will end the source/named segment and point to\r\n  // a sourceless position, which is useful.\r\n  return prev.length === 1;\r\n}\r\n\r\nfunction skipSource(\r\n  line: SourceMapSegment[],\r\n  index: number,\r\n  sourcesIndex: number,\r\n  sourceLine: number,\r\n  sourceColumn: number,\r\n  namesIndex: number,\r\n): boolean {\r\n  // A source/named segment at the start of a line gives position at that genColumn\r\n  if (index === 0) return false;\r\n\r\n  const prev = line[index - 1];\r\n\r\n  // If the previous segment is sourceless, then we're transitioning to a source.\r\n  if (prev.length === 1) return false;\r\n\r\n  // If the previous segment maps to the exact same source position, then this segment doesn't\r\n  // provide any new position information.\r\n  return (\r\n    sourcesIndex === prev[SOURCES_INDEX] &&\r\n    sourceLine === prev[SOURCE_LINE] &&\r\n    sourceColumn === prev[SOURCE_COLUMN] &&\r\n    namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME)\r\n  );\r\n}\r\n\r\nfunction addMappingInternal<S extends string | null | undefined>(\r\n  skipable: boolean,\r\n  map: GenMapping,\r\n  mapping: {\r\n    generated: Pos;\r\n    source: S;\r\n    original: S extends string ? Pos : null | undefined;\r\n    name: S extends string ? string | null | undefined : null | undefined;\r\n    content: S extends string ? string | null | undefined : null | undefined;\r\n  },\r\n) {\r\n  const { generated, source, original, name, content } = mapping;\r\n  if (!source) {\r\n    return addSegmentInternal(\r\n      skipable,\r\n      map,\r\n      generated.line - 1,\r\n      generated.column,\r\n      null,\r\n      null,\r\n      null,\r\n      null,\r\n      null,\r\n    );\r\n  }\r\n  assert<Pos>(original);\r\n  return addSegmentInternal(\r\n    skipable,\r\n    map,\r\n    generated.line - 1,\r\n    generated.column,\r\n    source as string,\r\n    original.line - 1,\r\n    original.column,\r\n    name,\r\n    content,\r\n  );\r\n}\r\n\r\n/*\r\nexport function addOriginalScope(\r\n  map: GenMapping,\r\n  data: {\r\n    start: Pos;\r\n    end: Pos;\r\n    source: string;\r\n    kind: string;\r\n    name?: string;\r\n    variables?: string[];\r\n  },\r\n): OriginalScopeInfo {\r\n  const { start, end, source, kind, name, variables } = data;\r\n  const {\r\n    _sources: sources,\r\n    _sourcesContent: sourcesContent,\r\n    _originalScopes: originalScopes,\r\n    _names: names,\r\n  } = cast(map);\r\n  const index = put(sources, source);\r\n  if (index === sourcesContent.length) sourcesContent[index] = null;\r\n  if (index === originalScopes.length) originalScopes[index] = [];\r\n\r\n  const kindIndex = put(names, kind);\r\n  const scope: OriginalScope = name\r\n    ? [start.line - 1, start.column, end.line - 1, end.column, kindIndex, put(names, name)]\r\n    : [start.line - 1, start.column, end.line - 1, end.column, kindIndex];\r\n  if (variables) {\r\n    scope.vars = variables.map((v) => put(names, v));\r\n  }\r\n  const len = originalScopes[index].push(scope);\r\n  return [index, len - 1, variables];\r\n}\r\n*/\r\n\r\n// Generated Ranges\r\n/*\r\nexport function addGeneratedRange(\r\n  map: GenMapping,\r\n  data: {\r\n    start: Pos;\r\n    isScope: boolean;\r\n    originalScope?: OriginalScopeInfo;\r\n    callsite?: OriginalPos;\r\n  },\r\n): GeneratedRangeInfo {\r\n  const { start, isScope, originalScope, callsite } = data;\r\n  const {\r\n    _originalScopes: originalScopes,\r\n    _sources: sources,\r\n    _sourcesContent: sourcesContent,\r\n    _generatedRanges: generatedRanges,\r\n  } = cast(map);\r\n\r\n  const range: GeneratedRange = [\r\n    start.line - 1,\r\n    start.column,\r\n    0,\r\n    0,\r\n    originalScope ? originalScope[0] : -1,\r\n    originalScope ? originalScope[1] : -1,\r\n  ];\r\n  if (originalScope?.[2]) {\r\n    range.bindings = originalScope[2].map(() => [[-1]]);\r\n  }\r\n  if (callsite) {\r\n    const index = put(sources, callsite.source);\r\n    if (index === sourcesContent.length) sourcesContent[index] = null;\r\n    if (index === originalScopes.length) originalScopes[index] = [];\r\n    range.callsite = [index, callsite.line - 1, callsite.column];\r\n  }\r\n  if (isScope) range.isScope = true;\r\n  generatedRanges.push(range);\r\n\r\n  return [range, originalScope?.[2]];\r\n}\r\n\r\nexport function setEndPosition(range: GeneratedRangeInfo, pos: Pos) {\r\n  range[0][2] = pos.line - 1;\r\n  range[0][3] = pos.column;\r\n}\r\n\r\nexport function addBinding(\r\n  map: GenMapping,\r\n  range: GeneratedRangeInfo,\r\n  variable: string,\r\n  expression: string | BindingExpressionRange,\r\n) {\r\n  const { _names: names } = cast(map);\r\n  const bindings = (range[0].bindings ||= []);\r\n  const vars = range[1];\r\n\r\n  const index = vars!.indexOf(variable);\r\n  const binding = getIndex(bindings, index);\r\n\r\n  if (typeof expression === 'string') binding[0] = [put(names, expression)];\r\n  else {\r\n    const { start } = expression;\r\n    binding.push([put(names, expression.expression), start.line - 1, start.column]);\r\n  }\r\n}\r\n*/\r\n", "type Key = string | number | symbol;\r\n\r\n/**\r\n * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the\r\n * index of the `key` in the backing array.\r\n *\r\n * This is designed to allow synchronizing a second array with the contents of the backing array,\r\n * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,\r\n * and there are never duplicates.\r\n */\r\nexport class SetArray<T extends Key = Key> {\r\n  declare private _indexes: Record<T, number | undefined>;\r\n  declare array: readonly T[];\r\n\r\n  constructor() {\r\n    this._indexes = { __proto__: null } as any;\r\n    this.array = [];\r\n  }\r\n}\r\n\r\ninterface PublicSet<T extends Key> {\r\n  array: T[];\r\n  _indexes: SetArray<T>['_indexes'];\r\n}\r\n\r\n/**\r\n * Typescript doesn't allow friend access to private fields, so this just casts the set into a type\r\n * with public access modifiers.\r\n */\r\nfunction cast<T extends Key>(set: SetArray<T>): PublicSet<T> {\r\n  return set as any;\r\n}\r\n\r\n/**\r\n * Gets the index associated with `key` in the backing array, if it is already present.\r\n */\r\nexport function get<T extends Key>(setarr: SetArray<T>, key: T): number | undefined {\r\n  return cast(setarr)._indexes[key];\r\n}\r\n\r\n/**\r\n * Puts `key` into the backing array, if it is not already present. Returns\r\n * the index of the `key` in the backing array.\r\n */\r\nexport function put<T extends Key>(setarr: SetArray<T>, key: T): number {\r\n  // The key may or may not be present. If it is present, it's a number.\r\n  const index = get(setarr, key);\r\n  if (index !== undefined) return index;\r\n\r\n  const { array, _indexes: indexes } = cast(setarr);\r\n\r\n  const length = array.push(key);\r\n  return (indexes[key] = length - 1);\r\n}\r\n\r\n/**\r\n * Pops the last added item out of the SetArray.\r\n */\r\nexport function pop<T extends Key>(setarr: SetArray<T>): void {\r\n  const { array, _indexes: indexes } = cast(setarr);\r\n  if (array.length === 0) return;\r\n\r\n  const last = array.pop()!;\r\n  indexes[last] = undefined;\r\n}\r\n\r\n/**\r\n * Removes the key, if it exists in the set.\r\n */\r\nexport function remove<T extends Key>(setarr: SetArray<T>, key: T): void {\r\n  const index = get(setarr, key);\r\n  if (index === undefined) return;\r\n\r\n  const { array, _indexes: indexes } = cast(setarr);\r\n  for (let i = index + 1; i < array.length; i++) {\r\n    const k = array[i];\r\n    array[i - 1] = k;\r\n    indexes[k]!--;\r\n  }\r\n  indexes[key] = undefined;\r\n  array.pop();\r\n}\r\n", "type GeneratedColumn = number;\r\ntype SourcesIndex = number;\r\ntype SourceLine = number;\r\ntype SourceColumn = number;\r\ntype NamesIndex = number;\r\n\r\nexport type SourceMapSegment =\r\n  | [GeneratedColumn]\r\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn]\r\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn, NamesIndex];\r\n\r\nexport const COLUMN = 0;\r\nexport const SOURCES_INDEX = 1;\r\nexport const SOURCE_LINE = 2;\r\nexport const SOURCE_COLUMN = 3;\r\nexport const NAMES_INDEX = 4;\r\n", "import { GenMapping, maybeAddSegment, setIgnore, setSourceContent } from '@jridgewell/gen-mapping';\nimport { traceSegment, decodedMappings } from '@jridgewell/trace-mapping';\n\nimport type { TraceMap } from '@jridgewell/trace-mapping';\n\nexport type SourceMapSegmentObject = {\n  column: number;\n  line: number;\n  name: string;\n  source: string;\n  content: string | null;\n  ignore: boolean;\n};\n\nexport type OriginalSource = {\n  map: null;\n  sources: Sources[];\n  source: string;\n  content: string | null;\n  ignore: boolean;\n};\n\nexport type MapSource = {\n  map: TraceMap;\n  sources: Sources[];\n  source: string;\n  content: null;\n  ignore: false;\n};\n\nexport type Sources = OriginalSource | MapSource;\n\nconst SOURCELESS_MAPPING = /* #__PURE__ */ SegmentObject('', -1, -1, '', null, false);\nconst EMPTY_SOURCES: Sources[] = [];\n\nfunction SegmentObject(\n  source: string,\n  line: number,\n  column: number,\n  name: string,\n  content: string | null,\n  ignore: boolean\n): SourceMapSegmentObject {\n  return { source, line, column, name, content, ignore };\n}\n\nfunction Source(\n  map: TraceMap,\n  sources: Sources[],\n  source: '',\n  content: null,\n  ignore: false\n): MapSource;\nfunction Source(\n  map: null,\n  sources: Sources[],\n  source: string,\n  content: string | null,\n  ignore: boolean\n): OriginalSource;\nfunction Source(\n  map: TraceMap | null,\n  sources: Sources[],\n  source: string | '',\n  content: string | null,\n  ignore: boolean\n): Sources {\n  return {\n    map,\n    sources,\n    source,\n    content,\n    ignore,\n  } as any;\n}\n\n/**\n * MapSource represents a single sourcemap, with the ability to trace mappings into its child nodes\n * (which may themselves be SourceMapTrees).\n */\nexport function MapSource(map: TraceMap, sources: Sources[]): MapSource {\n  return Source(map, sources, '', null, false);\n}\n\n/**\n * A \"leaf\" node in the sourcemap tree, representing an original, unmodified source file. Recursive\n * segment tracing ends at the `OriginalSource`.\n */\nexport function OriginalSource(\n  source: string,\n  content: string | null,\n  ignore: boolean\n): OriginalSource {\n  return Source(null, EMPTY_SOURCES, source, content, ignore);\n}\n\n/**\n * traceMappings is only called on the root level SourceMapTree, and begins the process of\n * resolving each mapping in terms of the original source files.\n */\nexport function traceMappings(tree: MapSource): GenMapping {\n  // TODO: Eventually support sourceRoot, which has to be removed because the sources are already\n  // fully resolved. We'll need to make sources relative to the sourceRoot before adding them.\n  const gen = new GenMapping({ file: tree.map.file });\n  const { sources: rootSources, map } = tree;\n  const rootNames = map.names;\n  const rootMappings = decodedMappings(map);\n\n  for (let i = 0; i < rootMappings.length; i++) {\n    const segments = rootMappings[i];\n\n    for (let j = 0; j < segments.length; j++) {\n      const segment = segments[j];\n      const genCol = segment[0];\n      let traced: SourceMapSegmentObject | null = SOURCELESS_MAPPING;\n\n      // 1-length segments only move the current generated column, there's no source information\n      // to gather from it.\n      if (segment.length !== 1) {\n        const source = rootSources[segment[1]];\n        traced = originalPositionFor(\n          source,\n          segment[2],\n          segment[3],\n          segment.length === 5 ? rootNames[segment[4]] : ''\n        );\n\n        // If the trace is invalid, then the trace ran into a sourcemap that doesn't contain a\n        // respective segment into an original source.\n        if (traced == null) continue;\n      }\n\n      const { column, line, name, content, source, ignore } = traced;\n\n      maybeAddSegment(gen, i, genCol, source, line, column, name);\n      if (source && content != null) setSourceContent(gen, source, content);\n      if (ignore) setIgnore(gen, source, true);\n    }\n  }\n\n  return gen;\n}\n\n/**\n * originalPositionFor is only called on children SourceMapTrees. It recurses down into its own\n * child SourceMapTrees, until we find the original source map.\n */\nexport function originalPositionFor(\n  source: Sources,\n  line: number,\n  column: number,\n  name: string\n): SourceMapSegmentObject | null {\n  if (!source.map) {\n    return SegmentObject(source.source, line, column, name, source.content, source.ignore);\n  }\n\n  const segment = traceSegment(source.map, line, column);\n\n  // If we couldn't find a segment, then this doesn't exist in the sourcemap.\n  if (segment == null) return null;\n  // 1-length segments only move the current generated column, there's no source information\n  // to gather from it.\n  if (segment.length === 1) return SOURCELESS_MAPPING;\n\n  return originalPositionFor(\n    source.sources[segment[1]],\n    segment[2],\n    segment[3],\n    segment.length === 5 ? source.map.names[segment[4]] : name\n  );\n}\n", "import { TraceMap } from '@jridgewell/trace-mapping';\n\nimport { OriginalSource, MapSource } from './source-map-tree';\n\nimport type { Sources, MapSource as MapSourceType } from './source-map-tree';\nimport type { SourceMapInput, SourceMapLoader, LoaderContext } from './types';\n\nfunction asArray<T>(value: T | T[]): T[] {\n  if (Array.isArray(value)) return value;\n  return [value];\n}\n\n/**\n * Recursively builds a tree structure out of sourcemap files, with each node\n * being either an `OriginalSource` \"leaf\" or a `SourceMapTree` composed of\n * `OriginalSource`s and `SourceMapTree`s.\n *\n * Every sourcemap is composed of a collection of source files and mappings\n * into locations of those source files. When we generate a `SourceMapTree` for\n * the sourcemap, we attempt to load each source file's own sourcemap. If it\n * does not have an associated sourcemap, it is considered an original,\n * unmodified source file.\n */\nexport default function buildSourceMapTree(\n  input: SourceMapInput | SourceMapInput[],\n  loader: SourceMapLoader\n): MapSourceType {\n  const maps = asArray(input).map((m) => new TraceMap(m, ''));\n  const map = maps.pop()!;\n\n  for (let i = 0; i < maps.length; i++) {\n    if (maps[i].sources.length > 1) {\n      throw new Error(\n        `Transformation map ${i} must have exactly one source file.\\n` +\n          'Did you specify these with the most recent transformation maps first?'\n      );\n    }\n  }\n\n  let tree = build(map, loader, '', 0);\n  for (let i = maps.length - 1; i >= 0; i--) {\n    tree = MapSource(maps[i], [tree]);\n  }\n  return tree;\n}\n\nfunction build(\n  map: TraceMap,\n  loader: SourceMapLoader,\n  importer: string,\n  importerDepth: number\n): MapSourceType {\n  const { resolvedSources, sourcesContent, ignoreList } = map;\n\n  const depth = importerDepth + 1;\n  const children = resolvedSources.map((sourceFile: string | null, i: number): Sources => {\n    // The loading context gives the loader more information about why this file is being loaded\n    // (eg, from which importer). It also allows the loader to override the location of the loaded\n    // sourcemap/original source, or to override the content in the sourcesContent field if it's\n    // an unmodified source file.\n    const ctx: LoaderContext = {\n      importer,\n      depth,\n      source: sourceFile || '',\n      content: undefined,\n      ignore: undefined,\n    };\n\n    // Use the provided loader callback to retrieve the file's sourcemap.\n    // TODO: We should eventually support async loading of sourcemap files.\n    const sourceMap = loader(ctx.source, ctx);\n\n    const { source, content, ignore } = ctx;\n\n    // If there is a sourcemap, then we need to recurse into it to load its source files.\n    if (sourceMap) return build(new TraceMap(sourceMap, source), loader, source, depth);\n\n    // Else, it's an unmodified source file.\n    // The contents of this unmodified source file can be overridden via the loader context,\n    // allowing it to be explicitly null or a string. If it remains undefined, we fall back to\n    // the importing sourcemap's `sourcesContent` field.\n    const sourceContent =\n      content !== undefined ? content : sourcesContent ? sourcesContent[i] : null;\n    const ignored = ignore !== undefined ? ignore : ignoreList ? ignoreList.includes(i) : false;\n    return OriginalSource(source, sourceContent, ignored);\n  });\n\n  return MapSource(map, children);\n}\n", "import { toDecodedMap, toEncodedMap } from '@jridgewell/gen-mapping';\n\nimport type { GenMapping } from '@jridgewell/gen-mapping';\nimport type { DecodedSourceMap, EncodedSourceMap, Options } from './types';\n\n/**\n * A SourceMap v3 compatible sourcemap, which only includes fields that were\n * provided to it.\n */\nexport default class SourceMap {\n  declare file?: string | null;\n  declare mappings: EncodedSourceMap['mappings'] | DecodedSourceMap['mappings'];\n  declare sourceRoot?: string;\n  declare names: string[];\n  declare sources: (string | null)[];\n  declare sourcesContent?: (string | null)[];\n  declare version: 3;\n  declare ignoreList: number[] | undefined;\n\n  constructor(map: GenMapping, options: Options) {\n    const out = options.decodedMappings ? toDecodedMap(map) : toEncodedMap(map);\n    this.version = out.version; // SourceMap spec says this should be first.\n    this.file = out.file;\n    this.mappings = out.mappings as SourceMap['mappings'];\n    this.names = out.names as SourceMap['names'];\n    this.ignoreList = out.ignoreList as SourceMap['ignoreList'];\n    this.sourceRoot = out.sourceRoot;\n\n    this.sources = out.sources as SourceMap['sources'];\n    if (!options.excludeContent) {\n      this.sourcesContent = out.sourcesContent as SourceMap['sourcesContent'];\n    }\n  }\n\n  toString(): string {\n    return JSON.stringify(this);\n  }\n}\n", "import buildSourceMapTree from './build-source-map-tree';\nimport { traceMappings } from './source-map-tree';\nimport SourceMap from './source-map';\n\nimport type { SourceMapInput, SourceMapLoader, Options } from './types';\nexport type {\n  SourceMapSegment,\n  EncodedSourceMap,\n  EncodedSourceMap as RawSourceMap,\n  DecodedSourceMap,\n  SourceMapInput,\n  SourceMapLoader,\n  LoaderContext,\n  Options,\n} from './types';\nexport type { SourceMap };\n\n/**\n * Traces through all the mappings in the root sourcemap, through the sources\n * (and their sourcemaps), all the way back to the original source location.\n *\n * `loader` will be called every time we encounter a source file. If it returns\n * a sourcemap, we will recurse into that sourcemap to continue the trace. If\n * it returns a falsey value, that source file is treated as an original,\n * unmodified source file.\n *\n * Pass `excludeContent` to exclude any self-containing source file content\n * from the output sourcemap.\n *\n * Pass `decodedMappings` to receive a SourceMap with decoded (instead of\n * VLQ encoded) mappings.\n */\nexport default function remapping(\n  input: SourceMapInput | SourceMapInput[],\n  loader: SourceMapLoader,\n  options?: boolean | Options\n): SourceMap {\n  const opts =\n    typeof options === 'object' ? options : { excludeContent: !!options, decodedMappings: false };\n  const tree = buildSourceMapTree(input, loader);\n  return new SourceMap(traceMappings(tree), opts);\n}\n"],
  "mappings": "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",
  "names": ["url", "module", "__commonJS", "exports", "module", "resolveUri", "sourceIndex", "__commonJS", "exports", "module", "cast", "GenMapping", "decodedMappings", "source", "maybeAddSegment", "setSourceContent", "setIgnore", "traceSegment", "TraceMap", "toDecodedMap", "toEncodedMap"]
}
